---
title: 复制含有随机指针的链表
date: 2018-1-26 10:31:11
categories: 算法
---

> 带随机指针的节点是一种特殊的数据结构，它的结构如下

```
public class Node {
    public Node next;
    public int value;
    public Node rand;

    public Node(int data) {
        this.value = data;
    }
}
```

#### 普通解法

思路：

1. 从头到尾遍历链表，每个节电都复制生成相应的副本节点，然后将对应关系放入哈希表map中
2. 第二次从左到右遍历链表，设置每一个节点的next和rand指针
3. 将第一个节点返回

具体算法如下：

```
public Node copyListWithRand1(Node head) {
        HashMap<Node, Node> map = new HashMap<>();
        Node cur = head;
        while (cur != null) {
            map.put(cur, new Node(cur.value));
            cur = cur.next;
        }
        cur = head;
        while (cur != null) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).rand = map.get(cur.rand);
            cur = cur.next;
        }
        return map.get(head);
    }
```

#### 进阶解法

> 进阶解法不适用哈希表map，仅仅使用有限几个变量

思路如下：

1. 从头到尾遍历链表，对每个节点cur都复制生成相应的副本节点copy，然后把copy放在cur和下一届要遍历的节点的中间
2. 第二次遍历链表，在遍历时设置每一个节点的rand指针
3. 分离节点与副本节点
4. 将第一个节点返回

算法如下：

```
public Node copyListWithRand2(Node head) {
        if (head == null) {
            return null;
        }
        Node cur = head;
        Node next = null;
        while (cur != null) {
            next = cur.next;
            cur.next = new Node(cur.value);
            cur.next.next = next;
            cur = next;
        }
        cur = head;
        Node curCopy = null;
        while (cur != null) {
            next = cur.next.next;
            curCopy = cur.next;
            curCopy.rand = cur.rand!= null? cur.rand.next :null;
            cur = next;
        }
        Node res = head.next;
        cur = head;
        while (cur != null) {
            next = cur.next.next;
            curCopy = cur.next;
            cur.next = next;
            curCopy.next = next != null?next.next :null;
            cur =next;
        }
        return res;
    }
```