---
title: 约瑟夫环问题
date: 2018-1-23 12:02:04
categories: 算法
---

> 约瑟夫环问题可以分为普通和进阶两个，区别就是进阶问题需要考虑时间复杂度，而普通问题则没有这个需求

### 普通难度

普通解法其实非常简单，具体思路如下：

1. 如果链表为空或者链表节点数为1或者m小于1，则直接返回
2. 在环型链表中遍历每个节点，不断转圈，不断让每个节点报数
3. 当报数到达m时，就删除当前报数的节点
4. 删除节点后，把链表连成环装，重复这个过程
5. 直到剩下最后一个节点时，结束

##### 算法如下：

```
public Node josephusKill(Node head, int m) {
        if (head == null || head.next == head || m < 1) {
            return head;
        }
        Node last = head;
        while (last.next != head) {
            last = last.next;
        }
        int count = 0;
        while (head != last) {
            if (++count == m) {
                last.next = head.next;
                count = 0;
            } else {
                last = last.next;
            }
            head = last.next;
        }
        return head;
    }
```

> 这个算法没有实现时间复杂度为O（N）的要求

### 进阶

进阶的算法中使用了递归的思想，具体思路如下：

1. 与普通算法一样，先进行判断
2. 遍历链表，求节点个数即为n
3. 递归求生存节点的编号，由数学的思想直接找出对应的编号
4. 根据生存节点的编号，遍历链表找到该节点

##### 算法如下：

```
public Node josephusKill2(Node head, int m) {
        if (head == null || head.next == head || m < 1) {
            return head;
        }
        Node cur = head.next;
        int tmp = 1;
        while (cur != head) {
            tmp ++;
            cur = cur.next;
        }
        tmp = getLive(tmp, m);
        while (--tmp != 0) {
            head = head.next;
        }
        head.next = head;
        return head;
    }

    public int getLive(int i, int m) {
        if (i ==1) {
            return 1;
        }
        return (getLive(i-1, m) + m - 1) % i + 1;
    }
```

