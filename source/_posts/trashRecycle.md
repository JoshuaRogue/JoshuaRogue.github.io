---
title: 垃圾回收机制
date: 2018-02-14 15:49:45
categories: Java
---

### 内存区域
一块Java堆空间一般分为三个部分：年轻代、年老代和永久代（java8之前为永久代，java8移除了永久代，改为了元空间）

各个部分的对比如下：

部分 | 特点 | 存放对象 | 回收算法
--- | --- | --- | ---
新生代(Young Generation) | 存活对象少，垃圾多 | 刚刚创建的对象 | Copying算法
年老代(Old Generation) | 存活对象多，垃圾少 | 存活了一段时间的对象 | 标记(Mark)算法
持久代(Permanent Generation)(已移除) | 对垃圾回收没有显著影响 | 静态的类和方法 | 无
元空间(Metaspace)(代替持久代) | 与堆不相连的本地内存区域 | 类的元数据信息 | 无

#### 新生代

##### 简介

新生代分为三个区，一个Eden区，另外的两个S0和S1都是Survivor区（这两个区本质一样，可互换）,程序中生成的大部分新的对象都是在Eden区中，当Eden区满时，还存活的对象将被复制到其中一个Survivor区，当此Survivor区的对象占用空间满时，此区存活的对象又被复制到另一个Survivor区，当这个Survivor区也满时，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到年老代。

##### Copying算法

扫描出存活的对象，并复制到一块新的完全未使用的空间中，就是在Eden、S0和S1之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在Young Generation区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从Eden到Survivor，最后到Old Generation。

> Eden：S0：S1默认为8：1：1

#### 年老代

##### 简介

年老代存放的是上面年轻代复制过来的对象，也就是在年轻代中还存活的对象，并且区满了复制过来的。一般来说，年老代中的生命周期都比较长。

##### Mark算法

扫描出存活的对象，然后再回收未被标记的对象，回收后对空出的空间要么合并，要么标记出来便于下次分配，以减少内存碎片带来的效率损耗。

#### 持久代

用于存放静态的类和方法，持久代对垃圾回收算法没有显著影响。

> 持久代在JDK8.0时已经被废弃，元空间取而代之。

#### 元空间

用于存放类的元数据信息，在JDK8.0中出现，替代了持久代，相比于持久代，因为它是在与堆不相连的内存区域中，所以可以被JVM动态扩展。

#### 内存对象的处理过程

1. 对象创建后在Eden区
2. 执行GC时，如果对象仍然存过，则复制到S0区
3. 当S0区满时，该区存活对象将复制到S1区，然后S0清空，接下来S0和S1角色互换
4. 当第三步达到一定次数后，存活对象将被复制到Old Generation（年老代）
5. 当这个对象在Old Generation区域停留的时间达到一定程度时，它会被移动到Old Generation，最后积累一定时间再移动到Permanent Generation区域（JDK8.0为MetaSpace区域）