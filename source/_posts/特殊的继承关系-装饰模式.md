---
title: 特殊的继承关系-装饰模式
date: 2018-1-20 13:02:04
categories: 设计模式
---

> 装饰模式使用一种对客户端透明的方案来动态地扩展对象的功能，同时它也是继承方案的一种替代方案之一。

这里举一个简答的汽车改装的例子来说明以下装饰模式的组成

#### 基本抽象类

```
public abstract class Car {
    public abstract void have();
}
```

#### 具体类：继承基本抽象类

```
public class Limousine extends Car {
    @Override
    public void have() {
        System.out.println("有基本的配置");
    }
}
```

这是需要装饰的类，所以只需要最基本的东西

#### 装饰抽象类

```
public abstract class CarRefit extends Car {
    protected Car car;
    public CarRefit(Car car) {
        this.car = car;
    }

    @Override
    public void have() {
        car.have();
    }
}
```

在装饰类中我们需要持有一个基本类的对象，以便进行装饰操作

#### 具体装饰类
1.
```
public class ExpensiveRefit extends CarRefit {
    public ExpensiveRefit(Car car) {
        super(car);
    }

    @Override
    public void have() {
        super.have();
        haveHUD();
        haveBetterEngine();
    }

    private void haveHUD() {
        System.out.println("加装了HUD");
    }

    private void haveBetterEngine() {
        System.out.println("加装了更好的发动机");
    }
}
```

2.
```
public class OtherRefit extends CarRefit {
    public OtherRefit(Car car) {
        super(car);
    }

    @Override
    public void have() {
        super.have();
        havePaint();
        haveEmpennage();
    }

    private void havePaint() {
        System.out.println("加装了个性喷漆");
    }

    private void haveEmpennage() {
        System.out.println("加装了尾翼");
    }
}
```

使用如下：

```
public class Main {
    public static void main(String[] args) {
        Limousine limousine = new Limousine();
        ExpensiveRefit expensiveRefit = new ExpensiveRefit(limousine);
        expensiveRefit.have();
        OtherRefit otherRefit = new OtherRefit(limousine);
        otherRefit.have();
    }
}
```

结果

![1.PNG](https://i.loli.net/2018/01/23/5a6695d1aebc5.png)


> 由上可知，装饰模式不需要依靠继承来实现功能的扩展，最重要的一步是抽象装饰类