---
title: 创建同一”类别“下的对象-抽象工厂模式
date: 2018-1-12 12:05:04
categories: 设计模式
---

> 抽象工厂模式看起来与工厂方法模式相似，但工厂方法模式构建的是继承同一抽象类的对象，而抽象工厂模式创建出的对象并不是继承于同一基类的，所以，我们无法使用工厂方法模式那样的反射来创建对象

### 抽象工厂模式的类主要分为四类，分别是：抽象工厂类、具体工厂类、抽象产品类、具体产品类。

> 与工厂方法模式不同的地方是工厂方法模式的抽象产品类和具体工厂类只有一个，而抽象工厂模式的抽象产品类可能有许多个，具体工厂类也可能有许多个，其相当于每个产品都有不同的组件据称

#### 抽象产品类

```
public abstract class AbstractPartA {
    public abstract void statement();
}
```

```
public abstract class AbstractPartB {
    public abstract void statement();
}
```

#### 具体产品类

```
public class PartA1 extends AbstractPartA {
    @Override
    public void statement() {
        System.out.println("PartA1");
    }
}
```

```
public class PartA2 extends AbstractPartA {
    @Override
    public void statement() {
        System.out.println("PartA2");
    }
}
```

```
public class PartB1 extends AbstractPartB {
    @Override
    public void statement() {
        System.out.println("PartB1");
    }
}
```

```
public class PartB2 extends AbstractPartB {
    @Override
    public void statement() {
        System.out.println("PartB2");
    }
}
```
> 这里的具体产品类类似于一个产品的部件有很多的等级，A与B是两个不同的部件，而A1和A2则代表了两个不同的等级，可以假设这里的A1要比A2好一点，贵一些
#### 抽象工厂类

```
public abstract class AbstractFactory {
    public abstract AbstractPartA createPartA();
    public abstract AbstractPartB createPartB();
}
```

#### 具体工厂类

> 具体工厂类类似于上面各种具体产品的组合

```
public class ProductFactoryOne extends AbstractFactory {
    @Override
    public AbstractPartA createPartA() {
        return new PartA1();
    }

    @Override
    public AbstractPartB createPartB() {
        return new PartB2();
    }
}
```

```
public class ProductFactoryTwo extends AbstractFactory {
    @Override
    public AbstractPartA createPartA() {
        return new PartA2();
    }

    @Override
    public AbstractPartB createPartB() {
        return new PartB2();
    }
}
```

##### 当然，这里的组合方式不知这两种，应该有四种，这里就不一一列举出来了



