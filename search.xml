<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Encryption, Encoding, Hash and related</title>
    <url>/2020/04/19/Encryption-Encoding-Hash-and-related/</url>
    <content><![CDATA[<h1 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h1><p>There are two useful encrypt algorithms, symmetry encryption and asymmetry encryption.</p>
<h2 id="Symmetry-Encryption"><a href="#Symmetry-Encryption" class="headerlink" title="Symmetry Encryption"></a>Symmetry Encryption</h2><p><img src="https://i.loli.net/2020/04/19/h5kJGc4peL6i7xS.png" alt="symmetry_enctypt.png"></p>
<p>Symmetry encryption use same secret key to encrypt data and decrypt data.</p>
<p>Examples: AES, DES</p>
<blockquote>
<p>The secret problem of symmetry of secret key, it is unsafe to transfer secret key on a unsafe network.</p>
</blockquote>
<h2 id="Asymmetry-Encryption"><a href="#Asymmetry-Encryption" class="headerlink" title="Asymmetry Encryption"></a>Asymmetry Encryption</h2><p>//todo finish it in future</p>
]]></content>
      <categories>
        <category>data basement</category>
      </categories>
  </entry>
  <entry>
    <title>Http&#39;s  concept、working mechanism  and data construction</title>
    <url>/2020/04/13/Http-s-concept%E3%80%81working-mashanism-and-data-construction/</url>
    <content><![CDATA[<h1 id="Http’s-Concept"><a href="#Http’s-Concept" class="headerlink" title="Http’s Concept"></a>Http’s Concept</h1><p>Http is a abbreviation of Hypertext Transfer Protocol, it runs in the application layer of network.</p>
<p>Hypertext means expanded text, we can put html content in it, and html content can provide a link refer to other text content(hyperlink).</p>
<h1 id="Http’s-Working-Mechanism"><a href="#Http’s-Working-Mechanism" class="headerlink" title="Http’s Working Mechanism"></a>Http’s Working Mechanism</h1><p>The most common scene to use http in our life is browsing website on our computer and use application on  mobile phone, the work mechanism is this:</p>
<h2 id="computer-browser"><a href="#computer-browser" class="headerlink" title="computer browser"></a>computer browser</h2><ol>
<li>input url in computer browser</li>
<li>computer browser build http request message</li>
<li>http message send to goal server via DNS server</li>
<li>server return response message</li>
<li>computer browser analyze response message and rending content of response message via render engine</li>
</ol>
<h2 id="mobile-phone-application"><a href="#mobile-phone-application" class="headerlink" title="mobile phone application"></a>mobile phone application</h2><ol>
<li>click or open user interface </li>
<li>application build request message in code</li>
<li>send request message to server via DNS server</li>
<li>server return response message</li>
<li>application received response message and analyze it(in code) and do their own work.</li>
</ol>
<p>The general flow of those two scenes is similar.</p>
<h2 id="the-relationship-between-url-and-http"><a href="#the-relationship-between-url-and-http" class="headerlink" title="the relationship between url and http"></a>the relationship between url and http</h2><p>For example, this url:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/wongzy</span><br></pre></td></tr></table></figure>
<p>It can be divided to three parts, protocol type, host address and path</p>
<p><em>https</em> is protocol type<br><em>github.com</em> is host address<br><em>/wongay</em> is path</p>
<h1 id="Message-construction"><a href="#Message-construction" class="headerlink" title="Message construction"></a>Message construction</h1><h2 id="request-message-construction"><a href="#request-message-construction" class="headerlink" title="request message construction"></a>request message construction</h2><p><img src="https://i.loli.net/2020/04/18/zY4NpJZaXqtIQuK.png" alt="http1.png"></p>
<p>Request message can be divided into three parts: Request Line、Headers and Body.</p>
<ul>
<li>Request Line: it must contains request method [POST], path [/wongzy] and protocol version [http/1.1]</li>
<li>Header: it must contains host [github.com], and other header is optional</li>
<li>body: different from other two parts(Request Line and Header), it can be empty</li>
</ul>
<h3 id="request-method"><a href="#request-method" class="headerlink" title="request method"></a>request method</h3><p>Useful request methods includes several methods and their standard as follows:</p>
<ol>
<li>GET: 1. for request resource 2. do not amend service resource 3. request message <em>do not have body</em></li>
<li>POST: 1. used to <em>put or amend</em> resources in server 2. request message <em>has body</em> to put or amend resources</li>
<li>PUT: 1. used to <em>amend</em> resources in server 2. request message <em>has body</em> to amend resources</li>
<li>DELETE: 1. used to delete body 2. request message <em>do not have body</em></li>
<li>HEAD: 1. to get resources’ message 2. request message <em>do not have body</em> 3. response message <em>do not have body</em></li>
</ol>
<h2 id="response-message-construction"><a href="#response-message-construction" class="headerlink" title="response message construction"></a>response message construction</h2><p><img src="https://i.loli.net/2020/04/18/URIoutxTmYfV9kl.png" alt="http2.png"></p>
<p>Response message can be divided into three parts: Status Line、 Header and Body.</p>
<ul>
<li>Status Line: it must contains protocol[http/1.1], status code [200], and response message [ok]</li>
<li>Header: depend on server</li>
<li>body: it can be empty</li>
</ul>
<h3 id="status-code"><a href="#status-code" class="headerlink" title="status code"></a>status code</h3><p>Common code includes five types, and their sense as follows:</p>
<ul>
<li>1XX: temporary message，for example : 100[continue sending], 101[changing protocol]</li>
<li>2XX: request successfully code, for example : 200[OK], 201[build successfully]</li>
<li>3XX: redirecting, for example: 301[moved forever], 302[moved temporary],304[content not change]</li>
<li>4XX: client error, for example: 400[client request error]、401[authentication fail]、403[forbidden]、404[resource not fund]</li>
<li>5XX: server error, for example: 500[internal error]</li>
</ul>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>Header is a important construction of Http message, it can be regard as a content summary, it has a official name, metadata.</p>
<p>it mainly includes those types:</p>
<h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>Used in request message, to find goal server via mainframe.</p>
<h3 id="content-Type"><a href="#content-Type" class="headerlink" title="content-Type"></a>content-Type</h3><p>To declare content’s type, included： </p>
<h4 id="text-html"><a href="#text-html" class="headerlink" title="text/html"></a>text/html</h4><p>Html document</p>
<h4 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded"></a>x-www-form-urlencoded</h4><p>Plain text form</p>
<h4 id="multitype-form-data"><a href="#multitype-form-data" class="headerlink" title="multitype/form-data"></a>multitype/form-data</h4><p>Binary resources, and those resources can be divided by boundary</p>
<h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4><p>application/json , image/jpeg , application/zip …</p>
<h3 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h3><p>Body’s length(unit:byte)</p>
<h3 id="Transfer-Encoding-chunked"><a href="#Transfer-Encoding-chunked" class="headerlink" title="Transfer-Encoding: chunked"></a>Transfer-Encoding: chunked</h3><p>Used to response as soon as possible, can not use together with content-length, body can transfer by chunk， and it would give serial number in body to declare whether data is transferred finish.</p>
<h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>Give url after redirect.</p>
<h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h3><p>Give what platform(computer or phone) user used.</p>
<h3 id="Range-Accept-Range"><a href="#Range-Accept-Range" class="headerlink" title="Range / Accept-Range"></a>Range / Accept-Range</h3><p>Declare resource data range in body, used to breakpoint resume and multithreading download.</p>
<h4 id="Accept-Range"><a href="#Accept-Range" class="headerlink" title="Accept-Range"></a>Accept-Range</h4><p>Used in response message, it declare data can be divided by which unit, like byte.</p>
<h4 id="Range-bytes"><a href="#Range-bytes" class="headerlink" title="Range: bytes=-"></a>Range: bytes=<start>-<end></end></start></h4><p>Used in request message, it declare the range of data client requested</p>
<h4 id="Content-Range-total"><a href="#Content-Range-total" class="headerlink" title="Content-Range:-/total"></a>Content-Range:<start>-<end>/total</end></start></h4><p>Used in response message, declare the range of data in body.</p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>Declare whether data can be cached in middle point.</p>
<h3 id="other-Headers"><a href="#other-Headers" class="headerlink" title="other Headers"></a>other Headers</h3><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>Used in request message, declare which type of content client can accept, for example : text/html.</p>
<blockquote>
<p>opposite: content-type</p>
</blockquote>
<h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p>Used in request message, declare which charset of content client can accept, for example : utf-8.</p>
<h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p>Used in request message, declare which encoding type client can accept, for example : gzip.</p>
<h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><p>Declare content’s encoding type of body.</p>
<h1 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h1><p>In Wiki， Rest means Representational state transfer， it is a really abstract concept. Roy Filed come up with Rest based on the exist of HTTP，Rest is extracted from http.</p>
<p>To use Rest correctly, we should obey http’s standard, but unfortunately, a large number of chinese company do not obey this(I do not know foreign company), event in many international company, they use method in a incorrect way, use POST do every thing in request message.</p>
]]></content>
      <categories>
        <category>Network related</category>
      </categories>
  </entry>
  <entry>
    <title>deep understand of Android ActivityManagerService</title>
    <url>/2019/10/03/deep-understanding-of-Android-ActivityManagerService/</url>
    <content><![CDATA[<h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p>AndroidManagerService(abbreviation as AMS) is the most vital service of Android, it mainly in charge of four component’s launching, switching、dispatching and manage the process of application, it plays a role as the manager process and dispatching module to the operating system. For this reason, it is very import to Android.</p>
<p>we will analyze AMS from these aspects as follow:</p>
<ul>
<li><p>as other service, we will analyze how ActivityManagerService start and trace it’s invoking track.</p>
</li>
<li><p>launch a Activity by a am command, analyze how the application build, start, and how they interact with AMS.</p>
</li>
<li><p>use Broadcast and Service as samples, analyze the transaction track of Broadcast and Service in AMS. among this, we will give a flow chart for the transaction of Service .</p>
</li>
<li><p>by starting with a Crash application process, analyze how AMS transact the “testament”.</p>
</li>
</ul>
<blockquote>
<p>except this four point, we will do a unified analysis to the dispatching of process and the managing of memory.</p>
</blockquote>
<p>this is a class diagram about AMS’s family, see the picture followed:</p>
<p><img src="https://i.loli.net/2019/10/03/BMTE1SrhL2zetbc.png" alt="AMSFamily.PNG"></p>
<p>from the chart,we can know:</p>
<ul>
<li><p>AMS was derived by ActivityManagerNative, and it realize Watchdog.Monitor and BatteryStatsImpl.BatterCallback interface， and AMN was derived by  Binder, it realized IActivityManager interface.</p>
</li>
<li><p>client use ActivityManager class, because of AMS is System’s core service, lots of API can not be opened to use, so the designer did not add ActivityManager to AMS family directly. ActivityManager can obtain a ActivityManagerProxy object by invoking AMN’s getDefault method, Activity Manager can interact with AMS by ActivityManagerProxy.</p>
</li>
</ul>
<h1 id="be-familiar-with-ActivityManagerService"><a href="#be-familiar-with-ActivityManagerService" class="headerlink" title="be familiar with ActivityManagerService"></a>be familiar with ActivityManagerService</h1><p>AMS was built by system_server’s ServerThread thread, extract its invoke track, codes as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.invoke main method,obtain a Context object</span><br><span class="line">context = ActivityManagerService.main(factoryTest);</span><br><span class="line">//2.setSystemProcess: so system_server process can add to AMS and be managed by it</span><br><span class="line">ActivityManagerService.setProecss();</span><br><span class="line">//3.installSystem: put SettingProvider to work in system_server process</span><br><span class="line">ActivityManagerService.installSystemProviders();</span><br><span class="line">//4.save WindowManagerService in inside (call it WMS later)</span><br><span class="line">ActivityManagerService.self().setWindowManager(wm);</span><br><span class="line">//5. interact with WMS, display &quot;start progrress&quot; dialog</span><br><span class="line">ActivityManagerNative.getDefault().showBootMessage(</span><br><span class="line">context.getResources().getText(</span><br><span class="line">//this string means: launching application program</span><br><span class="line">com.android.internal.R.string.android_upgrading_starting_apps), false);</span><br><span class="line">//6. AMS is the core in system, other service&apos;s systemReady can only be invoked by AMS after AMS ready</span><br><span class="line">//attention! there are a little Service be ready before AMS systemReady, it did not influence analysis in here</span><br><span class="line">ActivityManagerService.self().systemReady(new Runnable() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">startSystemUI(contextF); //launch systemUI, so, status bar was ready</span><br><span class="line">if (batteryF != null ) batteryF.systemReady();</span><br><span class="line">if (networkManagementF != null ) networkManagementF.systemReady();</span><br><span class="line">......</span><br><span class="line">Watchdog.getInstance().start(); // launch Watchdog </span><br><span class="line">...... //invoke other service&apos;s systemReady method</span><br></pre></td></tr></table></figure>
<p>in the codes above, listed six significant point and sample explain about these invoke, in this session we all analyze interaction with WindowManagerService(AMS) except 4,5 point.</p>
<h2 id="analysis-to-ActivityManagerService’s-main-method"><a href="#analysis-to-ActivityManagerService’s-main-method" class="headerlink" title="analysis to ActivityManagerService’s main method"></a>analysis to ActivityManagerService’s main method</h2><p>AMS’s Main method would return a Context object, what can be slather used by other services. With this context, we can do many things(for example, obtain the resources in environment and java class message). but what a context does AMS’s main method returned?see the code followed:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final Context main(int factoryTest) &#123;</span><br><span class="line">AThread thr = new AThread(); //1.build a AThread Object</span><br><span class="line">thr.start();</span><br><span class="line">......//wait until build thr success</span><br><span class="line">ActivityManagerService m = thr.mService;</span><br><span class="line">mSelf = m;</span><br><span class="line">//2.invoke ActivityThread&apos;s systemMain Method</span><br><span class="line">ActivityThread at = ActivityThread.systemMain();</span><br><span class="line">mSystemThread = at;</span><br><span class="line">//3.obtain a Context Object, attenation, the method be invoked named getSystemContext, what is SystemContext?</span><br><span class="line">Context context = at.getSystemContext();</span><br><span class="line">context.setTheme(android.R.style.Theme_Holo);</span><br><span class="line">m.mContext = context;</span><br><span class="line">m.mfactoryTest = factoryTest;</span><br><span class="line">//ActivityStack is the vital class for AMS to manage Activity&apos;s launch and dispatch, we will analyze it in the future</span><br><span class="line">m.mMainStack = new ActivityStack(m, context, true);</span><br><span class="line">//invoke BSS&apos;s publish method, this knowledge point we are introduced before.</span><br><span class="line">m.mBatteryStatsService.publish(context);</span><br><span class="line">// another service: UsageStatsService.</span><br><span class="line">m.mUsageStatsService.publish(context);</span><br><span class="line">synchronized(thr) &#123;</span><br><span class="line">thr.mReady = true;</span><br><span class="line">thr.notifyAll();//inform thr thread that this thread&apos;s mission finished</span><br><span class="line">&#125;</span><br><span class="line">//4.invoke AMS&apos;s startRunning method</span><br><span class="line">m.startRunning(null, null, null, null);</span><br><span class="line">return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>in Main method, we enumerated four viral method, they are:</p>
<ul>
<li><p>build AThread thread. Although AMS’s main method was invoked by ServerThread, but AMS’s own job did not put to ServerThread to finish, it create a new thread - AThread thread.</p>
</li>
<li><p>ActivityThread.systemMain method. init ActivityThread object.</p>
</li>
<li><p>ActivityThread.getSystemContext method. to acquire a Context object, from this method name we can see, this Context represent System’s context environment.</p>
</li>
<li><p>AMS’s startRunning method.</p>
</li>
</ul>
<p>attention! in main method, there is a “wait” and a “notifyAll”, because:</p>
<ol>
<li><p>main method need wait for AThread’s thread launch and finish a part of mission.</p>
</li>
<li><p>after AThread finishing a part of job, it will wait for the finish of main method.</p>
</li>
</ol>
<blockquote>
<p>this situation of two thread waiting for each other, is rare in Android code </p>
</blockquote>
<h3 id="analysis-to-AThread"><a href="#analysis-to-AThread" class="headerlink" title="analysis to AThread"></a>analysis to AThread</h3><p>in essence, AThread is a thread which supports message loop and transact, its main job is to build AMS object, then notify AMS’s main method. so, this AMS object is what the main method waited.</p>
<h4 id="the-construct-method-of-AMS"><a href="#the-construct-method-of-AMS" class="headerlink" title="the construct method of AMS"></a>the construct method of AMS</h4><p>there are several mission which AMS has done:</p>
<ul>
<li><p>build BSS, USS, mProcessStat(type of ProcessState), mProcessStatsThread thread, those are all related to system’s running status statistics.</p>
</li>
<li><p>build /data/system catalog,  assign to mCompatModePackage (type of CompatModePackage) and mConfiguration (type of Configuration)’s fields.</p>
</li>
</ul>
<h4 id="analysis-to-ActivityThread-systemMain"><a href="#analysis-to-ActivityThread-systemMain" class="headerlink" title="analysis to ActivityThread.systemMain"></a>analysis to ActivityThread.systemMain</h4><p>ActivityThread is a vital class in Android framework, it represent the main thread in a application’s process(for application process, Activity Thread’s main method was certainly invoked by process’s main thread). its responsibility is dispatch and transact the four component which runs in this thread.</p>
<p>attention! Application process are indicate those process which runs APK, they are derived(fork) by Zyote, relatively, there are system process(include Zygote and system_server).</p>
<p>the code of ActivityThread.systemMain</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final ActivityThread systemMain()&#123;</span><br><span class="line">HardwareRender.disable(true);//forbid hardware render accelerate</span><br><span class="line">// build a ActivityThread object, its construct method is very simple</span><br><span class="line">ActivityThread thread = new ActivityThread();</span><br><span class="line">thread.attach(true); //invoke its attach method, its params is true</span><br><span class="line">return thrad;</span><br></pre></td></tr></table></figure>
<p>as see above, ActivityThread represent its application process(which runs APK) main thread,but system_server was not a application process. so why here need ActivityThread?</p>
<p>remember framework-res.apk? which mentioned in the analysis of PackageManagerService. this APK does not only includes resource file, but also includes some Activity(for example, power-off dialog), these Activity are actually runs at system_server process. From ths perspective, can regard system_server as a special application process.</p>
<p>the code of ActivityThread’s attach method</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">sThreadLocal.set(this);</span><br><span class="line">mSystemThread = system; //judge whether it is system process</span><br><span class="line">if (!system) &#123;</span><br><span class="line">......//application process&apos;s transact flow</span><br><span class="line">&#125; else &#123; //system process&apos;s transact flow, this situation can only be transactted in system_server </span><br><span class="line">//when set DDMS, we can see that system_server process named system_process</span><br><span class="line">android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">//there are serveral vital role appear, see the analysis followed</span><br><span class="line">mInstrumentation = new Instrumentation();</span><br><span class="line">ContextImpl context = new ContextImpl();</span><br><span class="line">//init context, notice  the first parameter is getSystemContext</span><br><span class="line">context.init(getSystemContext(),mPackageInfo, null, this);</span><br><span class="line">//use Instrumentation to construct a Application object</span><br><span class="line">Application app = Instrumentation.newApplication(Application.class, context);</span><br><span class="line">//a process support several Application, mAllApplication are saved in its process&apos;s Application object</span><br><span class="line">mAllApplications.add(app);</span><br><span class="line">mInitialApplication = app; //set mInitialApplication</span><br><span class="line">app.onCreate(); //invoke Application&apos;s onCreate method</span><br><span class="line">&#125; ......// try/catch end</span><br><span class="line">&#125; //if (!system) to judge if end</span><br><span class="line">//register Configuration change&apos;s callback notification </span><br><span class="line">ViewRootImpl.addConfigCallback(new ComponentCallbacks2()&#123;</span><br><span class="line">public void onConfiguarationChanged(Configuaration newConfig)&#123;</span><br><span class="line">.......//when system configuaration change(for example, language change), need invoke this callback</span><br><span class="line">&#125;</span><br><span class="line">public void onLowMemory()&#123;&#125;</span><br><span class="line">public void onTrimMemory(int level)&#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>there are several vital number, respectively are type of Instrumentation class, Application class and Context class, there is their affects:</p>
<ul>
<li><p>Instrumentation: Instrumentation is a tool class.When it be used, system will build it first, then build other component via it.Otherwise, the interaction between system and components will be transmitted by Instrumentation, as thus, Instrumentation can monitor the interaction between system and those components.<br>In actually use,we can build Instrumentation’s derived class to process transact.</p>
<ul>
<li><p>Application: Application class saved a overall application status.Application are declared by <application> label of AndroidManifest.xml.We need to define Application’s derived class in actual use.</application></p>
</li>
<li><p>Context: Context is a interface that we can obtain and operate Application’s corresponding resources, classes, even the four components via it.</p>
</li>
</ul>
<blockquote>
<p>Application  in here is a Android concept, we can realize it as a container which the four components included. otherwise, a process can run several Applications(a apk can include other apks)</p>
</blockquote>
</li>
</ul>
<p>Context is a abstract class, but what built by AMS was its subclass, ContextImpl.As above, Context supplied Application’s contextual message, and how does those message transmitted to Context? This problem include two aspects:</p>
<ol>
<li>What Context actually is ?</li>
<li>What are the contextual message in Context?</li>
</ol>
<p>next step, we will analyze getSystemContext method, which be invoked above.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ContextImpl getSystemContext()</span><br><span class="line">&#123;</span><br><span class="line">synchronized(this) &#123;</span><br><span class="line">if(mSystemContext == null)&#123; //singleton mode</span><br><span class="line">ContextImpl context = ContextImpl.createSystemContext(this);</span><br><span class="line">//LoadApk is a new class imported by android2.3, which represent a APK loaded to system</span><br><span class="line">LoadApk info = new LoadedApk(this, &quot;android&quot;, context, null,</span><br><span class="line">CompatibiltyInfo.DEFAULT_COMPATIBILITY_INFO);</span><br><span class="line">//init this ContextImpl object</span><br><span class="line">context.init(info, null,this);</span><br><span class="line">//init resource message</span><br><span class="line">context.getResources().updateConfiguration(</span><br><span class="line">getConfiguaration(),getDisplayMetrcsLocked(</span><br><span class="line">Compatibility.DEFAULT_COMPATIBILITY_INFO,false));</span><br><span class="line">mSystemContext = context;//save this special ContextImpl object</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return mSystemContext;</span><br></pre></td></tr></table></figure>
<p>why method’s name is getSystemContext? because it use a LoadedApk object in the init flow path of ContextImpl. As the annotation, LoadedApk is a class imported by Android2.3，this class is used to save messages about APK(for example, resource file location, JNI library location, etc).The package which represented by LoadedApk that has the method getSystemContext to init ContextImpl, named “android”, actually is framework-res.apk, because this APK was solely used by system_server process, so call it getSystemContext.</p>
<p>We can display those classes’s relationship by this picture:</p>
<p><img src="https://i.loli.net/2019/10/13/SKUbmkCwZPGQ35I.png" alt="image002.png"></p>
<p>form the chapter we can see:</p>
<ul>
<li><p>from the derive relationship, ApplicationContentResolver was derived by ContentResolver, it mainly used to interact with ContentProvider. ContextImpl and ContextWrapper are both derived by Context, but Application was derived by ContextWrapper.</p>
</li>
<li><p>form involved aspect, the involved area of ContextImpl is most extensive. it refers Resources via mResources, refers LoadedApk via mPackageInfo, refers ActivityThread via mMainThread, and refers ApplicationContentResolver via mContentResolver.</p>
</li>
<li><p>ActivityThread represent main thread, it refers Instrumentation via mInstrumentation. Otherwise, it also saved several Application object.</p>
</li>
</ul>
<blockquote>
<p>be attention, some field number’s type is its base type in the method, but we directly refers to its real object in the picture.</p>
</blockquote>
<p>the summary of systemMain</p>
<p>after the invoke of systemMain method, we get those:</p>
<ol>
<li><p>obtain a ActivityThread, it represent application process’s main thread</p>
</li>
<li><p>obtain a Context object, the Application environment it slinkingly referred is related with framework-res.apk</p>
</li>
</ol>
<p>In summary, systemMain Method will build a Android runtime environment which is same as application process for system_server process.This sentence include two concepts:</p>
<ol>
<li><p>process: derived by operate system, is a running body in os, the code we coding must be running at a process</p>
</li>
<li><p>Android Runtime environment: Android build a runtime environment for itself. in this environment, the concept of process is blurred, component’s running status and their interaction are all in this environment.</p>
</li>
</ol>
<p>Android Runtime environment was built above process. Applications are only interact with android environment in a general way.As the same, system_server expect its inter services interact with Android environment, thus, it request to build a run environment for system_server.Because of the specialization of system_server, it invoke systemMain method, but general application invoke ActivityThread’s main method to build android environment.</p>
<p>Otherwise, although ActivityThread was defined to represent process’s main thread, but as a java class, which thread derive its instance ? In system_server we can see, Activity object was built by other thread, but in application process, ActivityThread was build by main thread.</p>
<h4 id="the-analysis-to-ActivityThread-getSystemContext"><a href="#the-analysis-to-ActivityThread-getSystemContext" class="headerlink" title="the analysis to ActivityThread.getSystemContext"></a>the analysis to ActivityThread.getSystemContext</h4><p>We have seen ActivityThread.getSystemContext Method in the previous session. After the invoke of this method, we will obtain a Context object which can represent System process.But what actually the Context is? We can see its family picture follows:</p>
<p><img src="https://i.loli.net/2019/10/17/QavJiGgsxnAP83l.png" alt="context_family"></p>
<p>From this picture we can see:</p>
<ul>
<li><p>ContextWrapper is very interesting, ContextWrapper is a proxy class actually is ContextImpl, which indicated by number mBase.Its inter function’s detail realization are totally achieved by mBase.The goal of this design is to hide ContextImpl.</p>
</li>
<li><p>Application is derived by ContextWrapper, and realized ComponentCallBacks2 interface. There is a LoadedApk type number mLoadedApk in Application.LoadedApk represent a Apk file. Because a AndroidManifest.xml file can only declared a Application label, so a Application must be bound with a LoadedApk.</p>
</li>
<li><p>Service are derived by ContextWrapper,  therein inter number mApplication indicate Application(in AndroidManifest.xml, Service can only as Application’s sub label, so Service must be bound with a Application)</p>
</li>
<li><p>ContextThemeWrapper override two methods which are related with Theme.This is related with interface, so Activity as UI container in Android system, must be derived by ContextThemeWrapper too.As same as Service, Activity indicated Application via number mApplication internally.</p>
</li>
</ul>
<h4 id="analysis-to-AMS’s-startRunning-method"><a href="#analysis-to-AMS’s-startRunning-method" class="headerlink" title="analysis to AMS’s startRunning method"></a>analysis to AMS’s startRunning method</h4><p>the code as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void startRunning(String pkg, String cls, String action,String data) &#123;</span><br><span class="line">synchronized(this) &#123;</span><br><span class="line">if(mStartRunning)</span><br><span class="line">return; //if has invoked this method, return</span><br><span class="line">mStartRunning = true;</span><br><span class="line">//mTopComponent eventually be signed to null</span><br><span class="line">mTopComponent = pkg != pkg != null &amp;&amp; cls != null ?</span><br><span class="line">new ComponentName(pkg, cls):null;</span><br><span class="line">mTopAction = action != null? action:Intent.ACTION_MAIN;</span><br><span class="line">mTopData = data; //mTopData enentually be signed to null</span><br><span class="line">if (!mSystemReady) return; //mSystemReady is false, so return directlly</span><br><span class="line">&#125;</span><br><span class="line">systemReady(null); //this method is very important, but it&apos;s a pity it not be invoked in startRunning method</span><br></pre></td></tr></table></figure>
<p>startRunning method is sample,so we do not write a lot to analyze it.</p>
<p>In here, we had analyzed all four acknowledge points, we can review what did AMS’s main method do.</p>
<h4 id="the-summary-of-ActivityManagerService’s-main-method"><a href="#the-summary-of-ActivityManagerService’s-main-method" class="headerlink" title="the summary of ActivityManagerService’s main method"></a>the summary of ActivityManagerService’s main method</h4><p>two goal of AMS’s main method:</p>
<ol>
<li><p>the first goal is easy to think out, build AMS object</p>
</li>
<li><p>the other goal is obscure but vital, is to apply a android environment to be used by system_server process.</p>
</li>
</ol>
<p>On the basis of the code analyze before, Android run environment will include two class number: Activity Thread and ContextImpl(usually its base class Context).</p>
<p>Picture follows shows some number variables in those two class, we can see ActivityThread and ContextImpl’s function via those.</p>
<p><img src="https://i.loli.net/2019/10/21/6FKdcyGLweQmRlM.png" alt="ActivityandContextImpl.PNG"></p>
<p>from the picture we can see:</p>
<ul>
<li><p>there is a mLooper number in ActivityThread, it represent a message loop. It afraid is a direct evidence for ActivityThread be called “Thread”.Otherwise, mServices is used to save Service, Activities is used to save ActivityClientRecord, and mAllApplications is used to save Application.We will introduce those variable’s function when met it.</p>
</li>
<li><p>for ContextImpl, its number variable represent thar it are related with resources and APK file.</p>
</li>
</ul>
<p>now we will analyze the third method - setSystemProcess.</p>
<blockquote>
<p>actually, SettingsProvider.apk is run in system_server process too.</p>
</blockquote>
<h3 id="the-analysis-to-AMS’s-setSystemProcess"><a href="#the-analysis-to-AMS’s-setSystemProcess" class="headerlink" title="the analysis to AMS’s setSystemProcess"></a>the analysis to AMS’s setSystemProcess</h3><p>The code of AMS’s setSystemProcess as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void setSystemProcess() &#123;</span><br><span class="line">try&#123;</span><br><span class="line">ActivityManagerService m = mSelf;</span><br><span class="line">//register several services to ServiceManager</span><br><span class="line">ServiceManager.addService(&quot;activity&quot;, m);</span><br><span class="line">//used to print memory message</span><br><span class="line">ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(m));</span><br><span class="line">/*</span><br><span class="line">the new service that android 4.0 added, used to output Applications Graphics Acceleration info. Reader can check details via command adb shell dumpsys gfxinfo.</span><br><span class="line">*/</span><br><span class="line">Servicemanager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(m));</span><br><span class="line">if (MONITOR_CPU_USAGE) //this value is default true, add cpuinfo service</span><br><span class="line">ServiceManager.addService(&quot;couinfo&quot;, new CpuBinder(m));</span><br><span class="line">//regist permission manager service PermissionController</span><br><span class="line">ServiceManager.addService(&quot;permission&quot;, new PermissionController(m));</span><br><span class="line">/* important explaination:</span><br><span class="line">query ApplicationInfo whose package named android to PackagemanagerService.</span><br><span class="line">attation this invoke, althought PKMS and AMS belong to same process, but the interaction between those still need Context.</span><br><span class="line">actually, here they can invoke PKMS&apos;s function directly, why it takes a lot effort? we will explain it clearly.</span><br><span class="line">*/</span><br><span class="line">//use AMS&apos;s mContext object</span><br><span class="line">Application info = mSelf.mContext.getPackageManager().getApplicationInfo(&quot;android&quot;, STOCK_PM_FLAFS);</span><br><span class="line">//1. invoke ActivityThread&apos;s installSYstemApplication method</span><br><span class="line">mSystemThread.installSystemApplicationInfo(info);</span><br><span class="line">synchronized(mSelf)&#123;</span><br><span class="line">//2. here refers to the processes&apos;s management of AMS, see the analysis as follows</span><br><span class="line">ProcessRecord app = mSelf.newProcessRecordLocked(mSYstemThread.getApplicationThread(),info,info.processName);</span><br><span class="line">//attation, the last parameter is a char sequence, its value is system</span><br><span class="line">app.persistent = true;</span><br><span class="line">app.pid = MY_PID;</span><br><span class="line">app.maxAdj = ProcessList.SYSTEM_ADJ;</span><br><span class="line">//3. save ProcessRecord object</span><br><span class="line">mSelf.mProcessNames.put(app.processName, app.info.uid, app);</span><br><span class="line">synchronized(mSelf.mPidsSelfLocked) &#123;</span><br><span class="line">mSelf.mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">&#125;</span><br><span class="line">//in the basis of system&apos;s current status, adjust process&apos;s dispatch priority  and OOM_Adj, we will analyze it after</span><br><span class="line">mSelf.updateLruProcessLocked(app, true, true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;...... //throw exception</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>we enumerate one important explanation and two important points:</p>
<ul>
<li><p>important explanation: AMS query ApplicationInfo named android to PKMS. In here, the interaction between AMS and PKMS was finished by Context, check the code invoked by a services of functions, we will find that AMS will request PKMS’s query function via Binder.AMS and PKMS are belong to one process, they can totally interact without Context. Why here spend a lot ? the reason is sample, Android expect the services in system_server are also interacting by android environment, for example, the unify between components’s interact interfaces and system’s future expandability.</p>
</li>
<li><p>important point one: ActivityThread’s installSystemApplicationInfo method.</p>
</li>
<li><p>important point two: ProcessRecord class, it is related with the management to process of AMS.</p>
</li>
</ul>
<h4 id="ActivityThread’s-installSystemApplication-function"><a href="#ActivityThread’s-installSystemApplication-function" class="headerlink" title="ActivityThread’s installSystemApplication function"></a>ActivityThread’s installSystemApplication function</h4><p>installSystemApplicationInfo function’s parameter is a ApplicationInfo object, this object was derived by querying the package named android of PKMS via Context(based on the knowledge above, there is only framework-res.apk is declared its package name android at current).</p>
<p>see installSystemApplicationInfo’s code, as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void installSystemApplicationInfo(Application info) &#123;</span><br><span class="line">synchronized(this)&#123;</span><br><span class="line">//the ContextImpl object returned is the object which built in AMS&apos;s main method</span><br><span class="line">ContextImpl context = getSystemContext();</span><br><span class="line">//invoke init method again, is this a repetitive invoke?</span><br><span class="line">context.init(new pk(this, &quot;android&quot;, context, info, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO), null, this);</span><br><span class="line">//create a Profiler object, used to performance statistics</span><br><span class="line">mProfiler = new Profiler();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can see the code which invoke context.init() method, reader may doubt that getSystemContext method would return mSystemContext, but there mSystemContext was initialized, why it initialized again?</p>
<p>check the code we can see:</p>
<ul>
<li><p>when first performed init, the fourth parameter in LoadedApk struct function represent ApplicationInfo is null.</p>
</li>
<li><p>when second performed init, the fourth parameter in LoadedApk struct function is not null, means that this parameter was real referred to a actual ApplicationInfo, this ApplicationInfo was derived from framework-res.apk.</p>
</li>
</ul>
<p>On the basis of the message above, readers may think: the goal for Context to perform init is only to create a Android environment, but this Context was not bound with actual ApplicationInfo.Before the second perform of init, obtain a real ApplicationInfo via the interaction between Context and PKMS,then bind this context with ApplicationInfo via init function.</p>
<p>But although we resolve the question that why init function performs twice, but a more difficult problem occurs: the Context obtained by the first time perform init was not bind with ApplicationInfo, but it is also useful, why it is necessary to bind with a ApplicationInfo ? The result is sample, because framework-res.apk(include SettingsProvider.apk we will introduced after) run in system_server. As same as all other Apk, its running need a Android environment which correctly init.</p>
<p>because framework-res.apk is a APK file, and as same as APK file, it should run in a process. AMS was used to the management and dispatch to process, so the process which run the APK should have a refer manage struct, so the next step of AMS is to match run environment and process manage struct to a unity, and manage it unified by AMS.</p>
<p>The process management struct of AMS is ProcessRecord.</p>
<h4 id="ProcessRecord-and-IApplicationThread"><a href="#ProcessRecord-and-IApplicationThread" class="headerlink" title="ProcessRecord and IApplicationThread"></a>ProcessRecord and IApplicationThread</h4><p>before the analysis to ProcessRecord, we think a problem first: how AMS interact with application process ? For example, when AMS launch a activity in other process, because this activity is running in other process, so it is necessary to AMS to interact with this process. The answer is interacting via Binder. For this, Android apply a IApplicationThread interface, this interface defined the interact function between AMS and application process. Chart follows is the interface’s family chart.</p>
<p><img src="https://i.loli.net/2019/10/27/8gyVjeQOxUoNK5C.png" alt="接口的家族图谱.PNG"></p>
<p>From the chart we can see:</p>
<ul>
<li><p>ApplicationThreadNative realized IApplicationThread interface. From the method name the interface defined we can see, AMS interact with application via it. For example, when launch a Activity it invoke its interface’s scheduleLaunchActivity method.</p>
</li>
<li><p>ApplicationThread refers its intern class ApplicationThread via number variable mAppThread, and Application derived from ApplicationThreadNative.</p>
<p>now there is IApplicationThread interface, with it, AMS can interact with application process via it. For example, for a sample method follows:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void scheduleStopActivity(IBinder token, boolean showWindow, int configChanges) &#123;</span><br><span class="line">queueOrSendMessage(// this method will send message to a Handle intern</span><br><span class="line">showWindow? H.STOP_ACTIVITY_SHOW:H.STOP_ACTIVITY_HIDE, token, 0, configChanges);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When AMS want to stop a Activity, it will invoke corresponding process IApplicationThread Binder client’s scheduleStopActivity method. What the function realized is send a message to the process which ActivityThread is in.In application process, ActivityThread runs in main thread, os this message will be transacted in main thread.</p>
<blockquote>
<p>tips：Activity’s onStop function will be invoked in main thread.</p>
</blockquote>
<p>IApplication is rarely a interface for interacting between AMS and another process, except this, AMS need more message about this process.In AMS, process’s massage saved in ProcessRecord data struct.So, what is ProcessRecord? We need see newProcessRecordLocked function before answer the method, its codes as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final ProcessRecord newProcessReoordLocked(IApplicationThread thread, ApplicationInfo info, String customProcess) &#123;</span><br><span class="line">String proc = customProcess != null ? customProcess:info.processName;</span><br><span class="line">BatteryStatsImpl.Uid.Proc ps = null;</span><br><span class="line">BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">synchronized(stats) &#123;</span><br><span class="line">//BSImpl will build a battery statics item for this process</span><br><span class="line">ps = stats.getProcessStatsLocked(info.uid, proc);</span><br><span class="line">&#125;</span><br><span class="line">//build a ProcessRecord object represent corresponding process. AMS and its process&apos;s object is the second parameter thread.</span><br><span class="line">return new ProcessRecord(ps, thread, info, proc);</span><br></pre></td></tr></table></figure>
<p>There are a lot of number variable in ProcessRecord, we see which number variable init in its construct function:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ProcessRecord(BatteryStatsImpl.Uid.Proc_BatteryStats, IApplicationThread_thread.ApplicationInfo_info, String_processName) &#123;</span><br><span class="line">batteryStats = _batteryStats; //used to statics for battery</span><br><span class="line">info = _info; //save ApplicationInfo</span><br><span class="line">processName = _processName; //save process name</span><br><span class="line">//a process can run several package, pkgList used to store package name</span><br><span class="line">pkgList.add(_info.packageName);</span><br><span class="line">thread = _thread; //save IApplicationThread, can interact with application process via it</span><br><span class="line">//variables below here are related with process priority, OOM_adj. We will analyze their function later.</span><br><span class="line">maxAdj = ProcessList.EMPTY_APP_ADJ;</span><br><span class="line">hiddenAdj = ProcessList.HIDDEN_APP_MIN_ADJ;</span><br><span class="line">curRawAdj = setRawAdj = -100;</span><br><span class="line">curAdj = setAdj = -100;</span><br><span class="line">//used to controll whether this process process is always standed in memory(it will be rebotted by system even be killed), only vital process have this priority.</span><br><span class="line">persistent = false;</span><br><span class="line">removed = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Except saving IApplicationThread which interacted with application process, ProcessRecord also saved process name, different state corresponding Oom_adj value and a ApplicationInfo. Although a process can run several Application, but ProcessRecord usually saved the ApplicationInfo whose Application run in advance.</p>
<p>For now, a ProcessRecord object was built, different from other application processes, the process it corresponded is system_server.To represent it specialization, AMS signed specific value for some number variable:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.persistent = true; //sign value to true</span><br><span class="line">app.pid = MY_PID; //sign pid to system_server&apos;s process number</span><br><span class="line">app.maxAdj = ProcessList.SYSTEM_ADJ; //set max OOM_Adj, system process&apos;s default value is -16</span><br><span class="line">//In addition, app&apos;s processName was signed to &quot;system&quot;</span><br></pre></td></tr></table></figure>
<p>Now, a ProcessRecord object which indicate system_server was built.After that AMS put it in its sphere of influence.</p>
<p>There are two number variables used to save ProcessRecord, one is mProcessNames, the other is mPidsSelfLocked.Chapter follows is the struct of two number variables.</p>
<p><img src="https://i.loli.net/2019/10/29/BMsAYCJQFLfSpbh.png" alt="数据结构示意图.PNG"></p>
<h4 id="summary-of-AMS’s-setSystemProcess"><a href="#summary-of-AMS’s-setSystemProcess" class="headerlink" title="summary of AMS’s setSystemProcess"></a>summary of AMS’s setSystemProcess</h4><p>Now we review what job setSystemProcess do:</p>
<ul>
<li><p>Register AMS, meminfo, gfxinfo and other services to ServiceManager.</p>
</li>
<li><p>On the basis of ApplicationInfo which from PKMS init Android running environment, and build a ProcessRecord which represents system_server process, from now, system_server was included in AMS’s sphere of manage.</p>
</li>
</ul>
<h1 id="the-summary-of-ActivityManagerService"><a href="#the-summary-of-ActivityManagerService" class="headerlink" title="the summary of ActivityManagerService"></a>the summary of ActivityManagerService</h1><p>there are four vital and complicated method in ActivityManagerService, the knowledge point summary as follows:</p>
<ul>
<li><p>AMS’s main function : build a instance of AMS, the most important work is to build Android runtime environment, obtain a ActivityThread and a Context object.</p>
</li>
<li><p>AMS’s setSystemProcess function: this function register AMS and meminfo services to ServiceManager, otherwise, it build a ProcessRecord object for system_server object.Because AMS is the process manage and dispatch center in java world, to treat equally without discrimination to java processes, although system_server is a system process, it will be included in AMS’s manage scope.</p>
</li>
<li><p>AMS’s installSystemProviders function: load SettingProvider for system_server</p>
</li>
<li><p>AMS’s systemReady function: do ending task before finishing launch. After invoking function, Home Activity will display in user.</p>
</li>
</ul>
<p>the analysis to AMS invoke trace is the first line we  crack AMS.</p>
<h1 id="the-analysis-of-startActivity"><a href="#the-analysis-of-startActivity" class="headerlink" title="the analysis of startActivity"></a>the analysis of startActivity</h1><p>We will spend a lot on the launch flow of Activity in this section, it is the most difficult way of five ways, believe read can realize it if work hard.</p>
<h2 id="start-with-am"><a href="#start-with-am" class="headerlink" title="start with am"></a>start with am</h2><p>am is the same as pm, it is a script, it used to interact with AMS, for example, launch Activity, launch Service, send Broadcast.When we use am script to launch a activity, it eventually will invoke AMS’s startActivityAnd Wait function to deal with this launch request, it is a sample way to analyze Activity’s launch via am.</p>
<h2 id="analysis-to-AMS’s-startActivityAndWait"><a href="#analysis-to-AMS’s-startActivityAndWait" class="headerlink" title="analysis to AMS’s startActivityAndWait"></a>analysis to AMS’s startActivityAndWait</h2><p>startActivityAndWait method has lots of parameters, we acquaint with them first.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final WaitResult startActivityAndWait&#123;</span><br><span class="line">/*</span><br><span class="line">in most situaction, a launch of Activity is called by a application process, IApplicationThread is a channel which application interact with application process, it is a mark to invoke process, in this example, am is not a application process, so the caller transfer is null</span><br><span class="line">*/</span><br><span class="line">IApplicationThread caller,</span><br><span class="line">//Intent and resolvedType, in this example,resolvedType is null</span><br><span class="line">Intent intent,String resolvedType,</span><br><span class="line">//grantedUriPermissions and granteMode are relatived with perimission</span><br><span class="line">Uri[] grantedUriPermissions, //in this example, is null</span><br><span class="line">int grantedMode, //in this example, is null, used to received startActivityForResult&apos;s result</span><br><span class="line">String resultWho, //in this example, is null</span><br><span class="line">//requestCode, in this example, is 0,its value&apos;s  significance was defined by its invoker,if its value equal or bigger than zero, AMS will save it by itself,and return it by onActivityResult method.</span><br><span class="line">int requestCode,</span><br><span class="line">boolean onlyIfNeeded, // in this example, is false</span><br><span class="line">boolean debug, //is a debug process</span><br><span class="line">//those three parameters are relatvied with performance statistics</span><br><span class="line">String profileFile,</span><br><span class="line">ParceIFileDescriptor profileFd, boolean autoStopProfiler)</span><br></pre></td></tr></table></figure>
<p>the code of startActivityAndWait as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final WaitResult startActivityAndWait(IApplicationThread caller, Intent intent,String resolvedType, Uri[] grantedUriPermissions,int grantedMode, IBinder resultTo, String resultWho, int requestCode, boolean onlyifNeeded, boolean debug, String profileFile, ParcelFileDescriptor profileFd, boolean autoStopProfiler) &#123;</span><br><span class="line">// create a WaitResult object to save transact result</span><br><span class="line">WaitResult res = new WaitResult();</span><br><span class="line">//mMainStack is ActivityStack type, invoke its startActivityMayWait function</span><br><span class="line">mMainStack.startActivityMayWait(caller, -1, intent, resolvedType, grantedUriPermissions, grantedMode, resultTo, resultWho,requestCode, onlyIfNeeded, debug, profileFile, profileFd, autoStopProfiler, res, null);//last parameter is Configuration,in this example ,is null</span><br><span class="line">return res;</span><br></pre></td></tr></table></figure>
<p>mMainStack is AMS’s member variable, type is ActivityStack, this class is Activity dispatch’s core role,we will introduce base knowledge first.</p>
<h3 id="Task-Back-Stack-ActivityStack-and-Launch-mode"><a href="#Task-Back-Stack-ActivityStack-and-Launch-mode" class="headerlink" title="Task, Back Stack, ActivityStack and Launch mode"></a>Task, Back Stack, ActivityStack and Launch mode</h3><h4 id="introduce-for-Task-and-Back-Stack"><a href="#introduce-for-Task-and-Back-Stack" class="headerlink" title="introduce for Task and Back Stack"></a>introduce for Task and Back Stack</h4><p>Task is a gather of activities. Why call it Activity? Activity is an organizational unit for performing a specific function.</p>
<p>We can see a picture to distinguish task and activity, as follows:</p>
<p><img src="https://i.loli.net/2019/12/05/OZJi4cqz8DSTGrW.png" alt="stack3.PNG"></p>
<p>from this picture,A、B those two task uses different Activity to accomplish mission.Take a attention, there is no reuse in A and B task.</p>
<p>see C task again, it can subdivide to four Activities, in C task there are two activities, one use task A’s A1, task B’s B2, why task C do not create its own Activity, but use other task’s activity? Because although the thing user want to do is different, when subdivide task, it is possible to appear situation that functions of Activity is similar with other.As A1, B2 are meet requirements, it is not necessary to create activity. </p>
<p>When there are several tasks in the system, system only support task in foreground, so the activity user see is foreground, other tasks are in background, the order in background tasks is not changed.User can move the whole task to background or foreground.</p>
<blockquote>
<p>tips: readers who had used android system should know, when you long pressed Home key, system would show recent task list, users can switch in several task.</p>
</blockquote>
<p>Content above introduce what is Task and how Android divide Task and manage Activity in a abstract way, but in real code, how it designed?</p>
<h4 id="introduce-to-ActivityStack"><a href="#introduce-to-ActivityStack" class="headerlink" title="introduce to ActivityStack"></a>introduce to ActivityStack</h4><p>There are two point we should consider:</p>
<ol>
<li><p>The way to organize Activity in Task.We know that Android organize Activity by first in, last out way, as same as Stack in data struct.</p>
</li>
<li><p>The way to organize and manage several Task.</p>
</li>
</ol>
<p>Android designed a ActivityStack class to take responsibility to those mission, the struct as picture follows:</p>
<p><img src="https://i.loli.net/2019/12/06/NYxtLlcM65HBfGF.png" alt="ActivityStack.PNG"></p>
<p>From this picture we can see:</p>
<ul>
<li><p>Activity is shown by ActivityRecord, Task is shown by TaskRecord. ActivityRecord’s task member refers to the Task which its Activity in. state variable used to represent the state the Activity stand(including INITIALIZING, RESUMED, PAUSED).</p>
</li>
<li><p>ActivityStack use ArrayList mHistory to save ActivityRecord, to our surprise, this mHistory saved all Task’s ActivityRecord in System, not just for a certain Task.</p>
</li>
<li><p>ActivityStack’s mMainStack member is interesting, it represent whether this ActivityStack is main ActivityStack. Where there is a Lord, there is a servant, but current System only has a ActivityStack, and its mMainStack is true.From the name of ActivityStack we can guess, in the initialize process Android developer want to use ActivityStack to manage single Task’s ActivityRecord(this class is “State and management of a single stack of activities”), but do not know why in current code it put all Task’s ActivityRecord to mHistory, and remained mMainStack.</p>
</li>
<li><p>There are no member in ActivityStack to save TaskRecord.</p>
</li>
</ul>
<p>from content above, ActivityStack use array way to save all Task’s ActivityRecord, and no member used to save TaskRecord. But this way has its advantage and disadvantage.</p>
<ul>
<li><p>the advantage is cut the manage of TaskRecord level, directly use ActivityRecord as manage unit, this method can reduce the spend of manage.</p>
</li>
<li><p>the disadvantage is weak the concept of Task, its struct is not clearly enough.</p>
</li>
</ul>
<p>We will see several useful method which search ActivityRecord, code as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* topRunningActivityLocked:</span><br><span class="line">find first ActivityRecord which is different from notTop and not in finishing state.When notTop is null, this method would return the first ActvitiyRecord which need to display. The enter of Stack can only be Stack peek. Although mHistory is a array, but find order is from end to start, so its behavir is same as Stack.</span><br><span class="line">*/</span><br><span class="line">final ActivityRecord topRunningActivityLocked(ActivityRecord notTop) &#123;</span><br><span class="line">int i = mHistory.size() - 1;</span><br><span class="line">while(i &gt;= 0) &#123;</span><br><span class="line">ActivityRecord r = mHistory.get(i);</span><br><span class="line">if (!r.finishing&amp;&amp;r!=notTop) return r;</span><br><span class="line">i --;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>there are several similar method:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*topRunningNonDelayedActivityLocked are similar with topRunningActivityLocked, but ActivityRecord request add a item: delayeResume set false*/</span><br><span class="line">final ActivityRecord topRunningNonDelayedActivityLocked(ActivityRecord notTop) &#123;</span><br><span class="line">int i = mHistory.size() - 1;</span><br><span class="line">while(i &gt;= 0)&#123;</span><br><span class="line">ActivityRecord r = mHistory.get(i);</span><br><span class="line">//delayedResume variable control whether delay resume Activity</span><br><span class="line">if (!r.finishing &amp;&amp; !r.delayedResume &amp;&amp; r != notTop) return r;</span><br><span class="line">i --;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity also apply findActivityLocked method and find matched ActivityRecord based on Intent and ActivityInfo, as same, finding is start from end of mHistory, and another method findTaskLocked’s return value is ActivityRecord, findTaskLocked do corresponding find mission based on Task which mHistory’s ActivityRecord belong to.</p>
<p>Above is four methods are useful method in ActivityStack.</p>
<h4 id="Introduce-about-Launch-Mode"><a href="#Introduce-about-Launch-Mode" class="headerlink" title="Introduce about Launch Mode"></a>Introduce about Launch Mode</h4><p>Launch Mode used to describe Activity’s launch mode, there are four mode at current, they are “standard”, “singleTop”, “singleTask” and “singleInstance”. First see it, it was difficult to understand, but actually, it is only a “jugglery” android played.Launch Mode is designed to control relation between Activity and Task.</p>
<ul>
<li><p>standard: a Task could have several same type’s Activity, attention, it is same type, not same object.For example, there are four activities A, B, C, D in Task, if start A type’s Activity again, Task will include A, B, C, D, A. The first A and the last A is the same type, but not same object. Otherwise, there can be same type Activity in several Task.</p>
</li>
<li><p>singleTop: When a certain Task includes A, B, C, D activities, if D want to start a D type Activity, what would task be ? In singleTop mode,Task is still include A, B, C, D, but D’s onNewIntent method will be invoked, but in standard mode, Task will be included A, B, C, D, D, the last D is new created.In singleTop mode, only target Activity is at peek of the Task, it can work, For example, only when start D, it worked,if it start A, B, C, it is useless.</p>
</li>
<li><p>singleTask: in this launch mode, this Activity can only exist one instance, and it will bind with a Task.When need start this Activity, system will invoke onNewIntent method to launch it, but not create new Task and Activity. Attention, although this Activity only has a instance, but except it in Task, it can have other Activity.</p>
</li>
<li><p>singleInstance:it is a reinforced singleTask mode, a Task can only has a Activity which set singleInstance, there would be other Activity in this task. But in singleTask mode, Task can have other Activity.</p>
</li>
</ul>
<p>Attention, Android suggest normal application developer do not use the last two launch mode easily. Because those mode although those modes are named Launch Mode, but them will influence the order Activity poll, cause user acquire different experience when pressed back key.</p>
<p>Except launch mode, there are other flags to control relationship between Activity and Task, we just enumerate a little part, detail message please see Intent introduction about Intent in SDK document.</p>
<ul>
<li><p>FLAG_ACTIVITY_NEW_TASK: put target Activity to a new Task</p>
</li>
<li><p>FLAG_ACTIVITY_CLEAR_TASK: when launch a Activity, kill tasks which are related with target Activity, and launch a new Task, and start a new Task, and put target Activity to this new task, this flag must be used with FLAG_ACTIVITY_NEW_TASK.</p>
</li>
<li><p>FLAG_ACTIVITY_CLEAR_TOP: when launch a Activity which was not in the peek of stack, remove Activity which above it.For example, there are A, B, C, D in the task, when want to start B, it should remove C, D from the task, but not create a new B.</p>
</li>
</ul>
<h4 id="the-analysis-of-startActivityMayWait-of-ActivityStack"><a href="#the-analysis-of-startActivityMayWait-of-ActivityStack" class="headerlink" title="the analysis of startActivityMayWait of ActivityStack"></a>the analysis of startActivityMayWait of ActivityStack</h4><p>the target of startActivityMayWait is to start com.dfp.test.TestActivity, if system do not started this Activity before, the result of this example is:</p>
<ul>
<li><p>because set FLAG_ACTIVITY_NEW_TASK flag in am, so except build a new Activity, it will also build a TaskRecord.</p>
</li>
<li><p>also need start a new application to load and run com.dfp.test.TestActivity’s instance.</p>
</li>
<li><p>if TestActivity is not Home, it need to stop Activity which is displaying.</p>
</li>
</ul>
<p>startActivityMayWait can be mainly divide into three stage.</p>
<p>the first stage include those parts:</p>
<ul>
<li><p>search ActivityInfo which responding this Intent</p>
</li>
<li><p>transact the situation that FLAG_CANT_SAVE_STATE exist, not system do not support this situation</p>
</li>
<li><p>otherwise, acquire invoker’s pid and uid, because in this example caller is null, so obtained pid and uid are owned by process which am in.</p>
</li>
</ul>
<p>the second stage is sample, it mainly about startActivityLocked function, this function is very complicated, we will introduce it in next session.</p>
<p>the third stage’s job is do some transact after value returned, but why it need wait even the result is IActivityManager.START_SUCCESS? Because target Activity need to run in a new application process, it must wait until that application process started normally and transact related request.Attention! only if am set -W option, it can be into wait status.</p>
<h5 id="analysis-to-startActivityLocked"><a href="#analysis-to-startActivityLocked" class="headerlink" title="analysis to startActivityLocked"></a>analysis to startActivityLocked</h5><p>startActivityLocked is the important job in the second stage of startActivityMayWait, this function is quite long.</p>
<p>The main job startActivityLocked dose include that:</p>
<ul>
<li><p>transact sourceRecord and resultRecord. sourceRecord represent Activity which send this request, resultRecord represent Activity which will receive transact result(when target Activity finish things, it need to inform requester the result), in normal situation, sourceRecord and resultRecord refers to same Activity.</p>
</li>
<li><p>transact app switch.If AMS forbid app switch, it will save this launch request, wait for the time app switch is permitted.Before transact this request, it will invoke doPendingActivityLaunchesLocked method,it will first start the Pending request saved because app switch is forbidden before.</p>
</li>
<li><p>invoke startActivityUncheckedLocked to transact this pending request.</p>
</li>
</ul>
<h1 id="the-summary-of-startActivity"><a href="#the-summary-of-startActivity" class="headerlink" title="the summary of startActivity"></a>the summary of startActivity</h1><ul>
<li><p>the start of this journey is am, am is important program in Android, we use am start command to start target Activity’s launch request.</p>
</li>
<li><p>then into ActivityManagerService and ActivityStack those two core class, to launching Activity, the first stage is to find or create ActivityRecord and corresponding TaskRecord. The second is to transact Activity launch or switch related job.</p>
</li>
</ul>
<p>:</p>
]]></content>
      <categories>
        <category>Books of Deep UnderStand Android</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Android：Looper、Handler及MessageQueue</title>
    <url>/2019/09/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%EF%BC%9AMessageQueue/</url>
    <content><![CDATA[<h1 id="Looper与Handler"><a href="#Looper与Handler" class="headerlink" title="Looper与Handler"></a>Looper与Handler</h1><p>就应用程序而言，Android程序的应用程序和其他系统上先相同，都是靠消息驱动来工作的，它们大致的工作原理如下：</p>
<ol>
<li><p>有一个消息队列，可以往这个消息队列中投递消息。</p>
</li>
<li><p>有一个消息队列，不断从消息队列中取出消息，然后处理</p>
</li>
</ol>
<p>我们用下图来展示这个工作过程：</p>
<p><img src="https://i.loli.net/2019/09/16/rV2hZpR1Lv3A9OJ.png" alt="线程和消息处理.PNG"></p>
<p>从图中可以看出：</p>
<ol>
<li><p>事件源把待处理的消息加入到消息队列中，一般是加至队列头。事件源提交的消息可以是案件、触摸屏等物理事件产生的消息，也可以是系统或应用程序本身发出的请求消息。</p>
</li>
<li><p>处理线程不断从消息队列头中取出消息并处理，事件源可以把优先级高的消息放到队列头，这样，优先级高的消息就会首先被处理。</p>
</li>
</ol>
<p>在Android系统中，这些工作主要由Looper和Handler实现。</p>
<h2 id="Looper类"><a href="#Looper类" class="headerlink" title="Looper类"></a>Looper类</h2><p>Looper类用于封装消息循环，并且有一个消息队列</p>
<p>Looper类的创建最关键的就是两行代码，Looper.prepare()和Looper.loop()</p>
<h3 id="Looper-prepare"><a href="#Looper-prepare" class="headerlink" title="Looper.prepare()"></a>Looper.prepare()</h3><p>这个函数所做的其实就是构造一个Looper对象，然后设置到ThreadLocal中，在Looper的构造函数中构造了一个消息队列（MessageQueue）</p>
<h3 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a>Looper.loop()</h3><p>这个函数所做的就是取出Looper与相应的消息队列，从消息队列（MessageQueue）中取出消息，并调用该消息的Handler，交给Handler的dispatchMessage函数处理（dispatchMessage定义了一套消息处理的优先级机制，可见下文）。</p>
<h2 id="Handler类"><a href="#Handler类" class="headerlink" title="Handler类"></a>Handler类</h2><p>Handler类有点像辅助类，它封装了消息投递、消息处理等接口。</p>
<p>Handler在构造函数中其实就应用了当前线程的Looper，如果没有Looper没有将会报错，Handler的MessageQueue实际上也是Looper所创建的MessageQueue。Handler对于消息的处理大概分为这三种优先级：</p>
<ol>
<li><p>Message如果自带了callback处理，则交给callback处理，最常见的就是Handler.post(Runnable r)函数,r就是在callback</p>
</li>
<li><p>Handler如果设置了全局的mCallback,则交给mCallback处理,这个mCallback需要返回true表示消息已经被处理</p>
</li>
<li><p>如果上述都没有(1中消息没有自带的callback切2返回false),则交给Handler子类实现的handleMessage来处理,这里要求重写handleMessage函数</p>
</li>
</ol>
<h2 id="Looper和Handler的结合：HandlerThread"><a href="#Looper和Handler的结合：HandlerThread" class="headerlink" title="Looper和Handler的结合：HandlerThread"></a>Looper和Handler的结合：HandlerThread</h2><p>Looper和Handler会有什么同步关系呢？它们之间确实有同步关系，同步关系肯定与多线程有关，这种错误一般发生在Looper在初始化在不同的线程，可能发生Looper为空的情况，所以Android为我们提供了HandlerThread来避免类似的问题。</p>
<p>HandlerThread中使用了一个getLooper函数，当Looper还没被创建时，如果需要调用Looper则需要等待（wait()），创建后则notifyAll()，那么调用Looper的线程就会被唤醒。</p>
<h1 id="心系两界的MessageQueue"><a href="#心系两界的MessageQueue" class="headerlink" title="心系两界的MessageQueue"></a>心系两界的MessageQueue</h1><p>MessageQueue类封装了与消息队列有关的操作，在一个以消息驱动的系统中，最重要的两部分就是消息队列和消息处理循环。在Android2.3以前，只有Java层有资格向MessageQueue添加消息，但从Android2.3开始，MessageQueue的核心部分下移至Native层，让Native层也能通过消息循环处理任务。</p>
<h2 id="MessageQueue的创建"><a href="#MessageQueue的创建" class="headerlink" title="MessageQueue的创建"></a>MessageQueue的创建</h2><p>在Java中，MessageQueue的构造函数是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageQueue() &#123;</span><br><span class="line">nativeInit();<span class="comment">//构造函数调用nativeInit,该函数由Native层实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nativeInit()方法真正实现为android_os_message_nativeInit()函数，其代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv * env,jobject obj)</span> </span>&#123;</span><br><span class="line"><span class="comment">//NativeMessageQueue是MessageQueue在Native层的代表</span></span><br><span class="line">NativeMessageQueue * nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line">......</span><br><span class="line"><span class="comment">//将这个NativeMessageQueue对象设置到Java层保存</span></span><br><span class="line">android_os_MessageQueue_setNativeMessageQueue(env,obj,nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nativeInit函数在Native层创建了一个与MessageQueue对应的NativeMessageQueue对象，其构造函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() &#123;</span><br><span class="line"><span class="comment">/* 代表消息循环的Looper也在Native层中呈现了，根据消息驱动的知识，一个线程会有一个Looper来处理消息队列中的消息。下面一行的调用就是取得保存在线程本地存储空间</span></span><br><span class="line"><span class="comment">(Thread Local Storage)中的Looper对象*/</span></span><br><span class="line">mLooper = Looper::getForThread();</span><br><span class="line"><span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">/*如果是第一次进来，则该线程没有设置本地存储，需要新创建一个Looper，然后再将其保存到TLS中，这是很常见的一种以线程为单位的单例模式*/</span></span><br><span class="line">mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">Looper::setForThread(mLooper);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Native的Looper是Native世界中参会消息循坏的一位重要角色。虽然它的类名和Java层的Looper类一样，但此二者其实并无任何关系。</p>
<h2 id="提取消息"><a href="#提取消息" class="headerlink" title="提取消息"></a>提取消息</h2><p>当一切准备就绪后，Java层的消息循环处理，也就是Looper会在一个循环中提取并处理消息。消息的提取就是调用MessageQueue的next()方法。当消息队列为空时，next就会阻塞。MessageQueue同时支持Java层和Native层的事件，那么其next()方法该如何实现呢？具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">final Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pendingIdleHandlerCount = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> nextPoollTImeoutMills = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//mPtr保存了NativeMessageQueue的指针，调用nativePoolOnce进行等待</span></span><br><span class="line">nativePoollOnce(mPtr, nextPollTimeoutMills);</span><br><span class="line">sychronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">final <span class="keyword">long</span> now = SystemClock.uptimeMills();</span><br><span class="line"><span class="comment">//mMessages用来存储消息，这里从其中取一个消息进行处理</span></span><br><span class="line">final Message msg = mMessages;</span><br><span class="line"><span class="keyword">if</span> (msg != null) &#123;</span><br><span class="line">final <span class="keyword">long</span> when = msg.when;</span><br><span class="line"><span class="keyword">if</span> (now &gt;= when) &#123;</span><br><span class="line">mBlocked = <span class="literal">false</span>;</span><br><span class="line">mMessages = msg.next;</span><br><span class="line">msg.next = null;</span><br><span class="line">msg.markInUse();</span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line"><span class="comment">//返回一个Message用于给Looper进行派发和处理</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">nextPoolTimeoutMillis = (<span class="keyword">int</span>) Math.min(when - now, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">nextPoolTimeoutMillis = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/*处理注册的IdleHandler，当MessageQueue中没有Message时，Looper会调用IdleHandler做一些工作，例如垃圾回收等*/</span></span><br><span class="line">......</span><br><span class="line">pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">nextPollTimeoutMills = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们可以得到，进行消息处理的流程是从nativePollOnce开始的，那么这个nativePollOnce什么时候才会返回呢？我们可以从投递Message入手</p>
<p>MessageQueue的enqueueMessage函数完成将一个Message投递到MessageQueue的工作，大概是如下过程：</p>
<ol>
<li><p>将Message按执行时间排序，并加入消息队列</p>
</li>
<li><p>根据情况调用nativeWake函数，以触发nativePollOnce函数，结束等待</p>
</li>
</ol>
<p>nativeWake函数则会调用native Looper的wake函数，向通道（Pipe）的写端写入一个字符“W”，这样管道的读端就会因为有数据可读而从等待状态中醒来。</p>
<p>当写端被唤醒之后，nativePollOnce就会返回，从而Message就会被处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在Windows上，线程间通知无外乎就是使用Event，在Linux上，使用POSIX的condition+mutex，也能完成同样的操作，但是这种方式在linux中用得相对较少，而是大量使用pipe，创建两个fd。当线程1想唤醒线程2的时候，就可以往writeFD中写数据，这样线程2阻塞在readFD中就能返回。我之前及其没搞明白为何要使用pipe，后来突然想明白了。因为Linux上阻塞的方法就是用select,poll和epoll，其中等待的都是FD，那么采用FD这种方式，能够统一调用方法。</span><br></pre></td></tr></table></figure>
<h1 id="MessageQueue总结"><a href="#MessageQueue总结" class="headerlink" title="MessageQueue总结"></a>MessageQueue总结</h1><p>MessageQueue核心逻辑下移到Native层后，极大地扩展了消息处理的范围，总结后有以下几点：</p>
<ul>
<li><p>MessageQueue继续支持来自Java层的Message消息，也就是早期的Message加Handler的处理方式</p>
</li>
<li><p>MessageQueue在Native层的代表NativeMessageQueue支持来自Native层的Message，是通过Native层的Message和MessageHandler来处理的。</p>
</li>
<li><p>NativeMessageQueue还处理通过addFd添加的Request。这种方式在输入系统里面大量用到了，这也是Android为什么使用pipe来唤醒MessageQueue的原因之一。</p>
</li>
<li><p>从处理逻辑上来，先是Native的Message，然后是Native的Request，最后才是Java的Message。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>深入理解Android系列丛书学习</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Android：Surface</title>
    <url>/2019/09/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%EF%BC%9ASurface/</url>
    <content><![CDATA[<h1 id="总体关系"><a href="#总体关系" class="headerlink" title="总体关系"></a>总体关系</h1><p>Surface是Android中的图像系统，我们将通过以下两点来对它进行学习：</p>
<ol>
<li><p>应用程序和Surface的关系</p>
</li>
<li><p>Surface和SurfaceFlinger之间的关系</p>
</li>
</ol>
<p>两个图表明了这两点：</p>
<p><img src="https://i.loli.net/2019/09/12/QvyimP9dO4Xw1NI.png" alt="surface系统两个关系.PNG"></p>
<p>左图表示了应用程序和Surface之间的关系，可以发现，不论是使用Skia绘制二维图像，还是用OpenGL绘制三维图像，最终Application都要和Surface交互。Surface就像是UI的画布。而App则像是在Surface上作画。</p>
<p>右图表示了Surface和SurfaceFlinger的关系。Surface向SurfaceFlinger提供数据，而SurfaceFlinger则混合数据。</p>
<h2 id="Activity的显示"><a href="#Activity的显示" class="headerlink" title="Activity的显示"></a>Activity的显示</h2><p>一般来说，应用程序的外表是通过Activity来展示的。那么，Activity是如何完成界面绘制工作的呢？根据前面所讲的知识可知，应用程序的显示和Surface有关，那么具体到Activity上，它和Surface又是什么关系？</p>
<h3 id="Activity的创建"><a href="#Activity的创建" class="headerlink" title="Activity的创建"></a>Activity的创建</h3><p>在收到创建Activity请求后，zygote进程在响应请求后会for一个子进程，这个子进程是App对应的进程，它的入口函数是ActivityThread类的main函数。</p>
<blockquote>
<p>main函数中也包括了初始化主线程（UI线程）Looper的逻辑</p>
</blockquote>
<p>ActivityThread类中有一个handleLaunchActivity函数，它就是创建Activity的地方，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final void handleLaunchActivity(ActivityRecord r, Intent customIntent) &#123;</span><br><span class="line">//1.performLaunchActivity返回一个Activity</span><br><span class="line">Activity a = perforLaunchActivity(r, customIntent);</span><br><span class="line">if (a != null) &#123;</span><br><span class="line">r.createdConfig = new Configuaration(mConfigration);</span><br><span class="line">Bundle oldState = r.state;</span><br><span class="line">//2.调用handleResumeActivity</span><br><span class="line">handleResumeActivity(r.token, false, r.isForward);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handleLaunchActivity函数中列出了两个关键点：</p>
<ol>
<li><p>perforLaunchActivity</p>
</li>
<li><p>handleResumeActivity</p>
</li>
</ol>
<h4 id="创建Activity"><a href="#创建Activity" class="headerlink" title="创建Activity"></a>创建Activity</h4><p>第一个关键函数performLaunchActivity返回一个Activity，这个Activity就是App中的那个Activity（仅仅考虑App中只有一个Activity的情况），它的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final Activity performLaunchActivity(ActivityRecord r,Intent cusomIntent) &#123;</span><br><span class="line">Activity Info aInfo = r.activityInfo;</span><br><span class="line">......//完成一些准备工作。</span><br><span class="line">//Activity定义在Activity.java中</span><br><span class="line">Activity activity = null;</span><br><span class="line">try &#123;</span><br><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">/*mInstrumentation为Instrumentation类型，</span><br><span class="line">源文件为Instrumentation.java它在newActivity函数中根据Activity的类名通过Java反射机制来创建对应的Activity，</span><br><span class="line">这个函数比较复杂*/</span><br><span class="line">activity = mInstrumentation.newActivity(cl,component.getClassName(),r.intent);</span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br><span class="line">if(r.state != null) &#123;</span><br><span class="line">r.state.setClassLoader(cl);</span><br><span class="line">&#125;</span><br><span class="line">&#125;catch(Exception e) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">if (activity != null) &#123;</span><br><span class="line">//在Activity中getContext函数返回的就是这个ContextImpl类型的对象</span><br><span class="line">ComtextImpl appContext = new ContextImpl();</span><br><span class="line">......</span><br><span class="line">//下面这个函数会调用Activity的onCreate函数。</span><br><span class="line">mInstrumentation.callActivityOnCreate(actvity, r.state);</span><br><span class="line">......</span><br><span class="line">return activity;</span><br></pre></td></tr></table></figure>
<p>performLaunchActivity的作用有以下两点：</p>
<ol>
<li><p>根据类名以Java反射的方法创建一个Activity</p>
</li>
<li><p>调用Activity的onCreate函数</p>
</li>
</ol>
<p>在onCreate函数中，我们一般会调用setContentView函数，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setContentView(View view) &#123;</span><br><span class="line">getWindow().setContentView(view);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Window getWindow() &#123;</span><br><span class="line">return mWindow;//返回一个类型为Window的mWindow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看一下window和view的两个概念：</p>
<ul>
<li><p>Window：Window是一个抽象基类，用于控制顶层窗口的外观和行为，它的作用是绘制背景和标题栏、默认的按键处理等。它将作为一个顶级的View加入到WindowManager中。</p>
</li>
<li><p>View：View是一个基本的UI单元，占据屏幕的一块矩形区域，可用于绘制，并能处理事件。</p>
</li>
</ul>
<p>那么Window是一个抽象类，它实际的对象是什么类型的？Window Manager究竟是什么？</p>
<p>Windows实际的创建在这段代码里面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//利用PolicyManager来创建Window对象</span><br><span class="line">mWindow = PolicyManager.makeNewWindow(this);</span><br></pre></td></tr></table></figure>
<p>PolicyManager的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PolicyManger</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POLICY_IMPL_CLASS_NAME = <span class="string">"com.android.internal.policy.impl.Policy"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IPolicy sPolicy;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Class policyClass = Class.forName(POLICY_IMPL_CLASS_NAME);</span><br><span class="line">    <span class="comment">//创建Policy对象。</span></span><br><span class="line">    sPolicy = (IPolicy) policyClass.newInstace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e)  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PolicyManger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过Policy对象的makeNewWindow创建一个Window。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Window <span class="title">makeNewWindow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sPolicy.makeNewWindw(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个单例的sPolicy对象，它是Policy类型的，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Policy</span> <span class="keyword">implements</span>  <span class="title">IPolicy</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"PhonePolicy"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] preload_classes = <span class="keyword">new</span> String[] &#123;</span><br><span class="line"><span class="string">"com.android.internal.policy.impl.PhoneLayoutInflater"</span>,</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//加载所有的类</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (String s:preload_classes) &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Class.forName(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PhoneWindow <span class="title">makeNewWindow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"><span class="comment">//makeNewWindow返回的是PhoneWindow对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PhoneWindow(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里就能确定了，mWindow对象实际上是一个PhoneWindow，而WindowManger的实际创建代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wm = WindowManager.getDefault();</span><br><span class="line">mWindowManger = new LocalWindowManager(wm);</span><br></pre></td></tr></table></figure>
<p>LocalWindowManager是在Window中定义的内部类，请看它的构造函数，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalWindowManager</span> <span class="keyword">implements</span> <span class="title">WindowManager</span> </span>&#123;</span><br><span class="line">LocalWindowManager(WindowManager wm) &#123;</span><br><span class="line">    mWindowManager = wm;</span><br><span class="line">    mDefaultDisplay = mContext.getResources().getDefaultDisplay(</span><br><span class="line">        mWindowManager.getDefaultDisplay());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wm的实际类型为WindowManagerImpl，他们的类关系如下：</p>
<p><img src="https://i.loli.net/2019/09/22/92akqKvLtngONM4.png" alt="WindowManager.PNG"></p>
<p>从这个图可以得出以下结论：</p>
<ul>
<li><p>Activity的mWindow成员变量其真实类型是PhoneWindow，而mWindowManager成员变量的真实类型是LocalWindowManager。</p>
</li>
<li><p>LocalWindowManager和WindowManagerImpl都实现了WindowManager接口。这里采用的是Proxy模式，表明LocalWindowManager将把它的工作委托给WindowManagerImpl来完成。</p>
</li>
</ul>
<p>Activity的setContent函数实际上调用的是PhoneWindow的setContent函数，PhoneWindow的setContent函数如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setContentView(View view) &#123;</span><br><span class="line">//调用另一个setContentView</span><br><span class="line">setContentView(view, new ViewLayoutParams(MATCH_PARENT,MATCH_PAENT));</span><br><span class="line">&#125;</span><br><span class="line">public void setContentView(View view,ViewGroup.LayoutParams params) &#123;</span><br><span class="line">//mContentParaent为ViewGroup类型，它的初值为null</span><br><span class="line">if（mContentParent == null &#123;</span><br><span class="line">installDecor();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">mContentParent.removeAllViews();</span><br><span class="line">&#125;</span><br><span class="line">//把view加入到ViewGroup中。</span><br><span class="line">mContentParent.addView(view, params);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>installDecor函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void installDecor() &#123;</span><br><span class="line">if (mDeocr == null) &#123;</span><br><span class="line">//创建mDecor,它为DecorView类型，从FrameLayout派生</span><br><span class="line">mDecor = generateDecor();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">if (mContentParent == null) &#123;</span><br><span class="line">//得到这个mContentParent</span><br><span class="line">mContentParent = generateLayout(mDecor);</span><br><span class="line">//创建标题栏</span><br><span class="line">mTitleView (TextView)findViewById(com.android.internal.R.id.title);</span><br></pre></td></tr></table></figure>
<p>而generateLayout的作用就是获取对应的标题栏，然后将它加入到ViewGroup中，最后将ViewGroup返回。</p>
<p>PhoneWindow、WindowManager、DecorView的关系如下：</p>
<p><img src="https://i.loli.net/2019/09/22/N5E4Rz2diKeL3Hq.png" alt="window、phonewindow关系.PNG"></p>
<p>从上图可以看出，在Activity的onCreate函数中，通过setContentView设置的View，其实只是DecorView的子View。DecorView还处理了标题栏显示等一系列的工作。</p>
<h4 id="handleResumeActivity分析"><a href="#handleResumeActivity分析" class="headerlink" title="handleResumeActivity分析"></a>handleResumeActivity分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) &#123;</span><br><span class="line">boolean willBeVisible = !a.mStartedActivity;</span><br><span class="line">if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">r.window = r.activity.getWindow();</span><br><span class="line">//1.获得一个View对象</span><br><span class="line">View decor = r.window.getDecorView();</span><br><span class="line">decor.setVisibility(View.INVISIBLE);</span><br><span class="line">//2.获得ViewManager对象。</span><br><span class="line">ViewManager wm = a.getWindowManager();</span><br><span class="line">......</span><br><span class="line">//3.把刚才的decor对象加入到ViewManager中。</span><br><span class="line">wm.addView(decor,I);</span><br><span class="line">&#125;</span><br><span class="line">......//其他处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上文中，我们分析了DecorView和ViewManager等对象，那么最后的wm.addView（decor， I）是什么呢？实际上，这里创建了一个ViewRoot对象，并把刚刚的View设置到这个ViewRoot对象中。</p>
<ul>
<li>ViewRoot是什么？</li>
</ul>
<p>ViewRoot实现了ViewParent接口，但是它不处理绘画，因为它没有onDraw函数。</p>
<p>ViewRoot的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRoot</span> <span class="keyword">extends</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,<span class="title">View</span>.<span class="title">Attachinfo</span>.<span class="title">Callbacks</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();<span class="comment">//这里创建了一个Surface对象</span></span><br><span class="line"><span class="keyword">final</span> W mWindow;<span class="comment">//这个是什么？</span></span><br><span class="line">View mView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个定义表达了三点：</p>
<ol>
<li><p>ViewRoot继承了Handler类，看来它能处理消息。ViewRoot重写了handleMessage函数。</p>
</li>
<li><p>ViewRoot有一个成员变量叫mSurface，它是Surface类型</p>
</li>
<li><p>ViewRoot还有W类型的mWindow和一个View类型的mView变量</p>
</li>
</ol>
<p>其中，W是ViewRoot定义的一个静态内部类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class W extends IWindow.Stub</span><br></pre></td></tr></table></figure>
<p>这个类将参与Binder的通信。</p>
<p>其中，Surface是Android真正的画布，它包含了以下几点：</p>
<ol>
<li><p>有一块Raw buffer，至于是内存还是显存，不必管它。</p>
</li>
<li><p>Surface操作这块Raw buffer</p>
</li>
<li><p>Screen compositor（其实就是SurfaceFlinger）管理这块Raw buffer</p>
</li>
</ol>
<p>Surface和SF、ViewRoot的关系图如下：</p>
<p><img src="https://i.loli.net/2019/09/23/WVzh1ujvUMKAYe4.png" alt="画布工作原理.PNG"></p>
<p>这张图表达了以下几点：</p>
<ol>
<li><p>ViewRoot有一个成员变量mSurface，它是Surface类型，它和一块RawBuffer有关联。</p>
</li>
<li><p>ViewRoot是一个ViewParent，它的子View的绘画操作，是在画布Surface上展开的。</p>
</li>
<li><p>Surface和SurfaceFlinger有交互</p>
</li>
</ol>
<p>ViewRoot的构造如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ViewRoot(Context context) &#123;</span><br><span class="line">super();</span><br><span class="line">....</span><br><span class="line">getWindowSession(context.getMainLooper());</span><br><span class="line">......//ViewRoot的mWindow是一个W类型，注意它不是Window类型，而是IWindow类型</span><br><span class="line">mWindow = new W(this, context);</span><br></pre></td></tr></table></figure>
<p>getWindowsession函数，将建立Activity的ViewRoot和WindowManagerService的关系。代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ublic static IWindowSession getWindowSession(Looper mainLooper) &#123;</span><br><span class="line">synchronized(mStaticInit) &#123;</span><br><span class="line">if (!mInitialized) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">InputMethodManager imm = InputMethodManager.getInstance(mainLooper);</span><br><span class="line">//下面这个函数先得到WindowManagerService的Binder代理，然后调用它的OpenSession。</span><br><span class="line">sWindowSession = IWindowManager.Stub.asInterface&#123;</span><br><span class="line">ServiceManager.getService(&quot;window&quot;)).openSession(imm.getClient(),imm.getInputContext());</span><br><span class="line">mInitalized = true;</span><br><span class="line">&#125; catch (RemoteException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return sWindowSession;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowManagerService由System_Server进程启动，SurfaceFligner也在这个进程中，Activity的显示还需要与WMS建立联系。我们先看setView的处理。</p>
<p>ViewRoot的setView函数做了三件事：</p>
<ol>
<li><p>保存传入的view参数为mView，这个mView指向PhoneWindow的DecorView。</p>
</li>
<li><p>调用requestLayout</p>
</li>
<li><p>调用IWindowSession的add函数，这是一个跨进程的Binder通信，第一个参数是mWindow，它是W类型，从IWindow.stub派生。</p>
</li>
</ol>
<p>可以看出，ViewRoot和远端进程SystemServer的WMS有交互，先来总结以下它和WMS的交互流程。</p>
<ol>
<li><p>ViewRoot调用openSession，得到一个IWindowSession对象</p>
</li>
<li><p>调用WindowSession对象的add函数，把一个W类型的mWindow对象作为参数传入</p>
</li>
</ol>
<ul>
<li>ViewRoot和WMS的关系</li>
</ul>
<p>上面总结了ViewRoot和WMS的交互流程，其中一共有两个跨进程的调用，ViewRoot和WMS之间的关系如下：</p>
<p><img src="https://i.loli.net/2019/09/24/n2OGipwtIYmga3A.png" alt="View和WMS.PNG"></p>
<p>这张图中的知识点如下：</p>
<ol>
<li><p>ViewRoot通过IWindowSession和WMS进程进行跨进程通信。IWindowSession定义在IWindowSession.aidl文件中。这个文件在编译由aidl工具处理，最后会生成类似于Native Binder中Bn端和Bp端的代码。每个App进程都会和WMS建立一个IWindowSession对话，这个会话会被App进程用于和WMS通信。</p>
</li>
<li><p>ViewRoot内部有一个W类型的对象，它也是一个基于Binder通信的类，W是IWindow的Bn端，用于响应请求。IWindow定义在另一个aidl文件IWindow.aidl中。IWindow主要用于Android案件事件的分发，当WMS所在的SystemServer进程接收到按键事件后，会把它交给这个IWindow对象。</p>
</li>
</ol>
<h2 id="Activity的UI绘制"><a href="#Activity的UI绘制" class="headerlink" title="Activity的UI绘制"></a>Activity的UI绘制</h2><p>在ViewRoot的setView函数中有一个requestLayout函数，它会向ViewRoot发送一个DO_TRAVERSAL消息，handleMessage函数中，对这个消息的处理是调用performTraversal函数，在performTraversal函数中，它会调用relayoutWindow和draw，这两个函数的作用分别如下：</p>
<ul>
<li>relayWindow</li>
</ul>
<p>relayoutWindow中会调用IWindowSession的relayout函数。</p>
<ul>
<li>draw</li>
</ul>
<p>在mSurface中lock一块Canvas，调用DecorView的draw函数，canvas就是画布，最后unlock画布，屏幕上马上就会显示了。</p>
<h2 id="Activity的总结"><a href="#Activity的总结" class="headerlink" title="Activity的总结"></a>Activity的总结</h2><p>Activity的创建和显示，可以提炼成如下几条：</p>
<ul>
<li><p>Activity的顶层View是DecorView，而我们在onCreate函数中通过setContentView设置的View只不过是这个DecorView中的一部分罢了。DecorView是一个FrameLayout类型的ViewGroup。</p>
</li>
<li><p>Activity和UI有关，它包括一个Window（真实类型是PhoneWindow）和一个WindowManager（真实类型是LocalWindowManager）对象。这两个对象将控制整个Activity的显示。</p>
</li>
<li><p>LocalWindowManager使用了WindowManagerImpl作为最终的处理对象（Proxy模式），这个WindowManagerImpl中有一个ViewRoot对象。</p>
</li>
<li><p>ViewRoot实现了ViewParent接口，它有两个重要的成员变量，一个是mView，它指向Activity顶层UI单元的DecorView，另外一个是mSurface，这个Surface包含了一个Canvas（画布）。除此之外，ViewRoot还通过Binder系统和WindowManagerService进行了跨进程通信。</p>
</li>
<li><p>ViewRoot能处理Handler的消息，Activity的显示就是由ViewRoot在它的performTraversals函数中完成的</p>
</li>
<li><p>整个Activity的绘图流程就是从mSurface中lock一块Canvas，然后交给mView去自由发挥画画的才能，最后unLockCanvasAndPost释放这块Canvas</p>
</li>
</ul>
<p>初识Surface</p>
<p>Surface对象是纵跨Java/JNI层的对象，与它相关的流程如下：</p>
<ol>
<li>在ViewRoot构造时，会创建一个Surface，它使用无参构造函数，代码如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final Surface mSurface = new Surface();</span><br></pre></td></tr></table></figure>
<ol>
<li>ViewRoot通过IWindowSession和WMS交互，而WMS调用中调用的一个attach函数会构造一个SurfaceSession，代码如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void windowAddedLocked() &#123;</span><br><span class="line">if (mSurfaceSession == null) &#123;</span><br><span class="line">mSurfaceSession = new SurfaceSession();</span><br><span class="line">mNumWindow++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>ViewRoot在performTransval的处理过程中会调用IWindowSession的relayout函数。</p>
</li>
<li><p>ViewRoot调用Surfaced lockCanvas，得到一块画布</p>
</li>
<li><p>ViewRoot调用Surface的unLockCanvasAndPost释放这块画布。</p>
</li>
</ol>
<p>下面来看一下relayout函数的本质，relayout函数是一个跨进程的调用，由WMS完成实际处理。</p>
<p>Surface的创建流程如下：</p>
<p><img src="https://i.loli.net/2019/09/27/VGY6esrb3QHuE8t.png" alt="Surface创建流程.png"></p>
<blockquote>
<p>来自CSDN邓老师博客</p>
</blockquote>
<p>由此图可以看出：</p>
<ul>
<li><p>WMS中的Surface才是真正的Surface，它的构造使用了带SurfaceSession参数的构造函数</p>
</li>
<li><p>ViewRoot中的Surface是一个“伪”Surface，它的构造使用了无参构造函数。</p>
</li>
<li><p>copyFrom就是进行转移，它将真正的Surface信息拷贝到“伪”Surface即outSurface里</p>
</li>
</ul>
<p>而这个过程则需要使用aidl帮助完成，这个过程发生在ViewRoot调用IWindowSession的relayout函数中，它在IWindowSession.aidl的定义如下：</p>
<p><img src="https://i.loli.net/2019/09/27/XGYKPN836lrQpTD.png" alt="乾坤大挪移真相.png"></p>
<h3 id="创建Surface的JNI层分析"><a href="#创建Surface的JNI层分析" class="headerlink" title="创建Surface的JNI层分析"></a>创建Surface的JNI层分析</h3><p>在JNI层，第一个被调用的是Surface的无参构造函数，其代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Surface() &#123;</span><br><span class="line">//CompatibleCanvas从Canvas类派生</span><br><span class="line">mCanvas = new CompatibleCanvas();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Canvas是画图所需要的四个类其中之一，这四个类分别是：</p>
<ul>
<li><p>Bitmap：用于存储像素，也就是画布。可把它当作一块数据存储区域。</p>
</li>
<li><p>Canvas：用于记载画图的动作，比如画一个圆，画一个矩形等。Canvas类提供了这些基本的绘图函数。</p>
</li>
<li><p>Drawing primitive：绘图基本元素，例如矩形、圆、弧线、文本、图片等。</p>
</li>
<li><p>Paint：它用来描述绘画时使用的颜色、风格（如实线、虚线等）</p>
</li>
</ul>
<p>在一般情况下，Canvas会封装一块Bitmap，而作图就是基于这块Bitmap的。前面所说的画布，其实指的就是Canvas中的这块Bitmap。</p>
<p>那么，真正的Surface怎么对它进行替换呢？可以分为以下几个流程：</p>
<ol>
<li><p>创建一个SurfaceComposerClient</p>
</li>
<li><p>调用SurfaceComposerClient的createSurface得到一个SurfaceControl对象</p>
</li>
<li><p>调用SurfaceControl的writeToParcel把一些信息写到Parcel包中</p>
</li>
<li><p>根据Parcel包的信息构造一个Surface对象。把这个Surface对象保存到Java层的mSurface对象中，这样，ViewRoot最终得到了一个Native的Surface对象。</p>
</li>
</ol>
<h3 id="Surface和画图"><a href="#Surface和画图" class="headerlink" title="Surface和画图"></a>Surface和画图</h3><p>最后两个和Surface相关的函数调用是lockCanvas和unlockCanvasAndPost。</p>
<ul>
<li><p>lockCanvas： 先获得一块存储区域，然后将它和Canvas绑定到一起，这样，UI绘画的结果就记录在这块存储里了</p>
</li>
<li><p>unlockCanvasAndPost：调用Surface对象的unlockAndPost函数</p>
</li>
</ul>
<h3 id="Surface流程"><a href="#Surface流程" class="headerlink" title="Surface流程"></a>Surface流程</h3><p>Surface精简流程可以由如下这个图概括</p>
<p><img src="https://i.loli.net/2019/09/30/BvamZsL78q5KgYn.png" alt="Surface精简流程.PNG"></p>
<h2 id="ViewRoot总结"><a href="#ViewRoot总结" class="headerlink" title="ViewRoot总结"></a>ViewRoot总结</h2><p>ViewRoot是Surface系统甚至UI系统中一个非常重要的类，VieRoot的总结如下：</p>
<ul>
<li>ViewRoot和View类的关系是上面？</li>
</ul>
<p>ViewRoot是View视图体系的根，每一个Window（注意是Window，比如PhoneWindow）有一个ViewRoot，它的作用是处理layout和View视图体系的绘制工作。视图体系包括Views和ViewGroupa，也就是SDK中能看到的View类都属于视图体系。根据前面的根系可知，这些View是需要通过draw画出来的。而ViewRoot就是用来draw他们的，ViewRoot本身没有draw/onDraw函数。</p>
<ul>
<li>ViewRoot和它所控制的View及其子View使用同一个Canvas吗？</li>
</ul>
<p>ViewRoot提供Canvas给它所控制的View，所以他们使用同一个Canvas。但Canvas使用的内存却不是固定的，而是通过Surface的lockCanvas得到的。</p>
<ul>
<li>View、Surface和Canvas之间的关系？</li>
</ul>
<p>一个Window将和一个Surface绑定在一起，绘制前ViewRoot会从Surface中lock除一个Canvas。</p>
<ul>
<li>Canvas有一个bitmap，那么绘制UI时，数据是画在Canvas的这个bitmap中吗？</li>
</ul>
<p>是的，bitmap实际上包括了一块内存，绘制的数据最终都在这块内存上。</p>
<ul>
<li>同一个ViewRoot下，不同类型的View使用同一个Surface吗？</li>
</ul>
<p>是的，但是SurfaceView要除外。因为SurfaceView的绘制一般在独立的线程上，并且由应用层主动调用lockCanvas，draw和unlockCanvasAndPost来完成绘制流程。应用层相当于抛开了ViewRoot的控制直接和屏幕打交道，这在camera、video方面用的最多。</p>
<h1 id="Surface总结"><a href="#Surface总结" class="headerlink" title="Surface总结"></a>Surface总结</h1><p>主要是这两点：</p>
<ul>
<li><p>应用程序和Surface的关系</p>
</li>
<li><p>Surface和SurfaceFlinger的关系</p>
</li>
</ul>
<p>应用程序与Surface的关系从应用程序的Activity开始，一路追踪到ViewRoot、WindowManagerService。</p>
<p>SurfaceFlinger则主要负责视图的显示，App 端 copyFrom() 出来 NativeSurface 时会创建一个 SharedBufferClient 与 SharedClient 这块共享内存关联。当客户端 addView() 或者需要更新 View 时，会通过 SharedBufferClient 写入数据到 ShareClient 中，SurfaceFlinger 中的 SharedBufferServer 接收到通知会将 FrameBuffer 中的数据传输到屏幕上。HWComposer 是基于硬件来产生 VSync 信号的，来通知 SurfaceFlinger 重绘控制显示的帧率。</p>
]]></content>
      <categories>
        <category>深入理解Android系列丛书学习</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Android：Binder</title>
    <url>/2019/08/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%EF%BC%9ABinder/</url>
    <content><![CDATA[<p>Binder是Android提供给我们的一种跨进程通信方案，Android虽然说是基于Linux内核的，可以使用Linux的管道进行跨进程通信，也可以使用网络的方法（使用Socket）进行跨进程通信，但是这些方式都没有Binder方便和灵活。</p>
<p>从宏观的角度来看，Android可以看作是一个基于Binder通信的C/S架构。Binder在里面起到了一个网络的作用，它将Android系统的各个部分连接在了一起。</p>
<h1 id="Native-Binder-总体架构"><a href="#Native-Binder-总体架构" class="headerlink" title="Native Binder 总体架构"></a>Native Binder 总体架构</h1><p>在基于Binder通信的C/S架构体系中，除了C/S架构所包括的Client端和Server端外，Android还有一个全局的ServiceManager端，它的作用是管理系统中的各种服务（Service）。这三者之间的关系如下图所示：</p>
<p><img src="https://i.loli.net/2019/08/28/e95E8zTGXZrgm4i.png" alt="Client_SM_S.PNG"></p>
<blockquote>
<p>注意，一个Server进程可以注册多个Service</p>
</blockquote>
<p>上图中三者的先后关系是这样的：</p>
<ol>
<li>Server进程要先注册一些Service到ServiceManager中，所以Server是ServiceManager的客户端，两者之间的C/S关系为，Server对应客户端（Client），ServiceManager对应服务端（Server）</li>
<li>如果某个Client进程要使用某个Service，必须先到ServiceManager中获取该Service的相关信息，所以Client是ServiceManager的客户端，两者之间的C/S关系为，Client对应客户端（Client），ServiceManager对应服务端（Server）</li>
<li>Client根据得到的Service信息与Service所在的Server建立通信，然后就可以直接与Service交互了，所以Client也是Service的客户端，两者之间的C/S关系为，Client对应客户端（Client），Server对应服务端（Server）</li>
</ol>
<p>这三者之间交互全部都是基于Binder通信的。</p>
<blockquote>
<p>Binder只是为这种C/S架构提供了一种通信方式，我们也完全可以次啊用其他IPC方式进行通信，实际上，系统中有很多其他的程序就是采用Socket或者Pipe（管道）方法进行进程间通信。ServiceManager并没有使用BpXXX和BnXXX</p>
</blockquote>
<h2 id="MediaServer"><a href="#MediaServer" class="headerlink" title="MediaServer"></a>MediaServer</h2><blockquote>
<p>MediaServer以下均称为MS。</p>
</blockquote>
<p>MS是一个可执行程序，虽然Android的SDK提供Java层的API，但Android系统本身还是一个完整的基于Linux内核的操作系统，所以并非所有的程序都是用Java编写的，MS就是一个使用C++编写的可执行程序。</p>
<p>MS是系统诸多重要Service的栖息地，它们包括了：</p>
<ul>
<li>AudioFlinger：音频系统中的核心服务。</li>
<li>AudioPolicyService：音频系统中关于音频策略的重要服务。</li>
<li>MediaPlayerService：多媒体系统中的重要服务</li>
<li>CameraService：有关摄像/拍照的重要服务</li>
</ul>
<p>可以看到，MS除了不涉及Surface系统外，其他重要的服务基本上都设涉及了。</p>
<p>MS是一个可执行程序，入口函数为main，写在Main_MediaServer.cpp当中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1.获得一个ProcessState实例。</span></span><br><span class="line">sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line"><span class="comment">//2.MS作为ServiceManager的客户端，需要向ServiceManager注册服务。</span></span><br><span class="line"><span class="comment">//调用defaultServiceManager，得到一个IServiceManager。</span></span><br><span class="line">sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line"><span class="comment">//初始化音频系统的AudioFlinger服务。</span></span><br><span class="line">AudioFlinger::instantiate();</span><br><span class="line"><span class="comment">//3.多媒体系统的MediaPlayer服务，我们将以它作为主切入点。</span></span><br><span class="line"> MediaPlayerService::Instantiate();</span><br><span class="line"><span class="comment">//CameraService服务。</span></span><br><span class="line"> CameraService::instantiate();</span><br><span class="line"><span class="comment">//音频系统的AudioPolicy服务。</span></span><br><span class="line"> AudioPolicyService::instantiate();</span><br><span class="line"><span class="comment">//4.根据名称来推断，难道是要创建一个线程池吗？</span></span><br><span class="line"> ProcessState::self()-&gt;startThreadPool();</span><br><span class="line"><span class="comment">//5.下面的操作是要将自己加入到刚才的线程池中吗？</span></span><br><span class="line"> IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，确定了个关键点，我们通过对这五个关键点的分析，来认识和理解Binder。</p>
<h3 id="获得一个ProcessState实例：sp-proc-ProcessState-self"><a href="#获得一个ProcessState实例：sp-proc-ProcessState-self" class="headerlink" title="获得一个ProcessState实例：sp proc(ProcessState::self());"></a>获得一个ProcessState实例：sp<processstate> proc(ProcessState::self());</processstate></h3><ol>
<li>单例的ProcessState</li>
</ol>
<p>ProcessState的代码在ProcessState.cpp中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; PeocessState::self() &#123;</span><br><span class="line"><span class="comment">//gProcess是在Static.cpp中定义的一个全局变量。</span></span><br><span class="line"><span class="comment">//程序刚开始，gProcess一定为空</span></span><br><span class="line"><span class="keyword">if</span> (gPrecess!=<span class="literal">NULL</span>) Return gProcess;</span><br><span class="line">AutoMutex_I(gPeocessMutex);</span><br><span class="line"><span class="comment">//创建一个ProcessState对象，并赋给gProcess。</span></span><br><span class="line"><span class="keyword">if</span> (gProcess == <span class="literal">NULL</span>) gProcess = <span class="keyword">new</span> ProcessState;</span><br><span class="line"><span class="keyword">return</span> gProcess;</span><br></pre></td></tr></table></figure>
<p>self函数采用了单例模式，根据这个以及ProcessState的名字很明确地告诉我们了一个信息：每个进程只有一个ProcessState对象，这一点，从它的命名中也可以看出端倪。</p>
<ol>
<li>ProcessState的构造</li>
</ol>
<p>再来看Process的构造很熟，这个函数非常重要，它悄悄地打开了Binder设备。代码如下所示，在ProcessState.cpp中可以找到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ProcessState::ProcessState()</span><br><span class="line"><span class="comment">//Android中有很多代码都是这么写的，稍不留神这里就调用了一个很重要的函数。</span></span><br><span class="line">:mDriver(open_driver())</span><br><span class="line">.mVMState(MAP_FAILED)<span class="comment">//映射内存的起始地址</span></span><br><span class="line">.mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">.mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">.mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">.mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">.mThreadPoolSeq(<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="comment">/*BINDER_VM_SIZE定义为（1*1024*1024）-（4096*2）=1M - 8k，mmap真正的实现和驱动有关系，而Binder驱动会分配一块内存来接收数据。*/</span></span><br><span class="line">mVMStart = mmap(<span class="number">0</span>,BINDER_VM_SIZE,PROT_READ.MAP_PRIVATE|MAP_NORESERVE,mDriverDF,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>open_driver：打开binder设备</li>
</ol>
<p>open_driver的作用就是打开/dev/binder这个设备，它是Android在内核中为完成进程间通信而专门设置的一个虚拟设备，具体实现如下所示，在ProcessState.cpp中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>,O_PDWR);</span><br><span class="line"><span class="comment">//打开/dev/binder设备。</span></span><br><span class="line"><span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">size_t</span> maxThread = <span class="number">15</span>;</span><br><span class="line"><span class="comment">//通过ioctl方式告诉binder驱动，这个fd支持的最大线程数是15个。</span></span><br><span class="line">result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Process::self函数的作用总结如下：</p>
<ul>
<li>打开dev/Binder设备，相当于与内核的Binder驱动有了交互的通道</li>
<li>对返回的fd使用mmap，这样Binder驱动就会分配一块内存来接收数据。</li>
<li>由于ProcessState具有唯一性，因此一个进程只打开设备一次</li>
</ul>
<h3 id="sp-sm-defaultServiceManager-调用defaultServiceManager，得到一个IServiceManager。"><a href="#sp-sm-defaultServiceManager-调用defaultServiceManager，得到一个IServiceManager。" class="headerlink" title="sp sm = defaultServiceManager();:调用defaultServiceManager，得到一个IServiceManager。"></a>sp<iservicemanager> sm = defaultServiceManager();:调用defaultServiceManager，得到一个IServiceManager。</iservicemanager></h3><p>defaultServiceManager函数的实现在IServiceManager.cpp中完成。它会返回一个IServiceManager对象，通过这个对象，我们可以神奇地与另一个进程ServiceManager进行交互。</p>
<ol>
<li>defaultServiceManager调用的函数</li>
</ol>
<p>defaultServiceManager的代码藏在IServiceManager中，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager() &#123;</span><br><span class="line"><span class="comment">//看样子又是一个单例，英文名字叫Singleton，Android是一个优秀的源码库，大量使用了设计模式</span></span><br><span class="line"><span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#123;</span><br><span class="line">AutoMutex_I(gDefaultServiceManagerLock);</span><br><span class="line"><span class="keyword">if</span> (gDefaultServiceManger == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//真正的gDefaultServiceManger是在这里创建的。</span></span><br><span class="line">gDefaultServiceManager = interface_cast&lt;IServiceManager&gt; &#123;</span><br><span class="line">Process::self() -&gt; getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gDefaultServiceManager;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，gDefaultServiceManager是调用了ProcessState的getContextObject函数来赋值的，getContextObject函数在ProcessState.cpp文件中，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt; &amp;caller) &#123;</span><br><span class="line"><span class="comment">/* caller的只为0，因为它传入的参数为NULL。</span></span><br><span class="line"><span class="comment">support函数根据openDriver函数是否可成功打开设备来判断它是否支持process。</span></span><br><span class="line"><span class="comment">真实设备肯定支持process。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (supportsProcesses()) &#123;</span><br><span class="line"><span class="comment">//真实设备上肯定是支持进程的，所以会调用下面这个函数。</span></span><br><span class="line"><span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getContextObject(String16(<span class="string">"default"</span>), caller);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getStrongProxyForHandle的函数实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">sp&lt;IBinder&gt; result;</span><br><span class="line">AutoMutex_I(mLock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">根据索引查找对应的资源。如果lookupHandleLocked发现没有对应的资源项，则会创建一个新的项并返沪。这个新项的内容需要填充。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">handle_entry *e = lookupHandleLocked(handle);</span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">IBinder *b = e -&gt; binder;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e -&gt; refs -&gt; attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line"><span class="comment">//对于新创建的资源项，它的binder为空，所以走这个分支。注意，handle的值为0</span></span><br><span class="line">b = <span class="keyword">new</span> BpBinder(handle); <span class="comment">//创建一个bpBinder</span></span><br><span class="line">e -&gt; binder = b;<span class="comment">//填充entry的内容</span></span><br><span class="line"><span class="keyword">if</span> (b) e -&gt; refs = b -&gt; getWeakRefs();</span><br><span class="line">result = b; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result.force_set(b);</span><br><span class="line">e -&gt; refs -&gt; decWeak(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result; <span class="comment">//返回BpBinder(handle),注意，handle的值为0</span></span><br></pre></td></tr></table></figure>
<p>上述代码中出现的BpBinder和它的孪生兄弟BBinder都是Android中与Binder通信相关的代表，他们都是从IBinder类中派生而来。</p>
<p>关于BpBinder和BBinder的关系可以这么理解：</p>
<ul>
<li>BpBinder是客户端用来与Server交互的代理类，p即Proxy的意思</li>
<li>BBinder则是与proxy相对的一端，它是proxy交互的目的端，可以这么理解，BpBinder为客户端，那么BBinder则是对应的服务端，BpBinder和BBinder是一一对应的，某个BpBinder只能与对应的BBinder交互。</li>
</ul>
<p>BpBinder是由Binder系统通过handler来标识对应的BBinder。</p>
<blockquote>
<p>注意，我们给BpBinder构造函数传的参数handle的值是0，这个0在整个Binder系统中有重要含义–因为0代表的就是ServiceManager所对应的BBinder。</p>
</blockquote>
<p>下面是BpBinder的代码，卸载BpBinder.cpp中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BpBinder::BpBinder(<span class="keyword">int32_t</span> handle)</span><br><span class="line">:mHandle(handle) <span class="comment">//handle是0</span></span><br><span class="line">,mAlive(<span class="number">1</span>)</span><br><span class="line">,mObitsSent(<span class="number">0</span>)</span><br><span class="line">,mObituaries(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">extendObjectLifetime(OBJECT_LIFTTIME_WEAK);</span><br><span class="line"><span class="comment">//另一个重要对象是IPCThreadState，我们稍后会详细讲解。</span></span><br><span class="line">IPCThreadState::self() -&gt; incWeakHandle(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，BpBinder和BBinder两个类没有任何地方操作ProcessState打开的那个/dev/binder设备</p>
<p>所以这段代码中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gDefaultServiceManager = interface_cast&lt;IServiceManager&gt; &#123;</span><br><span class="line">Process::self() -&gt; getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <em>interface_cast</em>函数就显得十分重要</p>
<p>interface_cast的具体实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">templaate&lt;<span class="keyword">typename</span> INTERFACE&gt;&gt;</span><br><span class="line">intline sp&lt;INTERFACE&gt; interface_cast(<span class="keyword">const</span> sp&lt;IBinder&gt; &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> INTERFACE::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里仅仅是一个模板函数，真实的实现其实是下面这样的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> sp&lt;IServiceManager&gt; interface_cast(<span class="keyword">const</span> sp&lt;IBinder&gt; &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> IServiceManager::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这个函数真正的实现还是在IServiceManager中的的，IServiceManager定义了ServiceManager中所提供的服务。</p>
<p>那么interface_cast是如何把BpBinder指针转换成一个IServiceManager指针的呢？答案就是下面这段代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">intr = <span class="keyword">new</span> BpServiceManager(obj);</span><br></pre></td></tr></table></figure>
<p>由代码当中可以看出，interface_cast不是指针的转换，而是利用BpBinder对象作为参数新建了一个BpServiceManager对象。到这里我们已经看到了IServiceManager和BpServiceManager的身影，所有的类关系图谱如下：</p>
<p><img src="https://i.loli.net/2019/09/01/Utr2SFfJudDsKZX.png" alt="IServiceManager类图.PNG"></p>
<p>从这张类图中我们可以看到BnServiceManager是同时继承了IServiceManager和BBinder，所以它可以直接地与Binder交互，但是BpServiceManager则没有直接继承关于Binder的类，它是通过BpRefBase与Binder进行交互的，因为BpRefBase中mRemote的值就是BpBinder。</p>
<p>再回到最开始的这段代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br></pre></td></tr></table></figure>
<p>通过defaultServiceManger函数，我们可以得到两个关键的对象：</p>
<ul>
<li>一个BpBinder对象，它的handle值是0</li>
<li>有一个BpServiceManager对象，它的mRemote值是BpBinder</li>
</ul>
<p>defaultServiceManager()实际返回的对象是BpServiceManager</p>
<h3 id="初始化多媒体系统的MediaPlayer服务：MediaPlayerService-Instantiate"><a href="#初始化多媒体系统的MediaPlayer服务：MediaPlayerService-Instantiate" class="headerlink" title="初始化多媒体系统的MediaPlayer服务：MediaPlayerService::Instantiate();"></a>初始化多媒体系统的MediaPlayer服务：MediaPlayerService::Instantiate();</h3><p>MediaPlayerService的代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> MediaPlayerService::instance() &#123;</span><br><span class="line">defaultServiceManager()-&gt; addService(</span><br><span class="line">String16(<span class="string">"media.player"</span>),<span class="keyword">new</span> MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为defaultServiceManager实际返回的对象是BpServiceManager，所以实际的代码是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vitual status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16 &amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt; &amp; service)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Parcel：就把她当作是一个数据包</span></span><br><span class="line">Parcel data，reply；</span><br><span class="line">data.writeInterfaceToken(IServiceManager::getInterfaceDescripter());</span><br><span class="line">data.writeString16(name);</span><br><span class="line">data.writeStrongBinder(service);</span><br><span class="line"><span class="comment">//remote返回的是mRemote,也就是BpBinder对象</span></span><br><span class="line">status_err err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION,data, &amp;reply);</span><br><span class="line"><span class="keyword">return</span> err = NO_ERROR?reply.readInt32():err;</span><br></pre></td></tr></table></figure>
<p>很明显，addService函数就做了一件事情：<em>就是把请求数据打包成data后，传给了BpBinder的transact函数，把通信的工作交给了BpBinder去完成。</em></p>
<p>BpBinder 的transact函数实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::transact(<span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel &amp; data, Parcel *reply, <span class="keyword">uint32_t</span> flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line"><span class="comment">//BpBinder果然是道具，它把transact工作交给了IPCThreadState。</span></span><br><span class="line"><span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">mHandle, code, data, reply, flag);<span class="comment">//mHandle也是参数</span></span><br><span class="line"><span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看出来，BpBinder把transact工作马上交给了IPCThreadState。现在我们来分析以下IPCThreadState与transact（）</p>
<ol>
<li>IPCThreadState</li>
</ol>
<p>IPCThreadState的实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">IPCThreadState *IPCThreadState::self() </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (gHavaTLS) &#123;<span class="comment">//第一次进来为false</span></span><br><span class="line">restart:</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">pthread_key_t</span> k = gTLS;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TLS是Thread Local Strage（线程本地存储空间）的简称。相当于Java的ThreadLocal</span></span><br><span class="line"><span class="comment">通过pThread——getspecific/pthread_setspececific函数可以获取/设置这些空间中的内容。从线程本地存储空间中获取保存在其中的IPCThreadState对象。</span></span><br><span class="line"><span class="comment">有调用pthread_getspecific的地方，肯定也有pthread_setspecific的地方</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">IPCThread State*st = （IPCThreadState*）pthread_getspectfic(k);</span><br><span class="line"><span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line"><span class="comment">//new一个对象，构造函数中会调用pthread_setspecific.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(gShoutdown) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line"><span class="keyword">if</span> (!gHaveTLS) &#123;</span><br><span class="line"><span class="keyword">if</span> (pThread_key_create(&amp;gTLS, threadDestructor)!=<span class="number">0</span>) &#123;</span><br><span class="line">pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">gHavaTLS = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">gHavaTLS = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line"><span class="keyword">goto</span> restart;</span><br></pre></td></tr></table></figure>
<p>它的构造函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">IPCThreadState::IPCthreadState()</span><br><span class="line">:mProcess(ProcessState::self()),mMyThreadId(androidGetTid())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在构造函数中，把自己设置到线程本地存储当中去。</span></span><br><span class="line">pthread_setspectfic(gTLS,<span class="keyword">this</span>);</span><br><span class="line">clearCaller();</span><br><span class="line"><span class="comment">//mIn和mOut是两个Parcel。把它看成是发送和接收命令的两个缓冲区即可。</span></span><br><span class="line">mIn.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">mOut.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个线程都有一个IPCThreadState，每个IPCThreadState中都有一个mIn，一个mOut，其中，mIn是用来接收来自Binder设备的数据的，而mOut则是用来存储发往Binder设备的数据的。</p>
<ol>
<li>transact（）</li>
</ol>
<p>这个函数实际完成了与Binder通信的工作，如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意，handle的值为0，代表通信的目的端</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,<span class="keyword">uint32_t</span> code,<span class="keyword">const</span> Parcel &amp; data, Parcel *reply,<span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">flag |= TF_ACCEPT_FPS;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意这里的第一个参数BC_TRANSACTION,它是应用程序向binder设备发送消息的消息码，而binder设备向应用程序回复消息的消息码以BR_开头。消息码的定义在binder_module.h中，请求消息码和回应消息码的对应关系，需要查看Binder驱动的实现才能将其理清楚，我们这里暂时用不上。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">err = writeTransactionData(BC_TRNASACTION,flags,handle,code, data, <span class="literal">NULL</span>);</span><br><span class="line">......</span><br><span class="line">err = waitForResponse(reply);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> err;</span><br></pre></td></tr></table></figure>
<p>这个流程很简单：先发数据，然后等结果。</p>
<p>writeTransaction函数的作用是把请求命令写在mOut中了，handle的值为0，用来标识目的端，其中0是ServiceManager的标志。</p>
<p>waitForResponse函数的作用是发送请求和接收回复。收到回复后，就会调用talkWithDriver函数，在talkWithDriver函数中就会调用ioctl方式与Binder交互。</p>
<blockquote>
<p> ioctl是设备驱动程序中对设备的I/O通道进行管理的函数。</p>
</blockquote>
<h3 id="ProcessState-self-gt-startThreadPool-创建线程池"><a href="#ProcessState-self-gt-startThreadPool-创建线程池" class="headerlink" title="ProcessState::self()-&gt;startThreadPool():创建线程池"></a>ProcessState::self()-&gt;startThreadPool():创建线程池</h3><p>startThread的实现如下面代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> PeocessState::startThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">AutoMutex_I(mLock);</span><br><span class="line"><span class="comment">//如果已经startThreadPool的话，这个函数就没有什么实质作用了。</span></span><br><span class="line"><span class="keyword">if</span> (!mThreadPoolStarted)&#123;</span><br><span class="line">mThreadPoolStarted = <span class="literal">true</span>;</span><br><span class="line">spawnPooledThread(<span class="literal">true</span>);<span class="comment">//注意，传进去的参数是true。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的spawnPooledThread函数的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> PeocessState::spawnPooledThread(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注意，isMain参数是true</span></span><br><span class="line"><span class="keyword">if</span>(mThreadPoolStarted) &#123;</span><br><span class="line"><span class="keyword">int32_t</span> s = android_atomic_add(<span class="number">1</span>,&amp;mThreadPoolSeq);</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">spritf(buf, <span class="string">"Binder Thread#%d"</span>,s);</span><br><span class="line">sp&lt;Thread&gt; t = <span class="keyword">new</span> PoolThread(isMain);</span><br><span class="line">t -&gt; run(buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里又新建了一个线程并运行，而这个新创建的线程（PoolThread）也调用了joinThreadPool这个函数。</p>
<h3 id="IPCThreadState-self-gt-joinThreadPool"><a href="#IPCThreadState-self-gt-joinThreadPool" class="headerlink" title="IPCThreadState::self()-&gt;joinThreadPool();"></a>IPCThreadState::self()-&gt;joinThreadPool();</h3><p>具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> IPCThreadState::joinThreadPool(<span class="keyword">bool</span> isMain) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注意，如果isMain为true，我们则需要循环处理。把请求信息写到mOut中，待会儿则一起发出去</span></span><br><span class="line">mOut.writeInt32(isMain?BC_ENTER_LOOPER:BC_REGISTER_LOOPER);</span><br><span class="line">androidSetSchedulingGroup(mMyThreadId,ANDROID_TGROUP_DEFAULT);</span><br><span class="line"><span class="keyword">status_t</span> result:</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="keyword">int32_t</span> cmd;</span><br><span class="line"><span class="keyword">if</span>(mIn.dataPosition()&gt;=mIn.dataSize())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> numPending = mPendingWeakDerefs.size();</span><br><span class="line"><span class="keyword">if</span> (numPending &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numPending;i ++) &#123;</span><br><span class="line">RefBase::weakref_type*refs = mPendingWeakDeref[i];</span><br><span class="line">refs-&gt;decWeak(mProcess.get());</span><br><span class="line">&#125;</span><br><span class="line">mPendingStrongDerefs.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送命令，读取请求</span></span><br><span class="line">result = talkWithDriver();</span><br><span class="line"><span class="keyword">if</span> (result &gt;= NO_ERROR)&#123;</span><br><span class="line"><span class="keyword">size_t</span> IN = mIn.dataAvail();</span><br><span class="line"><span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) <span class="keyword">continue</span>;</span><br><span class="line">cmd = mIn.readInt32();</span><br><span class="line">result = executeCommand(cmd);<span class="comment">//处理消息</span></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125; <span class="keyword">while</span>(result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line">mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">talkWithDriver(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来，这里也使用了talkWithDriver,两个调用了joinThreadPool的线程看看从Binder设备那里能不能找点可做的事情。</p>
<h3 id="MediaPlayerService总结"><a href="#MediaPlayerService总结" class="headerlink" title="MediaPlayerService总结"></a>MediaPlayerService总结</h3><p>目前看来MediaPlayerService调用了两个线程为Service服务，分别是：</p>
<ul>
<li><p>startThreadPool中新启动的线程（即第四步：ProcessState::self()-&gt;startThreadPool()）通过joinThreadPool读取binder设备，查看是否有请求。</p>
</li>
<li><p>主线程也调用joinThreadPool读取binder设备，查看是否有请求。看来，binder设备是支持多线程操作的。</p>
</li>
</ul>
<p>MediaPlayerService总共注册了四个服务。</p>
<p>Binder体系中通信层和业务层的交互关系可以通过这个图来表示：</p>
<p><img src="https://i.loli.net/2019/09/03/FRxbt4ywqJjSE3r.png" alt="Binder业务层通信层关系.PNG"></p>
<h2 id="服务总管ServiceManager"><a href="#服务总管ServiceManager" class="headerlink" title="服务总管ServiceManager"></a>服务总管ServiceManager</h2><h3 id="ServiceManager的原理"><a href="#ServiceManager的原理" class="headerlink" title="ServiceManager的原理"></a>ServiceManager的原理</h3><p>defaultServiceManager返回的是一个BpServiceManager，通过它可以把命令请求发送给handle值为0的目的端。而这些请求都被ServiceManger处理了。</p>
<h4 id="ServiceManger的入口函数"><a href="#ServiceManger的入口函数" class="headerlink" title="ServiceManger的入口函数"></a>ServiceManger的入口函数</h4><p>ServiceManager的入口函数如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//BINDER_SERVICE_MANAGER的值为NULL,是一个magic number</span></span><br><span class="line"><span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line"><span class="comment">//1.应该是打开binder设备吧？</span></span><br><span class="line">bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line"><span class="comment">//2.成为manager，是不是把自己的handle置为0？</span></span><br><span class="line">binder_become_context_manager(bs);</span><br><span class="line">svcmgr_handle = scvmgr;</span><br><span class="line"><span class="comment">//3.处理客户端发过来的请求</span></span><br><span class="line">binder_loop(bs,svcmgr_handler);</span><br></pre></td></tr></table></figure>
<ol>
<li>打开binder设备:binder_open</li>
</ol>
<p>binder_open函数用于打开binder设备，它的实现如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里的binder_open应该与我们之前在ProcessState中看到的一样：</span></span><br><span class="line"><span class="comment">1）打开binder设备</span></span><br><span class="line"><span class="comment">2）内存映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">struct binder_state*<span class="title">binder_open</span><span class="params">(<span class="keyword">unsigned</span> mapsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">bs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">.......</span><br><span class="line">bs-&gt;fd=open(<span class="string">"/dev/binder"</span>,O_RDWR);</span><br><span class="line">......</span><br><span class="line">bs-&gt;mapsize = mapsize;</span><br><span class="line">bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize,PROT_READ,MAP+PRIVATE,bs-&gt;fd,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>成为manager:binder_become_context_manager(bs)</li>
</ol>
<p>manager的实现如下面代码所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_become_context_manager</span><span class="params">(struct binder_state *bs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ioctl(bs-&gt;fd,BINDER_SET_CONTEXT_MGR,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>处理客户端发过来的请求:binder_loop</li>
</ol>
<p>binder_loop函数代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意binder_handler参数，它是一个函数指针，binder_loop读取请求后将解析这些请求，最后调用binder_handler完成最终的处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs,binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">readbuf[<span class="number">0</span>]=BC_ENTER_LOOPER;</span><br><span class="line">binder_write(bs,readbuf,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"><span class="keyword">for</span>(;;)&#123; <span class="comment">//死循环</span></span><br><span class="line">bwr.read_size=<span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">bwr.read_consumed=<span class="number">0</span>;</span><br><span class="line">bwr=read_buffer = (<span class="keyword">unsigned</span>)readbuf;</span><br><span class="line">res = ioctl(bs-&gt;fd,BINDER_WRITE_READ,&amp;bwr);</span><br><span class="line"><span class="comment">//接收到请求，交给binder_parse,最终会调用func来处理这些请求。</span></span><br><span class="line">res=binder_parse(bs,<span class="number">0</span>,readbuf,bwr.read_consumed,func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>binder_handler指针func实际上就是svcmgr_handler,svcmgr_handler会使用一个switch/case语句调用对应的IServiceManagerManager中定义的各个业务函数，其中有一个业务函数为addService，这个函数主要的作用是判断注册服务的进程是否有权限，如果进程的用户组是root用户或system用户才允许注册，如果达不到root或system权限的进程，则需要在allowed结构数据中添加相应的项目。它的定义大概像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> uid;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*name;</span><br><span class="line">&#125;allowed[]=&#123; <span class="comment">//如果达不到root或system权限的进程，则需要在allowed结构数据中添加相应的项目</span></span><br><span class="line">#ifdef LVMX</span><br><span class="line">&#123;AID_MEDIA,<span class="string">"com.lifevibes.mx.ipc"</span>&#125;,</span><br><span class="line">#endif</span><br><span class="line">&#123;AID_MEDIA,<span class="string">"media.audio_flinger"</span>&#125;,</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总结一下，ServiceManager不过就是保存了一些服务的信息。</p>
<h3 id="ServiceManager存在的意义"><a href="#ServiceManager存在的意义" class="headerlink" title="ServiceManager存在的意义"></a>ServiceManager存在的意义</h3><ul>
<li><p>ServiceManager能集中管理系统内的所有服务，它能施加权限控制，并不是任何进程都能注册服务的。</p>
</li>
<li><p>ServiceManager支持通过字符串名称来查找对应的Service。这个功能很像DNS。</p>
</li>
<li><p>由于各种原因的影响，Service进程可能生死无常，如果让每个Client都去检测，压力实在太大了。现在有了统一的管理机构，Client只需要查询ServiceManager，就能把我动向，得到最新信息。</p>
</li>
</ul>
<h2 id="MediaPlayerService和它的Client"><a href="#MediaPlayerService和它的Client" class="headerlink" title="MediaPlayerService和它的Client"></a>MediaPlayerService和它的Client</h2><p>前面一直讨论ServiceManager和它的Client，现在我们以MediaPlayerService的Client来进行分析。由于ServiceManager不是从BnServiceManager中派生的，所以之前没有讲数据请求是如何从通信层传递到业务层并进行处理的。我们以MediaPlayerService和它的Client作为分析对象，试着解决这些遗留问题。</p>
<h3 id="查询ServiceManager"><a href="#查询ServiceManager" class="headerlink" title="查询ServiceManager"></a>查询ServiceManager</h3><p>一个Client想要得到某个Service的信息，就必须先和ServiceManager打交道，通过调用getService函数来获取对应Service的信息。getService函数的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个函数通过与ServiceManager通信，获得一个能够与MediaPlayerService通信的BpBinder，然后再通过障眼法interface_cast，转换成一个BpMediaPlayerService。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">IMediaDeathNotifier::getMediaPlayerService() </span><br><span class="line">&#123;</span><br><span class="line">sp &lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">sp&lt;IBinder&gt;binder;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//向ServiceManager查询对应服务的信息，返回BpBinder。</span></span><br><span class="line">binder = sm-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br><span class="line"><span class="keyword">if</span>(binder!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果ServiceManager上还没有注册对应的服务，则需要等待，直到对应服务注册</span></span><br><span class="line"><span class="comment">//到ServiceManager中为止。</span></span><br><span class="line">usleep(<span class="number">500000</span>);</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过interface_casr,将这个binder转化成BpMediaPlayer，binder中handle标识的一定是目的端MediaPlayerService。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sMediaPlayerService=interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sMediaPlayerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了BpMediaPlayerService，就能够使用任何IMediaPlayerService提供的业务逻辑函数了。</p>
<p>调用这些函数都能够把请求数据打包发送给Binder驱动，并由BpBinder的handle值找到对应端的处理者来处理，这中间的过程如下所示：</p>
<ol>
<li>通信层接收到请求。</li>
<li>提交给业务层处理</li>
</ol>
<h3 id="MediaPlayerService细节"><a href="#MediaPlayerService细节" class="headerlink" title="MediaPlayerService细节"></a>MediaPlayerService细节</h3><p>在上文中我们可以看到，MediaPlayerService驻留在MediaPlayer进程中，这个进程有两个线程在talkWithDriver,假设其中有一个线程收到了请求消息，它最终通过executeCommand调用来处理这个请求，实现代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(<span class="keyword">int32_t</span> cmd)</span><br><span class="line">&#123;</span><br><span class="line">BBinder *obj;</span><br><span class="line">RefBase::weakref_type*refs;</span><br><span class="line"><span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"><span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> BR_ERROR:</span><br><span class="line">result = mIn.readInt32();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">&#123;</span><br><span class="line">binder_transaction_data tr;</span><br><span class="line">result = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"><span class="keyword">if</span>(result != NO_ERROR)<span class="keyword">break</span>;</span><br><span class="line">Parcel buffer;</span><br><span class="line">Parcel reply;</span><br><span class="line"><span class="keyword">if</span>(tr.target.ptr) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">看到BBinder想起图6-3了吗？BnServiceXXX从BBinder派生，这里的b实际就是实现BnServiceXXX的那个对象，这样就直接定位到了业务层的对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sp&lt;BBinder&gt; b ((BBinder*)tr.cookie);</span><br><span class="line"><span class="keyword">const</span> status_T error = b -&gt; transact(tr.code,buffer,&amp;reply,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (error &lt; NO_ERROR)reply.setError(error);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the_context_object是IPCThreadState.cpp中定义的一个全局变量。可通过setTheContextObject函数设置。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">status_t</span> error = the_context_object-&gt;transact(tr.code,buffer,&amp;reply,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>BBinder与业务层的关系我们可以通过这张图来梳理一下：</p>
<p><img src="https://i.loli.net/2019/09/06/h2D7ucwqQFpXHti.png" alt="BBinder_MediaPlayerService.PNG"></p>
<p>BnMediaPlayerService实现了onTransact函数，它将根据消息码调用对应的业务逻辑函数，这些业务逻辑函数由MediaPlayerService来实现，这些过程写在了Binder.cpp和IMediaPlayerService.cpp中，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BBinder::transact(</span><br><span class="line"><span class="keyword">uint32_t</span> code,<span class="keyword">const</span> Parcel &amp; data,Parcel*reply,<span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">data.setDataPosition(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">status_t</span> err = NO_ERROR;</span><br><span class="line"><span class="keyword">switch</span>(code) &#123;</span><br><span class="line"><span class="keyword">case</span> PING_TRANSACTION:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//调用子类的onTransact,这是一个虚函数</span></span><br><span class="line">err = onTransact(code, data, reply, flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(reply != <span class="literal">NULL</span>) &#123;</span><br><span class="line">reply-&gt;setDataPosision(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BnMediaPlayerService::onTransact(<span class="keyword">uint32_t</span> code,<span class="keyword">const</span> Parcel &amp; data,Parcel *reply,<span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(code) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">case</span> CREATE_MEDIA_RECORDED:&#123;</span><br><span class="line">CHECK_INTERFACE(IMediaPlayerService,data,reply);</span><br><span class="line"><span class="comment">//从请求数据中解析对应的参数</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = data.readInt32();</span><br><span class="line"><span class="comment">//子类要实现createMediaRecorder函数</span></span><br><span class="line">sp&lt;IMediaRecorder&gt; recorder = createMediaRecorder(pid);</span><br><span class="line">reply -&gt; writeStrongBinder(recorder-&gt;asBinder());</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CREATE_METADATA_RETRIEVER:&#123;</span><br><span class="line">CHECK_INTERFACE(IMediaPlayerService,data,reply);</span><br><span class="line"><span class="keyword">pid_t</span> pid = data.readInt32();</span><br><span class="line"><span class="comment">//子类要实现createMetadataRetriever函数</span></span><br><span class="line">sp&lt;IMediaMetadataRetriever&gt; retriever = createMetadataRetriever(pid);</span><br><span class="line">reply -&gt; writeStrongBinder(retriever-&gt;asBinder());</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> BBinder::onTransact(code,data,reply,flags);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binder的实现"><a href="#Binder的实现" class="headerlink" title="Binder的实现"></a>Binder的实现</h2><p>Binder的驱动代码在kernel/drivers/staing/android/binder.c中，另外该目录下还有一个binder.h头文件。/proc/binder目录下的内容可用来查看Binder设备的运行状态。</p>
<h3 id="Binder和线程的关系"><a href="#Binder和线程的关系" class="headerlink" title="Binder和线程的关系"></a>Binder和线程的关系</h3><p>以MS（MediaPlayerService）为例，如果现在程序运行正常，那么MS在进行两个动作：</p>
<ol>
<li><p>通过startThreadPool启动一个线程，这个线程在talkWithDriver.</p>
</li>
<li><p>主线程通过joinThreadPool也在talkWithDriver.</p>
</li>
</ol>
<p>如果在业务逻辑上需要与ServiceManager交互，比如说要调用listServices打印所有服务的名字，假设这是MS中的第三个线程，按照之前的分析，它最终会调用IPCThreadState的transact函数，这个函数会talkWithDriver并把请求发到ServiceManager进程，然后等待来自Binder设备的回复。现在有三个进程在talkWithDriver。</p>
<p>ServiceManager处理完了listServices，把回复结果写回Binder驱动，调用listServices的那个线程就会得到这个结果，一一对应。</p>
<h3 id="Binder消息通知"><a href="#Binder消息通知" class="headerlink" title="Binder消息通知"></a>Binder消息通知</h3><p>在Binder系统中，如果对应的BnXXX被终止了，那么我们可以通过一些方式收到这个通知</p>
<p>注册对应的监听需要做以下两件事：</p>
<ol>
<li><p>从IBinder::DeathRecipient派生一个类，并实现其中的通知函数binderDied。这个函数会在BnXXX被终止时调用。</p>
</li>
<li><p>把这个类注册到系统中，告诉它你关系哪一个BnXXX的生死</p>
</li>
</ol>
<p>这个消息是这么被收到的呢？其实也在executeCommand中，通过Proxy（对应着已经死亡的BBinder）发送消息</p>
<p>如果注册监听的进程率先被终止了，那么可以通过调用unlinkToDeath取消对对应的BnXXX死亡的监听</p>
<h3 id="匿名Service"><a href="#匿名Service" class="headerlink" title="匿名Service"></a>匿名Service</h3><p>匿名Service就是没有注册的Service，包含了以下两个意思：</p>
<ol>
<li>没有注册Service意味着这个Service没有在ServiceManager上注册</li>
<li>它是一个Service又表示它确实是一个基于Binder通信的C/S结构</li>
</ol>
<p>可以通过下面这个例子来了解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BnMediaPlayerService::onTransact(<span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel &amp; data,Parcel *reply,<span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(code) &#123;</span><br><span class="line"><span class="keyword">case</span> CREATE_URL: &#123;</span><br><span class="line">CHECK_INTERFACE(IMediaPlayerService,data,reply);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//player是一个IMediaPlayer类型的对象。</span></span><br><span class="line">sp&lt;IMediaPlayer&gt; player = create(pid,client,url,numHeaders&gt;<span class="number">0</span>?&amp;headers:<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//下面这句话也很重要</span></span><br><span class="line">reply-&gt;writeStrongBinder（player-&gt;asBinder());</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>当MediaPlayerClient调用create函数时，MediaPlayerService会返回一个IMediaPlayer对象，此后，MediaPlayerClient即可直接使用这个IMediaPlayer来进行跨进程的函数调用了。</p>
<p>BpMediaPlayer实际上是通过这个方法来得到BnMediaPlayer的handle的值的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">reply-&gt;writeStrongBinder（player-&gt;asBinder());</span><br></pre></td></tr></table></figure>
<p>当这个reply写到Binder驱动中时，驱动可能会特殊处理这种IBinder类型的数据，例如为这个BBinder建立一个独一无二的handle，这其实相当于在Binder驱动中注册了一项服务。</p>
<p>通过这种方式，MS输出了大量的Service，例如IMediaPlayer和IMediaRecorder等。</p>
<h3 id="Service的实现实例（Native层）"><a href="#Service的实现实例（Native层）" class="headerlink" title="Service的实现实例（Native层）"></a>Service的实现实例（Native层）</h3><p>纯Native的Service表示代码都在Native层。Native层有有很多Service，前面的MediaPlayerService就是一个例子。</p>
<p>如果我们要新建实现一个Service，也完全可以模仿MS，代码示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line"><span class="comment">//记住注册你的服务，否则谁也找不到你</span></span><br><span class="line">sm-&gt;addService(<span class="string">"service.name"</span>,<span class="keyword">new</span> Test());</span><br><span class="line"><span class="comment">//如果压力不大，可以不用单独搞一个线程</span></span><br><span class="line">ProcessState::self()-&gt;startThreadPool();</span><br><span class="line"><span class="comment">//这个是必须的，否则主线程退出了，你也完了</span></span><br><span class="line">IPCThreadState::self()-&gt;joinThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test是这么定义的呢？我们是跨进程的C/S,所以本地需要一个BnTest，对端需要提供一个代理BpTest。为了不暴露Bp的身份，Bp的定义和实现都放在BnTest.cpp中了。</p>
<p>ITest接口表明了它所能提供的服务，例如getTest和setTest等，这个与业务逻辑相关，代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要从IInterface派生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ITest</span>:</span><span class="keyword">public</span> IInterface。</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//神奇的宏 DECLEAR_MATA_INTERFACE。</span></span><br><span class="line">DECLEAR_META_INTERFACE(Test);</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">getTest</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setTest</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//ITest是一个接口类</span></span><br></pre></td></tr></table></figure>
<p>为了把ITest融入到Binder系统，需要定义BnTest和对客户端透明的BpTest。BnTest定义既可以与上面的Test定义放在一块，也可以分开，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnTest</span>:</span><span class="keyword">public</span> BnInterface&lt;ITest&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//由于ITest是个纯虚类，而BnTest只实现了onTransact函数，所以BnTest依然是一个纯虚类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">onTransact</span><span class="params">(uint32_T code, <span class="keyword">const</span> Parcel &amp; data,Parcel *reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外，我们还要使用IMPLEMENT宏。参考BnMediaPlayerService的方法，把BnTest和BpTest的实现都放在ITest.cpp中，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(Test,<span class="string">"android.Test.ITest"</span>);<span class="comment">//IMPLEMENT宏</span></span><br><span class="line"><span class="keyword">status_t</span> BnTest::onTransact(</span><br><span class="line"><span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel &amp; data,Parcel *reply,<span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(code) &#123;</span><br><span class="line"><span class="keyword">case</span> GET_Test:&#123;</span><br><span class="line">CHECK_INTERFACE(ITest,data,reply);</span><br><span class="line">getTest();<span class="comment">//子承父业，由Test完成</span></span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;<span class="keyword">break</span>;<span class="comment">//SET_XXX类似</span></span><br></pre></td></tr></table></figure>
<p>BpTest示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpTest</span>:</span><span class="keyword">public</span> BpInterface&lt;ITest&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BpXXX(<span class="keyword">const</span> sp&lt;IBinder&gt; &amp; impl)</span><br><span class="line">:BpInterface&lt;ITest&gt;(Impl)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vitural <span class="title">getTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Parcel data,reply;</span><br><span class="line">data.writeInterfaceToken(ITest::getInterfaceDescriptor());</span><br><span class="line">data.writeInt32(pid);</span><br><span class="line"><span class="comment">//打包请求数据，然后交给BpBinder通信层处理。</span></span><br><span class="line">remote()-&gt;transact(GET_Test,data, &amp;reply);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">?</span><br><span class="line"><span class="comment">//setTest类似</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>这样C/S的框架就写好了。</p>
<h3 id="Service的实现实例（Java层）"><a href="#Service的实现实例（Java层）" class="headerlink" title="Service的实现实例（Java层）"></a>Service的实现实例（Java层）</h3><p>在Java层中，如果想要利用Binder进行跨进程的通信，也得定义一个类似ITest的接口，不过，这是一个aidl文件，假设服务端程序都在com.test.service包中。</p>
<p>ITest.aidl文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.test.service;</span><br><span class="line">import com.test.complicatedDataStructure;</span><br><span class="line">interface ITest&#123;</span><br><span class="line">//complicatedDataStructure类是自己定义的复杂数据结构，in表示输入参数，out表示输出参数。</span><br><span class="line">//in和out的表示一定要准备却。切记！</span><br><span class="line">int getTest(out complicateddataStructure c);</span><br><span class="line">int setTest(in String name, in boolean reStartServer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后，会在gen目录下生成一个com.test.ITest.java文件，它实现了类似BnTest的一个东西，具体的业务实现还需要从ITest.Stub派生，实现代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">ITest.Stub是在aidl生成的那个Java文件中定义的，非常类似Native层的BnTest。</span></span><br><span class="line"><span class="comment">ITestImpl必须从ITest.Stub中派生，用来实现具体的业务函数。</span></span><br><span class="line"><span class="comment">package com.test.service;</span></span><br><span class="line"><span class="comment">class ITestImpl extends ITest.Stub&#123;</span></span><br><span class="line"><span class="comment">public void getTest(complicatedData Structure cds) throws RemoteException &#123;</span></span><br><span class="line"><span class="comment">//在这里实现具体的getTest</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">public void setTest(in String name, in boolean reStartServer) throws RemoteException &#123;</span></span><br><span class="line"><span class="comment">//在这里实现具体的setTest</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p>此时根目录下有这两个目录：</p>
<ul>
<li><p>src下有一个com.test.service包结构目录</p>
</li>
<li><p>gen下也有一个com.test.service包结构目录</p>
</li>
</ul>
<p>实现代理端：代理端往往在另一个程序中使用，假设是com.test.client包，把刚才com.test.service工程中gen下的com.test.service目录全部复制到com.test.client中，这样，client工程也就有两个包结构目录了：</p>
<ul>
<li><p>com.test.client</p>
</li>
<li><p>com.test.service。不过这个目录中仅有aidl生成的Java文件</p>
</li>
</ul>
<p>服务端一般驻留于Service进程，所以可以在Client端的onServiceConnected函数中获得代理对象，实现代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//不一定是在onServiceConnected中，但它是比较合适的。</span><br><span class="line">private ServiceConnection serviceConnection = new ServiceConnection() &#123;</span><br><span class="line">@override</span><br><span class="line">public void onServiceConnected(ConponentName name, IBinder service) &#123;</span><br><span class="line">if (ITestProxy == null) &#123;</span><br><span class="line">ITestProxy = ITest.Stub.asInterface(service);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AIDL支持简单数据结构与Java中String类型的数据进行跨进程传递，如果想做到跨进程传递复杂的数据结构，还须另做一些工作。</p>
<p>以ITest.aidl文件中使用的complicatedDataStructure为例：</p>
<ul>
<li><p>它必须实现implementsParcelable接口</p>
</li>
<li><p>内部必须有一个静态的CREATOR类</p>
</li>
<li><p>定义一个complicatedDataStructure文件。</p>
</li>
</ul>
<p>在实现了Java文件后，我们还需要实现aidl类，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.test.service;</span><br><span class="line">parcelable complicatedDataStructure;</span><br></pre></td></tr></table></figure>
<p>然后在使用它的aidl文件中添加这行代码即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.test.complicatedDataStrucrure;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Android提供AIDL语言以及AIDL解释器自动生成一个服务器的Bn端，即Bp端用于处理Binder通信的代码，当我们写好ITest.aidl文件之后，我们使用aidl工具将其解析为一个实现了Bn端及Bp端通过Binder进行通信的Java代码，当完成aidl解析之后，开发者需要继承XXX.Stub类并实现其抽象方法。</p>
</blockquote>
<h1 id="Java-Binder整体架构"><a href="#Java-Binder整体架构" class="headerlink" title="Java Binder整体架构"></a>Java Binder整体架构</h1><p>Java层的Binder其实也是一个C/S架构，而且在类的命名上尽量保持与Native层一致，因此也可认为，Java层的Binder架构是Native层Binder架构的一个镜像。Java Binder中的成员如下图所示：</p>
<p><img src="https://i.loli.net/2019/09/14/w8AjvftVremi5BT.png" alt="JavaBinder.PNG"></p>
<p>其中：</p>
<ul>
<li><p>Binder和BinderProxy类分别实现了IBinder接口。其中Binder类作为服务端的Bn的代表，而BinderProxy作为客户端的Bp的代表（由linkToDeath（）函数也可见一斑，native层中Bp正是由这个函数来实现消息通知）</p>
</li>
<li><p>BinderInternal类是一个仅供Binder框架使用的类。它内部有一个GcWatcher类，该类专门用于处理和Binder相关的垃圾回收</p>
</li>
</ul>
<blockquote>
<p>IBinder接口类中定义了一个叫FLAG_ONEWAY的整型变量，在调用Binder函数时，在指明了FLAG_ONEWAY标志后，函数就变成了非阻塞式调用（类似于回调）</p>
</blockquote>
<p>Java层Binder需要借助Native层Binder系统来开展工作，即镜像和Native有着千丝万缕的关系，一定要在Java层Binder正式工作之前建立这种关系，Java层Binder框架的初始化顺序如下：</p>
<p>Java初创初期，系统会提前注册一些JNI函数，其中有一个register_android_os_Binder函数来专门搭建Java Binder和Native交互关系，在register_android_os_Binder函数中，完成了JavaBinder架构中最重要的三个类的初始化工作，顺序如下：</p>
<ol>
<li><p>Binder类的初始化：使用gBinderOffsets对象保存了和Binder类相关的某些在JNI层使用的信息，用来在JNI层对Java层的Binder对象进行操作</p>
</li>
<li><p>BinderInternal类的初始化：获取一些有用的methodID和fieldID，表明JNI层一定会向上调用Java层的函数，以及注册相关类中native函数的实现。</p>
</li>
<li><p>BinderProxy类的初始化：获取WeakReference类和ERROR类的一些信息，BinderProxy对象的生命周期会委托WeakReference来管理，所以JNI层会获取该类get函数的MethodID</p>
</li>
</ol>
<blockquote>
<p>框架的初始化其实就是提前获取一些JNI层的使用信息，如类成员的MethodID、类成员变量的fieldID等。它能节省每次使用时获取这些信息的时间。当Binder调用频繁时，这些时间的积累也不容小觑。同时，这个过程中所创建的几个全局静态对象为JNI层访问Java层的对象提供了依据。每个初始化函数中所执行的registerNativeMethods（）方法则为Java层访问JNI层打通了道路。换句话说，Binder初始化的工作就是通过JNI建立起Native Binder与Java Binder之间互相通信的桥梁。</p>
</blockquote>
<h2 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h2><p>与native中MediaServer的例子一样，这里我们也使用一个具体的例子来解释Java层Binder的工作原理</p>
<h3 id="AMS如何将自己注册到ServiceManager"><a href="#AMS如何将自己注册到ServiceManager" class="headerlink" title="AMS如何将自己注册到ServiceManager"></a>AMS如何将自己注册到ServiceManager</h3><p>AMS通过addService函数将一个叫做JavaBBinder的对象添加到Parcel中，而最终传递到Binder驱动的正是这个JavaBBinder对象。Java层中所有的Binder对应的都是这个JavaBBinder对象，不同的Binder对象对应不同的JavaBBinder对象。</p>
<blockquote>
<p>JavaBBinder是从BBinder（native）派生的</p>
</blockquote>
<h3 id="ActivityManagerService相应请求"><a href="#ActivityManagerService相应请求" class="headerlink" title="ActivityManagerService相应请求"></a>ActivityManagerService相应请求</h3><p>JavaBBinder仅仅是一个传声筒，它本身不实现任何业务函数，其工作是：</p>
<ol>
<li><p>当它收到请求时，只是简单地调用它所绑定的Java层的Binder对象的exeTransact</p>
</li>
<li><p>该Binder对象的exeTransact调用其子类实现的onTransact函数</p>
</li>
<li><p>子类的onTransact函数将业务又派给其子类来完成</p>
</li>
</ol>
<p>通过这种方式，来自客户端的请求就能传递到正确的Java Binder对象了，下图展示了AMS相应请求的整个流程。</p>
<p><img src="https://i.loli.net/2019/09/15/ng2K67ZuPajXBOd.png" alt="AMS响应过程.PNG"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本章的学习中，我们学习了native中的Binder和Java中的Binder，总结分别如下：</p>
<h2 id="native层Binder"><a href="#native层Binder" class="headerlink" title="native层Binder"></a>native层Binder</h2><ol>
<li><p>Binder体系的总体架构，Client、Server和ServiceManager三者之间的关系（包括交互的先后关系）、</p>
</li>
<li><p>MediaPlayerService注册服务解析，通过handle=0找到ServiceManager注册，最后MediaPlayerService有两个线程处理请求</p>
</li>
<li><p>ServiceManager解析，ServiceManager成为manager需要将自己的handle置为0，它的作用是对需要注册的服务进行管理，包括权限控制等，同时帮助Client找到对应的Server</p>
</li>
<li><p>Client通过字符串（Service的名称）来得到对应的服务，这里以MediaPlayerService为例，展示了Client与MediaPlayerService交互的细节，哪个线程发起请求，答复就会送回到哪个请求</p>
</li>
<li><p>Binder对于匿名Service的管理，匿名Service可以通过在Binder驱动中的操作来注册自己（其实就是给自己一个独一无二的handle），以及对死亡进程的监听，native层与Java层Service的实现</p>
</li>
</ol>
<h2 id="native层Binder-1"><a href="#native层Binder-1" class="headerlink" title="native层Binder"></a>native层Binder</h2><p>Java层的Binder可以用一张图来总结，因为Java层的Binder十分依赖native层的Binder。</p>
<p><img src="https://i.loli.net/2019/09/15/VbfDFe5L8pTMUro.png" alt="Java层Binder架构.PNG"></p>
]]></content>
      <categories>
        <category>深入理解Android系列丛书学习</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin之码上开学课后习题（不时更新）</title>
    <url>/2019/08/21/Kotlin%E4%B9%8B%E7%A0%81%E4%B8%8A%E5%BC%80%E5%AD%A6%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<p>马上开学地址为<a href="https://kaixue.io/" target="_blank" rel="noopener">链接</a></p>
<h1 id="Kotlin-的变量、函数和类型"><a href="#Kotlin-的变量、函数和类型" class="headerlink" title="Kotlin 的变量、函数和类型"></a>Kotlin 的变量、函数和类型</h1><h2 id="使用-Android-Studio-创建一个基于-Kotlin-的新项目（Empty-Activity），添加一个新的属性（类型是非空的-View），在-onCreate-函数中初始化它。"><a href="#使用-Android-Studio-创建一个基于-Kotlin-的新项目（Empty-Activity），添加一个新的属性（类型是非空的-View），在-onCreate-函数中初始化它。" class="headerlink" title="使用 Android Studio 创建一个基于 Kotlin 的新项目（Empty Activity），添加一个新的属性（类型是非空的 View），在 onCreate 函数中初始化它。"></a>使用 Android Studio 创建一个基于 Kotlin 的新项目（Empty Activity），添加一个新的属性（类型是非空的 View），在 onCreate 函数中初始化它。</h2><p>kotlin如果需要创建非空的属性，我们需要用到<em>lateinit</em>关键字，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.kotlinkaixue</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> view : View</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        view = findViewById(R.id.view)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="声明一个参数为-View-类型的方法，传入刚才的-View-类型属性，并在该方法中打印出该-View-的-id。"><a href="#声明一个参数为-View-类型的方法，传入刚才的-View-类型属性，并在该方法中打印出该-View-的-id。" class="headerlink" title="声明一个参数为 View? 类型的方法，传入刚才的 View 类型属性，并在该方法中打印出该 View? 的 id。"></a>声明一个参数为 View? 类型的方法，传入刚才的 View 类型属性，并在该方法中打印出该 View? 的 id。</h2><p>代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.kotlinkaixue</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> view : View? =  <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = MainActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">name</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        view = findViewById(R.id.view)</span><br><span class="line">        Log.i(TAG, view?.id.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出的日志如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-08-23 21:14:49.736 6126-6126/com.example.kotlinkaixue I/com.example.kotlinkaixue.MainActivity: 2131165328</span><br></pre></td></tr></table></figure>
<h1 id="Kotlin-里那些「不是那么写的」"><a href="#Kotlin-里那些「不是那么写的」" class="headerlink" title="Kotlin 里那些「不是那么写的」"></a>Kotlin 里那些「不是那么写的」</h1><h2 id="创建一个-Kotlin-类，这个类需要禁止外部通过构造器创建实例，并提供至少一种实例化方式。"><a href="#创建一个-Kotlin-类，这个类需要禁止外部通过构造器创建实例，并提供至少一种实例化方式。" class="headerlink" title="创建一个 Kotlin 类，这个类需要禁止外部通过构造器创建实例，并提供至少一种实例化方式。"></a>创建一个 Kotlin 类，这个类需要禁止外部通过构造器创建实例，并提供至少一种实例化方式。</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">kotlinKaixue</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> instance = kotlinKaixue()</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span> : kotlinKaixue &#123;</span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这实际上是一种饿汉式单例的写法，但是它保证了线程安全</p>
</blockquote>
<h2 id="分别用-Array、IntArray、List-实现-「保存-1-100-000-的数字，并求出这些数字的平均值」，打印出这三种数据结构的执行时间。"><a href="#分别用-Array、IntArray、List-实现-「保存-1-100-000-的数字，并求出这些数字的平均值」，打印出这三种数据结构的执行时间。" class="headerlink" title="分别用 Array、IntArray、List 实现 「保存 1-100_000 的数字，并求出这些数字的平均值」，打印出这三种数据结构的执行时间。"></a>分别用 Array、IntArray、List 实现 「保存 1-100_000 的数字，并求出这些数字的平均值」，打印出这三种数据结构的执行时间。</h2><p>代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> maxNum = <span class="number">1000</span>_000;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testArray</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">val</span> array: Array&lt;<span class="built_in">Int</span>&gt; = Array(maxNum) &#123;</span><br><span class="line">            it.inc()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> array) &#123;</span><br><span class="line">            sum += i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> avg = BigDecimal(sum).divide(BigDecimal(array.size))</span><br><span class="line">        <span class="keyword">val</span> duration = System.currentTimeMillis() - startTime</span><br><span class="line">        println(<span class="string">"Array: avg = <span class="variable">$avg</span>, duration = <span class="variable">$duration</span> ms"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testIntArray</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">        <span class="keyword">val</span> intArray: IntArray = IntArray(maxNum) &#123;</span><br><span class="line">            it.inc()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        intArray.forEach &#123;</span><br><span class="line">            sum += it</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> avg = BigDecimal(sum).divide(BigDecimal(intArray.size))</span><br><span class="line">        <span class="keyword">val</span> duration = System.currentTimeMillis() - startTime</span><br><span class="line">        println(<span class="string">"IntArray: avg = <span class="variable">$avg</span>, duration = <span class="variable">$duration</span> ms"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testList</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">        <span class="keyword">val</span> list : List&lt;<span class="built_in">Int</span>&gt; = List(maxNum) &#123;</span><br><span class="line">            it.inc()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        list.forEach &#123;</span><br><span class="line">            sum += it</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> avg = BigDecimal(sum).divide(BigDecimal(list.size))</span><br><span class="line">        <span class="keyword">val</span> duration = System.currentTimeMillis() - startTime</span><br><span class="line">        println(<span class="string">"list: avg = <span class="variable">$avg</span>, duration = <span class="variable">$duration</span> ms"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    testArray()</span><br><span class="line">    testIntArray()</span><br><span class="line">    testList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array: avg = 1784.293664, duration = 29 ms</span><br><span class="line">IntArray: avg = 1784.293664, duration = 9 ms</span><br><span class="line">list: avg = 1784.293664, duration = 35 ms</span><br></pre></td></tr></table></figure>
<h1 id="Kotlin-里那些「更方便的」"><a href="#Kotlin-里那些「更方便的」" class="headerlink" title="Kotlin 里那些「更方便的」"></a>Kotlin 里那些「更方便的」</h1><h2 id="请按照以下要求实现一个-Student-类："><a href="#请按照以下要求实现一个-Student-类：" class="headerlink" title="请按照以下要求实现一个 Student 类："></a>请按照以下要求实现一个 Student 类：</h2><ol>
<li>写出三个构造器，其中一个必须是主构造器</li>
<li>主构造器中的参数作为属性</li>
<li>写一个普通函数 show，要求通过字符串模板输出类中的属性</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="number">23</span>, <span class="literal">true</span>)</span><br><span class="line">    student.show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">constructor</span></span>(<span class="keyword">var</span> age:<span class="built_in">Int</span>, <span class="keyword">val</span> sex:<span class="built_in">Boolean</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hobby : String ? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(person: Person) : <span class="keyword">this</span>(person.age, person.sex)</span><br><span class="line">    <span class="keyword">constructor</span>(age: <span class="built_in">Int</span>, sex: <span class="built_in">Boolean</span>,hobby: String?) : <span class="keyword">this</span>(age, sex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hobby = hobby</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"age = <span class="variable">$age</span>, sex = <span class="variable">$sex</span>, hobby = <span class="variable">$hobby</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(<span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> sex: <span class="built_in">Boolean</span>)</span><br></pre></td></tr></table></figure>
<h2 id="编写程序，使用今天所讲的操作符，找出集合-21-40-11-33-78-中能够被-3-整除的所有元素，并输出。"><a href="#编写程序，使用今天所讲的操作符，找出集合-21-40-11-33-78-中能够被-3-整除的所有元素，并输出。" class="headerlink" title="编写程序，使用今天所讲的操作符，找出集合 {21, 40, 11, 33, 78} 中能够被 3 整除的所有元素，并输出。"></a>编写程序，使用今天所讲的操作符，找出集合 {21, 40, 11, 33, 78} 中能够被 3 整除的所有元素，并输出。</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> array = intArrayOf(<span class="number">21</span>, <span class="number">40</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">78</span>)</span><br><span class="line">     <span class="keyword">val</span> result = array.filter &#123;</span><br><span class="line">        it % <span class="number">3</span> == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.forEach &#123;</span><br><span class="line">        print(<span class="string">"<span class="variable">$it</span> "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Kotlin-的泛型"><a href="#Kotlin-的泛型" class="headerlink" title="Kotlin 的泛型"></a>Kotlin 的泛型</h1><h2 id="实现一个-fill-函数，传入一个-Array-和一个对象，将对象填充到-Array-中，要求-Array-参数的泛型支持逆变（假设-Array-size-为-1）。"><a href="#实现一个-fill-函数，传入一个-Array-和一个对象，将对象填充到-Array-中，要求-Array-参数的泛型支持逆变（假设-Array-size-为-1）。" class="headerlink" title="实现一个 fill 函数，传入一个 Array 和一个对象，将对象填充到 Array 中，要求 Array 参数的泛型支持逆变（假设 Array size 为 1）。"></a>实现一个 fill 函数，传入一个 Array 和一个对象，将对象填充到 Array 中，要求 Array 参数的泛型支持逆变（假设 Array size 为 1）。</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span> <span class="title">fill</span><span class="params">(array : <span class="type">Array</span>&lt;<span class="type">T</span>&gt;, item : <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    array[<span class="number">0</span>] = item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现一个-copy-函数，传入两个-Array-参数，将一个-Array-中的元素复制到另外个-Array-中，要求-Array-参数的泛型分别支持协变和逆变。（提示：Kotlin-中的-for-循环如果要用索引，需要使用-Array-indices）"><a href="#实现一个-copy-函数，传入两个-Array-参数，将一个-Array-中的元素复制到另外个-Array-中，要求-Array-参数的泛型分别支持协变和逆变。（提示：Kotlin-中的-for-循环如果要用索引，需要使用-Array-indices）" class="headerlink" title="实现一个 copy 函数，传入两个 Array 参数，将一个 Array 中的元素复制到另外个 Array 中，要求 Array 参数的泛型分别支持协变和逆变。（提示：Kotlin 中的 for 循环如果要用索引，需要使用 Array.indices）"></a>实现一个 copy 函数，传入两个 Array 参数，将一个 Array 中的元素复制到另外个 Array 中，要求 Array 参数的泛型分别支持协变和逆变。（提示：Kotlin 中的 for 循环如果要用索引，需要使用 Array.indices）</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span> <span class="title">copy</span><span class="params">(arrayIn : <span class="type">Array</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;, arrayOut : <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> arrayIn.indices) &#123;</span><br><span class="line">        arrayIn[i] = arrayOut[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Android gradle插件基础</title>
    <url>/2019/08/18/Android-gradle%E6%8F%92%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>在项目的build.gradle文件中，我们可以看到默认的插件是这样的。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-android'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-android-extensions'</span></span><br></pre></td></tr></table></figure>
<p>注意，本项目使用了kotlin，所以多用了两个插件，分别是<em>kotlin-android</em>和<em>kotlin-android-extensions</em>两个插件，如果我们需要自定义自己的插件，那么需要按照如下步骤创建</p>
<h1 id="创建自定义插件"><a href="#创建自定义插件" class="headerlink" title="创建自定义插件"></a>创建自定义插件</h1><h2 id="创建自定义插件项目"><a href="#创建自定义插件项目" class="headerlink" title="创建自定义插件项目"></a>创建自定义插件项目</h2><p>需要创建自定义gradle插件，第一步创建新module，但是需要注意，<em>我们需要在项目的setting.gradle中将它去掉</em>。</p>
<p>这里特别注意的是自定义插件项目的module名字是约定好的，必须为<strong>buildSrc</strong></p>
<p>创建完module后目录如下：</p>
<p><img src="https://i.loli.net/2019/08/18/KYch9pf7tiqILRM.png" alt="微信图片_20190818144514.png"></p>
<h2 id="创建插件类"><a href="#创建插件类" class="headerlink" title="创建插件类"></a>创建插件类</h2><p>我这里是用Kotlin进行编写的，代码如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.multilingual</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoMultilingualResourcePlugin</span> : <span class="type">Plugin</span>&lt;<span class="type">Project</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的apply函数就是将插件引入到项目中的逻辑</p>
<h2 id="自定义插件名字"><a href="#自定义插件名字" class="headerlink" title="自定义插件名字"></a>自定义插件名字</h2><p>我们的项目名是buildSrc无法自定义，但是插件的名字是我们自己定义的，定义的方法如下：</p>
<p>在项目的main目录下创建resources目录，再在resources目录下创建META-INF目录，META-INF目录下再创建gradle-plugins目录，再gradle-plugins目录下我们就能声明我们的自定义插件了，我们需要创建<em>自定义插件名.properties</em></p>
<p>最后的目录结构如下</p>
<p><img src="https://i.loli.net/2019/08/18/9RIeVQfOrLChaDl.png" alt="微信图片_20190818151247.png"></p>
<p>可以看到，我自定义插件名字为<em>cn.wongzhenyu.multilingual</em>，这里要取自己的名字。</p>
<p>再这个文件中，我们还需要指定插件的入口，我这里填的如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation-class=com.example.multilingual.AutoMultilingualResourcePlugin</span><br></pre></td></tr></table></figure>
<p>这样，我们就指定了本插件的入口，我们可以在主项目中使用了，像这样</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'cn.wongzhenyu.multilingual'</span></span><br></pre></td></tr></table></figure>
<h1 id="配置自定义插件"><a href="#配置自定义插件" class="headerlink" title="配置自定义插件"></a>配置自定义插件</h1><p>我们可以看到，Android插件需要配置很多东西，想这样</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">29</span></span><br><span class="line">    buildToolsVersion <span class="string">"29.0.0"</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.example.automultilingualresourceplugin"</span></span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">        targetSdkVersion <span class="number">29</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android-optimize.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义插件也能够实现这样，在build.gradle中配置参数，然后我们在插件中可以读取到，实现方式如下</p>
<h2 id="创建扩展类"><a href="#创建扩展类" class="headerlink" title="创建扩展类"></a>创建扩展类</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.multilingual</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">MultilingualPluginExtension</span></span>&#123;</span><br><span class="line">     <span class="keyword">var</span> output:<span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们创建了一个类，只有一个布尔值变量值为true</p>
<h2 id="在build-gradle中配置参数"><a href="#在build-gradle中配置参数" class="headerlink" title="在build.gradle中配置参数"></a>在build.gradle中配置参数</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">multilingual &#123;</span><br><span class="line">    output <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在自定义插件中创建扩展类并读取参数"><a href="#在自定义插件中创建扩展类并读取参数" class="headerlink" title="在自定义插件中创建扩展类并读取参数"></a>在自定义插件中创建扩展类并读取参数</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.multilingual</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.multilingual.utils.FileUtil</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoMultilingualResourcePlugin</span> : <span class="type">Plugin</span>&lt;<span class="type">Project</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> extension: MultilingualPluginExtension</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line">        extension = project.extensions.create(<span class="string">"multilingual"</span>, MultilingualPluginExtension::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        project.afterEvaluate &#123;</span><br><span class="line">            FileUtil.INSTANCE.setIsOutput(extension.output)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要特别注意的是，我们读取在build.gradle中配置的参数必须是在gradle的evaluate声明周期之后，否则读取的参数还是默认的，而不是在build.gradle中配置的</p>
<h1 id="另一种插件-Transform"><a href="#另一种插件-Transform" class="headerlink" title="另一种插件:Transform"></a>另一种插件:Transform</h1><p>transform是插件是另一种用法，它相当于在app打包的过程中再插入了一个task，这个task会在assembleDebug之前执行，具体的代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.multilingual</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.QualifiedContent</span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.Transform</span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.TransformInvocation</span><br><span class="line"><span class="keyword">import</span> com.android.build.gradle.<span class="keyword">internal</span>.pipeline.TransformManager</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShrinkResourcePlugin</span> : <span class="type">Transform</span></span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"Test"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getInputTypes</span><span class="params">()</span></span>: MutableSet&lt;QualifiedContent.ContentType&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getScopes</span><span class="params">()</span></span>: MutableSet&lt;<span class="keyword">in</span> QualifiedContent.Scope&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isIncremental</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(transformInvocation: <span class="type">TransformInvocation</span>?)</span></span> &#123;</span><br><span class="line">        ...<span class="comment">//这里需要自己实现之前的逻辑，否则会打包出错，可添加自己的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认正确的transform函数如下，这是使用groovy实现的：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">void</span> transform(TransformInvocation transformInvocation) <span class="keyword">throws</span> TransformException, InterruptedException, IOException &#123;</span><br><span class="line">       <span class="keyword">def</span> inputs = transformInvocation.inputs</span><br><span class="line">       <span class="keyword">def</span> outputProvider = transformInvocation.outputProvider</span><br><span class="line">       inputs.each &#123;</span><br><span class="line">           it.jarInputs.each &#123;</span><br><span class="line">               File dest = outputProvider.getContentLocation(it.name, it.contentTypes, it.scopes, Format.JAR)</span><br><span class="line">               FileUtils.copyFile(it.file, dest)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           it.directoryInputs.each &#123;</span><br><span class="line">               File dest = outputProvider.getContentLocation(it.name, it.contentTypes, it.scopes, Format.DIRECTORY)</span><br><span class="line">               println <span class="string">"Dest: $&#123;it.file&#125;"</span></span><br><span class="line">               FileUtils.copyDirectory(it.file, dest)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Transform插件实现过程中需要实现的几个函数作用如下：</p>
<ul>
<li>getName</li>
</ul>
<p>返回task的名字</p>
<ul>
<li>getInputTypes()</li>
</ul>
<p>处理的文件的类型</p>
<ul>
<li>getScopes()</li>
</ul>
<p>处理的文件范围</p>
<ul>
<li>isIncremental()</li>
</ul>
<p>在transform()函数中对文件列表是否有增删改</p>
<ul>
<li>transform()</li>
</ul>
<p>具体的实现逻辑函数</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android依赖的多种关键字用法</title>
    <url>/2019/07/28/Android%E4%BE%9D%E8%B5%96%E7%9A%84%E5%A4%9A%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>Android是基于gradle进行构建的，我们也通过gradle来引入依赖项，当我们使用Android studio为我们自动得导入依赖时，我们可能会看到在本module的build.gradle中出现了这样的代码</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.okhttp:okhttp:+'</span></span><br></pre></td></tr></table></figure>
<p>这样，Android studio会自动使用最新的okhttp库，但是这样做是十分危险的，因为可能某些API更新之后会导致App无法运行。<br>同理，下面这样使用会使用在某大版本前提下的最新版本库。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.okhttp:okhttp:2.+'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Android Studio查看依赖的快捷键为Shift+Ctrl+Alt+s</p>
</blockquote>
<h2 id="Android-Gradle-Plugin-3-0-0与之前gradle配置比较"><a href="#Android-Gradle-Plugin-3-0-0与之前gradle配置比较" class="headerlink" title="Android Gradle Plugin 3.0.0与之前gradle配置比较"></a>Android Gradle Plugin 3.0.0与之前gradle配置比较</h2><p>在Android Gradle Plugin 3.0.0之前，gradle引入依赖的关键字为<em>compile</em>，但是在3.0之后，关键字就变得多样化了。具体的对比如下：</p>
<table>
<thead>
<tr>
<th>新配置</th>
<th>已弃用配置</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>implementation</td>
<td>compile</td>
<td>Gradle 会将依赖项添加到编译类路径，并将依赖项打包到构建输出。但是，当您的模块配置 implementation 依赖项时，会告知 Gradle 您不想模块在编译时将依赖项泄露给其他模块。也就是说，依赖项只能在运行时供其他模块使用。使用此依赖项配置而不是 api 或 compile（已弃用），可以显著缩短构建时间，因为它可以减少构建系统需要重新编译的模块数量。例如，如果 implementation 依赖项更改了其 API，Gradle 只会重新编译该依赖项和直接依赖它的模块。大多数应用和测试模块都应使用此配置。</td>
<td></td>
</tr>
<tr>
<td>api</td>
<td>compile</td>
<td>Gradle 会将依赖项添加到编译类路径，并构建输出。当模块包括 api 依赖项时，会告知 Gradle 模块想将该依赖项间接导出至其他模块，以使这些模块在运行时和编译时均可使用该依赖项。此配置的行为类似于 compile （现已弃用），但您应仅对需要间接导出至其他上游消费者的依赖项慎重使用它。 这是因为，如果 api 依赖项更改了其外部 API，Gradle 会重新编译可以在编译时访问该依赖项的所有模块。 因此，拥有大量 api 依赖项会显著增加构建时间。 如果不想向不同的模块公开依赖项的 API，库模块应改用 implementation 依赖项。</td>
</tr>
<tr>
<td>compileOnly</td>
<td>provided</td>
<td>Gradle 只会将依赖项添加到编译类路径（即不会将其添加到构建输出）。如果是创建 Android 模块且在编译期间需要使用该依赖项，在运行时可选择呈现该依赖项，则此配置会很有用。如果使用此配置，则您的库模块必须包含运行时条件，以便检查是否提供该依赖项，然后妥善更改其行为，以便模块在未提供依赖项的情况下仍可正常工作。这样做不会添加不重要的瞬时依赖项，有助于缩减最终 APK 的大小。 此配置的行为类似于 provided （现已弃用）。</td>
</tr>
<tr>
<td>runtimeOnly</td>
<td>apk</td>
<td>Gradle 只会将依赖项添加到构建输出，供运行时使用。也就是说，不会将其添加到编译类路径。 此配置的行为类似于 apk（现已弃用）。</td>
</tr>
<tr>
<td>annotationProcessor</td>
<td>compile</td>
<td>要在库中添加注解处理器依赖项，则必须使用 annotationProcessor 配置将其添加到注解处理器类路径。这是因为使用此配置可分离编译类路径与注解处理器类路径，从而提升构建性能。如果 Gradle 在编译类路径上找到注解处理器，则会停用 避免编译功能，这样会增加构建时间（Gradle 5.0 和更高版本会忽略编译类路径上的注解处理器）。如果 JAR 文件包含以下文件，则 Android Gradle Plugin 会假定依赖项是注解处理器：META-INF/services/javax.annotation.processing.Processor。 如果插件检测到编译类路径上包含注解处理器，则会生成构建错误。</td>
</tr>
</tbody>
</table>
<p>我们可以看到，implementation和api的区别主要是是否是传递性依赖。<br>举个例子，如果我们的Android项目采取了组件化方案，有app与common_library两个module，app模块依赖于common_library模块，在common_library中的依赖是这样的；</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">api <span class="string">'com.facebook.fresco:fresco:0.12.0'</span></span><br></pre></td></tr></table></figure>
<p>那么app模块也可以使用freso，但是如果用的不是api关键字而是implementation关键字，像这样：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'com.facebook.fresco:fresco:0.12.0'</span></span><br></pre></td></tr></table></figure>
<p>那么app模块将无法使用freso</p>
<h2 id="依赖冲突的解决方法"><a href="#依赖冲突的解决方法" class="headerlink" title="依赖冲突的解决方法"></a>依赖冲突的解决方法</h2><p>依赖冲突的原因主要是引入了不同版本的相同库，例如引入了两个库，一个库中包含了okhttp3.2。1版本，而另一个库中则包含了okhttp3.2.2版本，那么就会产生冲突，导致编译不过，解决这种冲突的方法有两种：一种是使用相同版本的okhttp库，另一种则是屏蔽传递性依赖，从而达到解决冲突的效果。</p>
<h3 id="屏蔽传递性依赖"><a href="#屏蔽传递性依赖" class="headerlink" title="屏蔽传递性依赖"></a>屏蔽传递性依赖</h3><h4 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">'some-library'</span>) &#123;</span><br><span class="line">        exclude <span class="string">group:</span> <span class="string">'com.example.imgtools'</span>, <span class="string">module:</span> <span class="string">'native'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们在映入some-library的同时将<em>com.example.imgtools：native</em>这个库剔除掉了，这样进行引入，我们的module就不会传递性地引入<em>com.example.imgtools：native</em>这个库了，除了使用exclude来屏蔽传递性依赖，实际上我们还有一个更一了百了的方法，如下：</p>
<h4 id="transitive"><a href="#transitive" class="headerlink" title="transitive"></a>transitive</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">api (<span class="string">'com.facebook.fresco:fresco:0.13.0'</span>)&#123;</span><br><span class="line">        transitive = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样，通过<em>com.facebook.fresco:fresco</em>这个库传递的所有依赖都被我们屏蔽了</p>
<h4 id="force"><a href="#force" class="headerlink" title="force"></a>force</h4><p>通过force关键字可以强制指定某个模块的版本</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">   resolutionStrategy &#123;</span><br><span class="line">       force <span class="string">'org.hamcrest:hamcrest-core:1.3'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用configurations.all可以指定全局设置</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Proguard学习及App混淆</title>
    <url>/2019/07/21/Proguard%E5%AD%A6%E4%B9%A0%E5%8F%8AApp%E6%B7%B7%E6%B7%86/</url>
    <content><![CDATA[<h2 id="proguard-android-txt与proguard-android-optimize-txt"><a href="#proguard-android-txt与proguard-android-optimize-txt" class="headerlink" title="proguard-android.txt与proguard-android-optimize.txt"></a>proguard-android.txt与proguard-android-optimize.txt</h2><p>当我们打Release的时候，Google会默认对我们的release包进行优化，这个优化是通过在modeule中build.gradle中的minifyEnabled来开启的。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span>  <span class="comment">//开启代码混淆</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>),</span><br><span class="line">                    <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果我们将minifyEnabled置为false的话，那么在我们打release包的时候将不会对代码进行混淆，实际上这也是一种比较危险的做法，我们的代码经过反编译之后就会被别人清晰地看到。</p>
<p>我们还可以看到下面的这段代码</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>),</span><br><span class="line">                    <span class="string">'proguard-rules.pro'</span></span><br></pre></td></tr></table></figure>
<p>其中的<em>proguard-android.txt</em>是默认的配置文件，Google已经为我们做好的最基本的配置，同时，如果我们想要进一步的对混淆配置进行优化的话，可以使用另一个配置，<em>proguard-android-optimize.txt</em>。</p>
<p>proguard-android-optimize.txt可以说是proguard-android.txt中的扩展版，它不仅仅包含了proguard-android.txt中已有的部分，也多了其他的优化部分，它会对字节码也进行分析优化，进一步缩小APK的体积，提高应用运行速度。</p>
<p>在<strong>能编过</strong>的情况下，，这两个文件已经能够满足我们对混淆的要求，但是如果我们引入了其他的一些库，需要对混淆配置进行改动的话，则需要自定义<em>proguard-rules.pro</em>这个文件，实际上，我们也可以自已创建文件，并替换掉<em>proguard-rules.pro</em>，只要和<em>proguard-rules.pro</em>文件在一个目录下就行。</p>
<h2 id="proguard-rules-pro与Proguard规则"><a href="#proguard-rules-pro与Proguard规则" class="headerlink" title="proguard-rules.pro与Proguard规则"></a>proguard-rules.pro与Proguard规则</h2><p>引入proguard-rules.pro的原因主要是，google为我们配置了默认的混淆规则，但是在项目庞大，系统默认的规则还不够时，需要我们在给他增加一些规则，否则会产生错误，造成编译错误。</p>
<p>当因为混淆规则而发生错误时，我们可以通过gradle的输出文件来查看到底是哪里发生了错误。这个文件就是<module-name>/build/outputs/mapping/release/目录下的usage.txt文件，我们可以通过查看它来确定移除了哪些我们需要用到的代码。</module-name></p>
<p>造成我们所需要的代码被移除的原因主要是以下三点。</p>
<ol>
<li>当应用引用的类只来自 AndroidManifest.xml 文件时</li>
<li>当应用调用的方法来自 Java 原生接口 (JNI) 时</li>
<li>当应用在运行时（例如使用反射或自检）操作代码时</li>
</ol>
<p>保留代码的规则主要有以下几种：</p>
<ul>
<li>通过指定类的名称保留指定的类文件和类的成员</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keep &#123;Modiffier&#125; &#123;class_specification&#125;</span><br></pre></td></tr></table></figure>
<p>例子如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keep public class com.google.vending.licensing.ILicensingService</span><br></pre></td></tr></table></figure>
<ul>
<li>通过指定类的成员名称保留指定类的成员</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepclassmembers &#123;modifier&#125; &#123;class_specification&#125;</span><br></pre></td></tr></table></figure>
<p>例子如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepclassmembers public class * extends android.view.View &#123;</span><br><span class="line">   void set*(***);</span><br><span class="line">   *** get*();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过指定类成员名保留指定的类和类的成员</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepclasseswithmembers &#123;class_specification&#125;</span><br></pre></td></tr></table></figure>
<p>例子如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep &lt;methods&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过指定类保留指定的类的成员名称</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepnames &#123;class_specification&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过指定类成员保护指定的类的成员名称</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepclasseswithmembernames &#123;class_specification&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过指定类成员保护指定的类和类的成员名称（这里类成员条件必须完全满足）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepclasseswithmembernames &#123;class_specification&#125;</span><br></pre></td></tr></table></figure>
<p>看过这些规则可能就会晕了，因为记起来十分的繁琐，但实际上，google也为我们提供了另一个方法来保留代码，就是使用注释的方式，我们可以看到在<em>proguard-android.txt</em>和<em>proguard-android-optimize.txt</em>中都写有这样的规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keep class android.support.annotation.Keep</span><br><span class="line"></span><br><span class="line">-keep @android.support.annotation.Keep class * &#123;*;&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep &lt;init&gt;(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，遇到我们想保存的类或者类对象的时候，只添加注释即可。</p>
<p>但是，这样用我们需要用到注解支持库，需要在gradle里加上。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123; compile <span class="string">'com.android.support:support-annotations:24.2.0'</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="资源压缩"><a href="#资源压缩" class="headerlink" title="资源压缩"></a>资源压缩</h2><p>上面讲的都是代码的混淆，但实际上<em>如果已经实现了代码混淆</em>，我们也可以对资源进行压缩，只需要再加上一句shrinkResources true即可。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            shrinkResources <span class="literal">true</span></span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>),</span><br><span class="line">                    <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Java泛型总结</title>
    <url>/2019/07/14/Java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="从HashMap看泛型"><a href="#从HashMap看泛型" class="headerlink" title="从HashMap看泛型"></a>从HashMap看泛型</h2><p>泛型其实在我们编写代码的时候会经常用到，但是我们一般不会想到这原来就是在使用泛型，例如下面这个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>其实就就是很典型的一个泛型的使用，我们使用的Map接口如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Map&lt;K,V&gt; &#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而HashMap类是这样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>HaspMap继承了AbstractMap和Map，同时也让泛型的类型得以保留。泛型的具体写法见后续章节。</p>
<h2 id="泛型类和泛型接口的创建"><a href="#泛型类和泛型接口的创建" class="headerlink" title="泛型类和泛型接口的创建"></a>泛型类和泛型接口的创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Store&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Store() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public T buy() &#123;</span><br><span class="line">        return (T)(new Object());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public float re(T object) &#123;</span><br><span class="line">        return object.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，创建的Store类里面有两个方法，一个Buy方法可以返回泛型的类型，而re方法可以返回的是float类型，我们可以这样创建这个类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Store&lt;String&gt; store = new Store&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>可以看到，其实我们在Store的构造方法当中并没有指定<em>T</em>到底是哪个参数类型，但是在创建的时候，可以通过等号左边的变量来确定<em>T</em>到底是哪个参数。</p>
<p>泛型接口的写法可以参考下，其实和类的写法没有什么不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IStore&lt;T&gt; &#123;</span><br><span class="line">    public T bug();</span><br><span class="line">    float re(T object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以把两个结合一下，写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Store&lt;T&gt; implements IStore&lt;T&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public T bug() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public float re(T object) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，泛型不一定要用<em>T</em>声明，也可以用其他的字母进行声明，而且继承接口字母不一定要与接口中的写的一样，也能够进行泛型的继承。如下：</p>
<p>比如说像下面这样写也是可以的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Store&lt;E&gt; implements IStore&lt;E&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public E bug() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public float re(E object) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，E也可以是一个具体的类型，不一定非要继承泛型。</p>
</blockquote>
<p>上面阐述的是单泛型类的写法，如果遇到多泛型的，我们可以这样写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Store&lt;E, F&gt; implements IStore&lt;E&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public E bug() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public float re(E object) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public F buy2() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们的Store类就比IStore又多了一个泛型参数F。</p>
<h2 id="extends与super的用法"><a href="#extends与super的用法" class="headerlink" title="extends与super的用法"></a>extends与super的用法</h2><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>extends在类中声明，可以对泛型参数进行约束，表述此泛型必须为extends后类型的子类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Store&lt;E, F extends String&gt; implements IStore&lt;E&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public E bug() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public float re(E object) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Store&lt;Integer, String&gt; store = new Store&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>在此处代码左边我们可以看到，我声明的数据类型是String，满足了条件，但是如果我们用其他不是String子类的类型的话，编译器就会报错。</p>
<p>同时，extends也可以用在方法参数中。例如;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public float said(List&lt;? extends String&gt; list) &#123;</span><br><span class="line">        float num = 0;</span><br><span class="line">        for (String s : list) &#123;</span><br><span class="line">            num += s.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是尤其需要注意的是，extends不能在初始化泛型的时候使用，像这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;? extends String&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>如果像这样使用，会发现add方法根本无法使用，因为编译器不能确定到底是哪个类型，所以这个方法就被<strong>废掉了</strong>。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super关键字与extends关键字很像，也是代表了一种约束。但是与extends关键字不同的是，它只能与 <em>?</em> 关键字一起使用，而且不能在类的声明中使用。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public  &lt;T&gt;  T get(T e) &#123;</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，前面必须用一个前括号对泛型进行声明。</p>
<p>两个参数的写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public  &lt;K, V&gt;  float get(K key, V value) &#123;</span><br><span class="line">        return key.hashCode() * value.hashCode();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在Android中最经典的使用泛型方法的例子就是我们最常用的findViewById了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;T extends View&gt; T findViewById(@IdRes int id) &#123;  return getWindow().findViewById(id); &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>泛型其实最主要的用处是方便使用者，如果我们是一般的业务开发的话，需要我们自己写泛型的情况是很少的，但是如果我们是要写一个类的话，泛型就能帮上很大的忙。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>ConstraintLayout用法</title>
    <url>/2019/07/07/ConstraintLayout%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ConstraintLayout是Google用于减少布局嵌套而推出的一个布局，能够在效果达到LinearLayout、ReactiveLayout和FrameLayout的情况下减少布局的嵌套，它通过四条边的约束来达到确定位置的目的。一般我们会使用的属性如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app:layout_constraintXXX_toXXXOf=&quot;&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>XXX可指代Top、Bottom、Start和End四个方向，其中Start和End其实对我们来说就是左右，但是Google为了适配其他国家的语言（他们的文字可能是从右往左的），而使用了Start和End而不是Left和Right。</p>
</blockquote>
<p> 当我们需要一个View在父容器中间时可以这样设置。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app:layout_constraintStart_toStartOf=&quot;parent&quot; </span><br><span class="line"> app:layout_constraintEnd_toEndOf=&quot;parent&quot; </span><br><span class="line"> app:layout_constraintTop_toTopOf=&quot;parent&quot; </span><br><span class="line"> app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br></pre></td></tr></table></figure>
<p> 可以使用parent来简单地指代父容器，而不需要父容器一定要有具体的id。</p>
<p> 同时，也可以通过设置来达到View垂直或水平居中于某一个View的边的效果。</p>
<p> 例如，这里有一个比较特殊的用法，可以让View垂直于某一个View下边。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app:layout_constraintTop_toBottomOf=&quot;@id/test&quot;</span><br><span class="line">app:layout_constraintBottom_toBottomOf=&quot;@id/test&quot;</span><br></pre></td></tr></table></figure>
<p> 可以看到，这里View的上下便都被id为test的View的下边约束住了，我们可以把这种约束想象成两条弹力系数一样的橡皮筋，这样，view就只能垂直于id为test的下边了。</p>
<p> ConstrainLayout有点比较特殊，如果它的宽度或者高度设置成了0dp之后，那么它的边就会向被约束的边对齐，如果我们想要一个View充满整个容器可以这样做。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">       app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">       app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">       app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">       app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">       android:layout_width=&quot;0dp&quot;</span><br><span class="line">       android:layout_height=&quot;0dp&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><p> 权重我们经常能够在LinearView中看到，其实ConstrainLayout中也存在，但是需要我们先对需要设置权重的View相互之间建立约束关系。即首尾相连，最前于最后两个View于父容器建立约束，具体代码如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">      android:id=&quot;@+id/view1&quot;</span><br><span class="line">      app:layout_constraintHorizontal_weight=&quot;2&quot;</span><br><span class="line">      app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">      app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">      app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">      app:layout_constraintEnd_toStartOf=&quot;@id/view2&quot;</span><br><span class="line">      android:background=&quot;@color/colorAccent&quot;</span><br><span class="line">      android:layout_width=&quot;0dp&quot;</span><br><span class="line">      android:layout_height=&quot;200dp&quot;/&gt;</span><br><span class="line">   &lt;View</span><br><span class="line">       android:id=&quot;@+id/view2&quot;</span><br><span class="line">       app:layout_constraintHorizontal_weight=&quot;1&quot;</span><br><span class="line">       app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">       app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">       app:layout_constraintStart_toEndOf=&quot;@id/view1&quot;</span><br><span class="line">       app:layout_constraintEnd_toStartOf=&quot;@id/view3&quot;</span><br><span class="line">       android:background=&quot;@color/colorPrimary&quot;</span><br><span class="line">       android:layout_width=&quot;0dp&quot;</span><br><span class="line">       android:layout_height=&quot;200dp&quot;/&gt;</span><br><span class="line">   &lt;View</span><br><span class="line">       android:id=&quot;@+id/view3&quot;</span><br><span class="line">       app:layout_constraintHorizontal_weight=&quot;3&quot;</span><br><span class="line">       app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">       app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">       app:layout_constraintStart_toEndOf=&quot;@id/view2&quot;</span><br><span class="line">       app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">       android:layout_width=&quot;0dp&quot;</span><br><span class="line">       android:background=&quot;@color/colorPrimaryDark&quot;</span><br><span class="line">       android:layout_height=&quot;200dp&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p> 效果图如下</p>
<p> <img src="https://i.loli.net/2019/07/07/5d21e6cba06f969786.png" alt="约束布局.png"></p>
<h3 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h3><p> 通过圆心、半径、角度等对View进行约束，这几个属性具体如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app:layout_constraintCircle=&quot;@id/view&quot; </span><br><span class="line">app:layout_constraintCircleAngle=&quot;90&quot; </span><br><span class="line">app:layout_constraintCircleRadius=&quot;180dp&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段xml很好理解，圆心为id为view的View，半径为180dp，角度为90度</p>
</blockquote>
<h3 id="避免越界"><a href="#避免越界" class="headerlink" title="避免越界"></a>避免越界</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app:layout_constrainedWidth=&quot;true&quot;</span><br><span class="line">app:layout_constrainedHeight=&quot;true&quot;</span><br></pre></td></tr></table></figure>
<p> 这两个属性可以保证View的宽高不会超过约束的属性。</p>
<h3 id="百分比定位"><a href="#百分比定位" class="headerlink" title="百分比定位"></a>百分比定位</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app:layout_constraintVertical_bias=&quot;0.3&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里的百分比是指的被约束空间的百分比，而不是父容器的百分比，这需要与下面的app:layout_constraintWidth_percent区分开来</p>
</blockquote>
<p> 这个属性就是指定位在垂直防线30%处</p>
<h3 id="约束链"><a href="#约束链" class="headerlink" title="约束链"></a>约束链</h3><p> 通过这个属性可以实现两个组件打包对其、分开对其。默认为均匀扩散。</p>
<ul>
<li>packed（打包）</li>
<li>spread（扩散）</li>
<li><p>spread_inside（内部扩散）</p>
<p>如下代码可以实现两个组件打包，可以实现两个组件一起居中等效果，这里需要注意，两个组件需要首尾相连，可参考<em>权重</em>所示代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app:layout_constraintVertical_chainStyle=&quot;packed&quot;</span><br></pre></td></tr></table></figure>
<h3 id="宽高比"><a href="#宽高比" class="headerlink" title="宽高比"></a>宽高比</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app:layout_constraintDimensionRatio=&quot;2:1&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> 这里表示宽高比为2：1，需要注意，使用这个属性的话需要宽或高中的一个属性是确定的。</p>
<h3 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h3><p> 这里指的是View相对于父容器的大小</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app:layout_constraintWidth_percent=&quot;0.3&quot;</span><br></pre></td></tr></table></figure>
<h2 id="辅助组件"><a href="#辅助组件" class="headerlink" title="辅助组件"></a>辅助组件</h2><h3 id="GuideLine"><a href="#GuideLine" class="headerlink" title="GuideLine"></a>GuideLine</h3><p> 方向设置</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:orientation=&quot;vertical&quot;</span><br></pre></td></tr></table></figure>
<p> 关于辅助线的具体防线，这里有三个属性可以帮助设置</p>
<ul>
<li>距离起始方向的距离 layout_constraintGuide_begin </li>
<li>距离结束方向的距离 layout_constraintGuide_end </li>
<li><p>百分比  layout_constraintGuide_percent</p>
<h3 id="Group与Layer"><a href="#Group与Layer" class="headerlink" title="Group与Layer"></a>Group与Layer</h3><p>都可以通过 constraint_referenced_ids来引用其他View，Group可以一起给他们设置可见度，而Layer可以一起给他们设置位移和旋转等。</p>
<h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><p>与BaseLine类似的是，都可以设置隐形的约束，但是Barrier可以通过某个View的位置动态调整。</p>
<h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><p>可以通过设置wrapMode属性来控制View的排列方式，有chain、aligne和none三个属性值，none是默认值。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>RecyclerView深入学习</title>
    <url>/2019/06/30/RecyclerView%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>RecyclerView是Google用来替换ListView的组件，实际上它很早就被推出了，但是在旧项目中，我们还是能够经常看到ListView的身影，RecyclerView相比较与ListView，增加了默认的ViewHolder，能够减少findViewById调用的次数，而且有四级缓存，相比较于ListView的两层缓存，做了比较大的改进。</p>
</blockquote>
<h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>在开始编写RecyclerView之前，我们需要在项目中的gradle中应用RecyclerView</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &apos;androidx.recyclerview:recyclerview:1.0.0&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>AndroidX是google将很多组件抽离出来组成的一个库，当然很多地方都用的是另一种写法，通过Support库来引入RecyclerView</p>
</blockquote>
<p>RecyclerViewAdapter的写法很多人都需要通过查阅文档才能够记起来，实际上它的写法大概分为两个部分。一部分是Adapter，另一部分是ViewHolder。这两部分如下：</p>
<p>最开始我们先写Adapter的部分</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; list = null;</span><br><span class="line">    private Context context = null;</span><br><span class="line"></span><br><span class="line">    public RecyclerViewAdapter(List&lt;String&gt; stringList, Context context) &#123;</span><br><span class="line">        this.list = stringList;</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;</span><br><span class="line">        View view = LayoutInflater.from(context).inflate(R.layout.layout_recyclerview_item, parent, false);</span><br><span class="line">        return new RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String toString() &#123;</span><br><span class="line">                return super.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getItemCount() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到我们使用了默认的ViewHolder，此时我们并没有进行自定义，ViewHolder可以在指定为默认的RecyclerView.ViewHolder，但是必须实现它的抽象方法，而且在绑定的时候如果我们没有进行自定义，绑定也十分不方面，所以我们一般自定义ViewHolder，如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.ItemViewHolder&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; list = null;</span><br><span class="line">    private Context context = null;</span><br><span class="line"></span><br><span class="line">    public RecyclerViewAdapter(List&lt;String&gt; stringList, Context context) &#123;</span><br><span class="line">        this.list = stringList;</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public RecyclerViewAdapter.ItemViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;</span><br><span class="line">        View view = LayoutInflater.from(context).inflate(R.layout.layout_recyclerview_item, parent, false);</span><br><span class="line">        return new ItemViewHolder(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onBindViewHolder(@NonNull RecyclerViewAdapter.ItemViewHolder holder, int position) &#123;</span><br><span class="line">        String s = list.get(position);</span><br><span class="line">        holder.tvItem.setText(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getItemCount() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class ItemViewHolder extends RecyclerView.ViewHolder &#123;</span><br><span class="line">        </span><br><span class="line">        private ImageView ivItem;</span><br><span class="line">        private TextView tvItem;</span><br><span class="line">        </span><br><span class="line">         ItemViewHolder(@NonNull View itemView) &#123;</span><br><span class="line">            super(itemView);</span><br><span class="line">            ivItem = itemView.findViewById(R.id.iv_item);</span><br><span class="line">            tvItem = itemView.findViewById(R.id.tv_item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在自定义ViewHolder之后，我们需要把之前的RecyclerView.ViewHolder改为我们自己的ViewHolder，包括两个方法onCreateViewHolder和onBindViewHolder。</p>
<h2 id="RecyclerView的四级缓存"><a href="#RecyclerView的四级缓存" class="headerlink" title="RecyclerView的四级缓存"></a>RecyclerView的四级缓存</h2><p>先上图，四级缓存的过程如下</p>
<p><img src="https://i.loli.net/2019/06/30/5d18649e657bb96136.png" alt="四层缓存.png"></p>
<p>其中mAttachedScrap是指在屏幕外，但是未与列表进行分离的item，如果我们可以找到我们想要现实的item，就直接返回，如果没有找到，我们则继续向下一级寻找item，依次为mCachedViews和mViewCacheExtension，最后是mRecyclerPool，如果到最后都没有找到的话，则调用onCreateViewHolder创建ViewHolder，我们这里需要记住的是，如果在mRecyclerPool缓存前就找到了我们所需的ViewHolder的话，就不需要再调用onBindViewHolder对ViewHolder进行绑定了，可以这么理解，mAttachedScrap、mCachedViews和mViewCacheExtension是根据item的位置（position）来进行缓存的，而mRecyclerPool仅仅对ViewType进行了记忆，需要重新进行绑定才可。</p>
<h2 id="RecyclerView性能优化"><a href="#RecyclerView性能优化" class="headerlink" title="RecyclerView性能优化"></a>RecyclerView性能优化</h2><h3 id="设置OnClickListener"><a href="#设置OnClickListener" class="headerlink" title="设置OnClickListener"></a>设置OnClickListener</h3><p>我们一般习惯在OnBindViewHolder的时候进行OnClickListener的绑定，但是根据四级缓存，如果最后是在mRecyclerPool里面找到的ViewHolder，那么OnBindViewHolder将会重新创建，所以我们需要尽可能的在onCreateViewHolder的时候就将OnClickListener进行绑定。</p>
<h3 id="LinearLayoutManager。setInitialPrefetchItemCount-int-itemCount"><a href="#LinearLayoutManager。setInitialPrefetchItemCount-int-itemCount" class="headerlink" title="LinearLayoutManager。setInitialPrefetchItemCount(int itemCount)"></a>LinearLayoutManager。setInitialPrefetchItemCount(int itemCount)</h3><p>在多个RecyclerView进行嵌套时，例如竖向滑动的RecyclerView中嵌套了几个横向滑动的RecyclerView，那么这个方法将会减少页面的卡顿，可以通过这个方法来设置横向列表初次可见的item个数</p>
<h3 id="RecyclerView-setHasFixedSize"><a href="#RecyclerView-setHasFixedSize" class="headerlink" title="RecyclerView.setHasFixedSize"></a>RecyclerView.setHasFixedSize</h3><p>这个方法可以在列表内容进行变化时对性能进行优化，如果列表中Item个数是一定的话，那么我们就可以通过这个函数将mHasFixedSize设置为true，它可以减少RequestLayout的调用。</p>
<h3 id="共用mRecyclerPool"><a href="#共用mRecyclerPool" class="headerlink" title="共用mRecyclerPool"></a>共用mRecyclerPool</h3><p>当多个RecyclerView一起出现在同一个页面时，可以通过setRecycledViewPool来使用同一个mRecyclerPool进行缓存</p>
<h3 id="DiffUtil"><a href="#DiffUtil" class="headerlink" title="DiffUtil"></a>DiffUtil</h3><p>DiffUtil能很方便的对两个数据集之间进行比对，然后计算出变动情况，配合RecyclerView.Adapter ，可以自动根据变动情况，调用 adapter 的对应方法。</p>
<p>使用代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new DiffCallBack(oldDatas, newDatas), true);</span><br><span class="line">diffResult.dispatchUpdatesTo(mAdapter);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android电视焦点问题总结及按钮事件分发</title>
    <url>/2019/04/16/Android%E7%94%B5%E8%A7%86%E7%84%A6%E7%82%B9%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="焦点的获取"><a href="#焦点的获取" class="headerlink" title="焦点的获取"></a>焦点的获取</h1><p>在Android的电视上，操作与手机很不相同，手机上我们可以用手指来选择自己想要点击的控件，但是在Android电视上，我们只能通过焦点来选择自己想要选择的控件，而且必须做一些工作来让选择变得更加明显。</p>
<p>控件如果想要获得焦点，则要在xml文件中加上这句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:focusable=&quot;true&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，一些控件，例如imageView必须设置这个属性，因为默认的属性为false</p>
</blockquote>
<p>电视上最让人抓狂的就是控件抢焦点的问题，如果不想让控件获得焦点，一定得在该控件的属性里加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:focusable=&quot;false&quot;</span><br></pre></td></tr></table></figure>
<h2 id="RecyclerView中子控件获取不到焦点的问题"><a href="#RecyclerView中子控件获取不到焦点的问题" class="headerlink" title="RecyclerView中子控件获取不到焦点的问题"></a>RecyclerView中子控件获取不到焦点的问题</h2><p>在RecyclerView中，如果不进行设置，焦点可能永远都会被RecyclerView抢占，解决方法只需要在控件中加入这句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:descendantFocusability=&quot;afterDescendants&quot;</span><br></pre></td></tr></table></figure>
<p>这个属性值总共有三种，分别是</p>
<ul>
<li>beforeDescendants：viewgroup会优先其子类控件而获取到焦点</li>
<li>afterDescendants：viewgroup只有当其子类控件不需要获取焦点时才获取焦点</li>
<li>blocksDescendants：viewgroup会覆盖子类控件而直接获得焦点</li>
</ul>
<p>可根据需要自己设置，例如在最顶层的控件中用使用blocksDescendants，那么所有只有顶层布局才能获得焦点。</p>
<h1 id="按钮事件分发"><a href="#按钮事件分发" class="headerlink" title="按钮事件分发"></a>按钮事件分发</h1><p>当控件获得焦点时，我们可以通过重写onKeyDown方法来对事件进行处理，这个处理与onTouchEvent类似。但与手机上事件分发不同的是，电视上ViewGroup没有拦截事件的函数，因为电视上的操作没有像手机上那么复杂，需要处理滑动等等。</p>
<p>当该控件处理完事件时，返回true，代表该事件被消费掉了，返回false则将这个事件交给其他的控件处理。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Java Socket(UDP)</title>
    <url>/2018/11/30/Java-Socket-UDP/</url>
    <content><![CDATA[<p>UDP是在IP之上发送数据的另一种传输层协议，速度很快，但不可靠。当发送UDP数据时，无法知道数据是否会到达，也不知道数据的各个部分是否会以发送时的顺序到达。不过，确实能到达的部分一般都会很快到达。</p>
<p>Java中UDP的实现分为两个类：DatagramPacket和DatagramSocket。DatagramPacket类将数据填充到UDP包中，这称为数据报。为发送数据，将要数据报放到DatagramPacket中，使用DatagramSocket来发哦是那个这个包。要接收数据，可以从DatagramSocket中接收一个DatagramPacket对象，然后检查该包的内容。</p>
<h5 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a>DatagramPacket类</h5><p>在Java中，UDP数据报用DatagramPacket类的实例表示，这个类提供了一些方法来获取和设置IP首部中的源或目标地址、获取和设置源或目标端口、获取和设置数据，以及获取和设置数据长度。其余首部字段无法通过纯Java代码访问。</p>
<h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><p>取决于数据报用于发送数据还是接收数据，DatagramPacket会使用不同的构造函数。希望接收数据报时，只需要提供保存数据报数据的byte数据和该数据用于数据报数据的字节数这两个参数。当socket从网络接收数据时，它将数据报的数据存储在DatagramPacket对象的缓冲区数据中，直到达到你指定的长度。希望发送数据报时，这些构造函数需要一个缓冲区和一个长度，另外还需要指定数据报发往的地址和端口。</p>
<p>DatagramSocket从DatagramPacket中读取目标地址和端口，地址和端口不存储在Socket中。</p>
<p>接收数据报的构造函数：</p>
<ul>
<li>public DatagramPacket(byte buf[], int length)</li>
<li>public DatagramPacket(byte buf[], int offset, int length)</li>
</ul>
<p>发送数据报的构造函数：</p>
<ul>
<li>public DatagramPacket(byte buf[], int offset, int length,InetAddress address, int port)</li>
<li>public DatagramPacket(byte buf[], int offset, int length, SocketAddress address)</li>
<li>public DatagramPacket(byte buf[], int length,InetAddress address, int port)</li>
<li>public DatagramPacket(byte buf[], int length, SocketAddress address)</li>
</ul>
<p>其中InetAddress或SocketAddress对象的destination指向包发往的目标主机，int参数port是该主机上的端口。</p>
<blockquote>
<p>在一个包中填充多少数据才合适，这取决于实际情况。有些协议规定了包大小。要选择最佳的包大小，涉及很多因素。如果网络非常不可靠，如分组无线电网络，则要选择较小的包，因为这样可以减少在传输中被破坏的可能。另一方面，非常快速而可靠的LAN应当使用尽可能大的包。对于很多类型的网络，<em>8KB字节（即8192字节）</em> 往往是一个很好的折中方案。</p>
</blockquote>
<h5 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a>DatagramSocket类</h5><p>所有数据报Socket都绑定到一个本地端口，在这个端口上监听入站数据，这个端口也会放置在数据报的首部中。如果要编写一个客户端，不需要关心本地端口，可以调用一个构造函数，让系统来分配一个未使用的端口。这个端口号放置在所有出站数据报中，服务器将用它来确定响应数据报的发送地址。因此，当服务器构造DatagramSocket时，要指定它监听的本地端口。不过，客户端和服务器使用的Socket是一样的：区别只在于使用匿名端口还是已知端口。客户端Socket和服务器Socket没有区别。</p>
<h6 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h6><ul>
<li>public DatagramSocket() throws SocketException</li>
</ul>
<p>这个构造函数创建一个绑定到匿名端口的Socket。 <em>在发起与服务器对话的客户端中可能要使用这个构造函数。</em></p>
<ul>
<li>public DatagramSocket(int port) throws SocketException</li>
</ul>
<p>这个构造函数创建一个在指定端口监听入站数据报的Socket。 <em>可以使用这个构造函数编写在已知端口监听的服务器。</em></p>
<ul>
<li>public DatagramSocket(int port, InetAddress laddr) throws SocketException</li>
</ul>
<p>这个构造函数主要用于多宿主主机，它会创建在指定端口和网络接口监听入站数据报的Socket</p>
<ul>
<li>public DatagramSocket(SocketAddress bindaddr) throws SocketException</li>
</ul>
<p>与前一个相似，只是网络接口和端口由SocketAddress读取</p>
<ul>
<li>protected DatagramSocket(DatagramSocketImpl impl)</li>
</ul>
<p>这个构造函数允许子类提供自己的UDP实现，而不是接收默认实现。与其他4个构造函数创建的Socket不同，这个Socket一开始没有与端口绑定。使用前必须通过bind（）方法绑定到一个SocketAddress</p>
<h6 id="发送和接收数据报"><a href="#发送和接收数据报" class="headerlink" title="发送和接收数据报"></a>发送和接收数据报</h6><p>DatagramSocket类的首要任务是发送和接收UDP数据报。一个Socket既可以发送又接收数据报。</p>
<p>发送数据报：</p>
<p>public void send(DatagramPacket p) throws IOException</p>
<p>接收数据报：</p>
<p>public synchronized void receive(DatagramPacket p) throws IOException</p>
<blockquote>
<p>这个方法会阻塞调用线程，直到数据报到达</p>
</blockquote>
<h6 id="Socket选项"><a href="#Socket选项" class="headerlink" title="Socket选项"></a>Socket选项</h6><p>Java支持6个UDP Socket选项：</p>
<ul>
<li>SO_TIMEOUT</li>
</ul>
<p>SO_TIMEOUT是receive()在抛出异常前等待入站数据报的时间，以毫秒计</p>
<ul>
<li>SO_RECBUF</li>
</ul>
<p>确定了用于网络I/O的缓冲区大小</p>
<ul>
<li>SO_SNDBUF</li>
</ul>
<p>获取和设置建议用于网络输出的发送缓冲区大小</p>
<ul>
<li>SO_REUSEDADDR</li>
</ul>
<p>可以控制是否允许多个数据报Socket同时绑定到相同的端口和地址</p>
<ul>
<li>SO_BROADCAST</li>
</ul>
<p>控制是否允许一个Socket向广播地址收发包</p>
<ul>
<li>IP_POS</li>
</ul>
<p>业务流类型</p>
<h5 id="组播Socket类-MulticastSocket"><a href="#组播Socket类-MulticastSocket" class="headerlink" title="组播Socket类(MulticastSocket)"></a>组播Socket类(MulticastSocket)</h5><p>在Java中，要使用java.net.MulticastSocket类来组播数据，这是java.net.DatagramSocket的一个子类。</p>
<p>MulticastSocket与DatagramSocket十分相似:将数据放在DatagramPacket中，然后通过MulticastSocket收发。</p>
<p>MulticastSocket可以完成以下4种关键操作：</p>
<ol>
<li>加入组播组</li>
<li>向组中成员发送数据</li>
<li>接收组中的数据</li>
<li>离开组播组</li>
</ol>
]]></content>
      <categories>
        <category>Android网络开发</category>
      </categories>
  </entry>
  <entry>
    <title>Java Socket(TCP)</title>
    <url>/2018/11/28/%E5%AE%A2%E6%88%B7%E7%AB%AFSocket/</url>
    <content><![CDATA[<p>在Internet上，数据按有限大小的包传输，这些包称为数据报(datagram)。每个数据报包含一个首部（header)和一个有效载荷（payload）。首部包含包发送到的地址和端口、包来自的地址和端口、检测数据是否被破坏的校验和，以及用于保证可靠传输的各种其他管理信息。有效荷载包含数据本身。不过，由于数据报长度有限，通常必须将数据分解为多个包，再在目的地重新组合。也有可能一个包或多个包在传输中丢失或遭到破坏，需要重传。或者包乱序到达，需要重新排序。所有这些是很繁重的工作，需要大量复杂的代码。</p>
<p>Socket允许程序员将网络连接看作是另外一个可以读/写的字节流。Socket对程序员掩盖了网络的底层细节，如错误检测、包大小、包分解、包重传、网络地址等。</p>
<h4 id="使用Socket"><a href="#使用Socket" class="headerlink" title="使用Socket"></a>使用Socket</h4><p>Socket是两台主机之间的一个连接。它可以完成7个基本操作：</p>
<ul>
<li>连接远程机器</li>
<li>发送数据</li>
<li>接收数据</li>
<li><p>关闭连接</p>
<blockquote>
<p>客户端Socket</p>
</blockquote>
</li>
<li><p>绑定端口</p>
</li>
<li>监听入站数据</li>
<li>在绑定端口上接受来自远程机器的连接<blockquote>
<p>服务端ServerSocket</p>
</blockquote>
</li>
</ul>
<p>Java程序通常采用以下方式使用客户端Socket：</p>
<ol>
<li><p>程序用构造函数创建一个新的Socket</p>
</li>
<li><p>Socket尝试连接远程主机</p>
</li>
</ol>
<p>一旦建立了连接，本地和远程主机就从这个Socket得到输入流和输出流，使用这两个流相互发送数据。连接是全双工的，两台主机都可以同时发送和接收数据。数据的含义取决于协议，发送给FTP服务器的命令与发送给HTTP服务器的命令就有所不同。一般会先完成某种协商握手，然后再具体传输数据。</p>
<p>当数据传输结束后，一端或两端将关闭连接。有些协议，如HTTP 1.0，要求每次请求得到服务后都要关闭连接。其他协议，如FTP和HTTP 1.1，则允许在一个连接上处理多个请求。</p>
<h5 id="构造和连接Socket"><a href="#构造和连接Socket" class="headerlink" title="构造和连接Socket"></a>构造和连接Socket</h5><p>java.net.Socket类是Java完成客户端TCP操作的基础类。其他建立TCP网络连接的面向客户端的类（如URL、URLConnection、Applet和JEditorPane）最终都会调用这个类的方法。这个类本身使用原生代码与主机操作系统的本地TCP栈进行通信。</p>
<p>Socket的构造函数如下：</p>
<ul>
<li>public Socket()：无参构造函数，支持不同类型的socket</li>
<li>public Socket(Proxy proxy)：可以使用某个特定的代理服务器</li>
<li>public Socket(String host, int port) throws UnknownHostException, IOException</li>
<li>public Socket(InetAddress address, int port) throws IOException</li>
<li>public Socket(String host, int port, InetAddress localAddr, int localPort) throws IOException</li>
<li>public Socket(InetAddress address, int port, InetAddress localAddr, int localPort) throws IOException</li>
</ul>
<p>已不建议使用：</p>
<ul>
<li>public Socket(String host, int port, boolean stream) throws IOException</li>
<li>public Socket(InetAddress host, int port, boolean stream) throws IOException</li>
</ul>
<h5 id="设置Socket选项"><a href="#设置Socket选项" class="headerlink" title="设置Socket选项"></a>设置Socket选项</h5><p>Socket选项指定了Java Socket类所依赖的原生socket如何发送和接收数据。对于客户端Socket，Java支持9个选项：</p>
<ol>
<li>TCP_NODELAY</li>
</ol>
<p>设置TCP_NODELAY为true可确保包会尽可能快地发送，而无论包的大小。正常情况下，本地主机会有一个缓冲，而设置TCP_NODELAY为true可以打破这种缓冲模式，这样所有包一旦就绪就会发送</p>
<ol>
<li>SO_LINGER</li>
</ol>
<p>SO_LINGER选项指定了Socket关闭时如何处理尚未发送的数据报，将这个选项打开而且延迟时间设置为任意正数，close（）方法会阻塞，等待发送数据和接收确认。当过去相应秒数后，Socket关闭，所有剩余的数据都不会发送，也不会收到确认。</p>
<ol>
<li>SO_TIMEOUT</li>
</ol>
<p>正常情况下，尝试从Socket读取数据时，read（）调用会阻塞尽可能长的时间来得到足够的字节。设置SO_TIMEOUT可以确保这个调用阻塞的时间不会超过某个固定的毫秒数。</p>
<ol>
<li>SO_REVBUF和SO_SNDBUF</li>
</ol>
<p>SO_REVBUF选项用于控制用于网络输入的 <em>建议的</em> 接收缓冲区大小。SO_SNDBUF选项控制用于网络输入的 <em>建议的</em> 发送缓冲区的大小。</p>
<p>尽管看起来应该能独立地设置发送和接收缓冲区，但实际上缓冲区通常会设置为二者中较小的一个。例如，如果将发送缓冲区设置为64KB，而接收缓冲区设置为128KB，那么发送和接收缓冲区的大小都将是64KB。Java会报告接收缓冲区为128KB，但底层TCP栈实际上会使用64KB。</p>
<blockquote>
<p>TCP的滑动窗口大小实际上就是socket的接收缓冲区（SO_RCVBUF）大小的字节数，拥塞窗口大小实际上就是socket的接收缓冲区（SO_SNDBUF）大小的字节数。</p>
</blockquote>
<ol>
<li>SO_KEEPALIVE</li>
</ol>
<p>如果打开了SO_KEEPALIVE，客户端偶尔会通过一个空闲连接发送一个数据包，以确保服务器未崩溃。如果服务器没能响应这个包，客户端会持续尝试11分钟多的时间，直到接收到响应为止。如果在12分钟内未收到响应，客户端就关闭socket。</p>
<ol>
<li>OOBINLNE</li>
</ol>
<p>使用这个选项可以发送紧急数据。</p>
<ol>
<li>SO_REUSEADDR</li>
</ol>
<p>开启这个选项可以允许另一个SOcket绑定到这个之前Socket绑定的端口，即使此时仍有可能存在前一个SOcket未接收的数据。</p>
<ol>
<li>IP_TOS</li>
</ol>
<p>服务类型</p>
<h4 id="使用ServerSocket"><a href="#使用ServerSocket" class="headerlink" title="使用ServerSocket"></a>使用ServerSocket</h4><p>ServerSocket类包含了使用Java编写服务器所需的全部内容。其中包括创建新ServerSocket对象的构造函数、在指定端口监听连接的方法、配置各个服务器Socket选项的方法，以及其他一些常见的方法。</p>
<p>在Java中，服务器程序的基本生命周期如下：</p>
<ol>
<li>使用一个ServerSocket构造函数在一个特定端口创建一个新的ServerSocket</li>
<li>ServerSocket使用其accept（）方法监听这个端口的入站连接。accept（）会一直阻塞，直到一个客户端尝试建立连接，此时accept（）将返回一个连接客户端和服务器的Socket对象。</li>
<li>根据服务器的类型，会调用Socket的getInputStream（）方法或getOutputSteam（）方法，或者这两个方法都调用，以获得与客户端通信的输入和输出流</li>
<li>服务器和客户端根据已协商的协议交互，直到要关闭连接</li>
<li>服务器或客户端（或二者）关闭连接</li>
<li>服务器返回步骤2，等待下一次连接</li>
</ol>
<h5 id="构造ServerSocket"><a href="#构造ServerSocket" class="headerlink" title="构造ServerSocket"></a>构造ServerSocket</h5><p>ServerSocket共有构造函数如下：</p>
<ul>
<li>public ServerSocket() throws IOException: 无参构造函数，会创建一个ServerSocket对象，但未将它绑定到某个端口，所以开始时它不能接收任何连接。以后可以使用bind（）来进行绑定。允许程序在绑定端口之前设置服务器socket选项。有些选项在服务器socket绑定后必须固定</li>
<li>public ServerSocket(int port) throws IOException</li>
<li>public ServerSocket(int port, int backlog) throws IOException</li>
<li>public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException</li>
</ul>
<h5 id="ServerSocket选项"><a href="#ServerSocket选项" class="headerlink" title="ServerSocket选项"></a>ServerSocket选项</h5><p>Socket选项指定了ServerSocket类所依赖的原生Socket如何发送和接收数据。对于服务器Socket，Java支持以下3个选项：</p>
<ol>
<li>SO_TIMEOUT</li>
</ol>
<p>SO_TIMEOUT是accept（）在抛出java.io.InterruptedIOExption异常前等待入站连接的时间，以毫秒计。如果SO_TIMEOUT为0，accept（）就永远不会超时。</p>
<ol>
<li>SO_REUSEADDR</li>
</ol>
<p>服务器Socket的SO_REUSEADDR选项与客户端Socket的SO_REUSEDADDR选项非常类似。它确定了是否允许一个Socket绑定到之前使用过的一个端口，而此时可能还有一些发送到原Socket的数据正在网络上传输。</p>
<ol>
<li>SO_REVBUF</li>
</ol>
<p>SO_REVBUF选项设置了服务器Socket接收的客户端Socket默认接收缓冲区大小。设置一个服务器的SO_REVBUF就像在accept（）返回的各个Socket上调用setReceivedBufferSize()，这个选项给出了一个 <em>建议值</em> 。</p>
<h6 id="服务类型"><a href="#服务类型" class="headerlink" title="服务类型"></a>服务类型</h6><p>public void setPerformancePreferences(int connectionTime,int latency,int bandwidth)方法描述了其连接时间，延迟和带宽所给定的相对优先级。但很多实现（包括Android）会完全忽略这些值。</p>
<h4 id="安全Socket"><a href="#安全Socket" class="headerlink" title="安全Socket"></a>安全Socket</h4><p>作为一个Internet用户，你确实有一些保护手段可以防范官方的监视。为了使Internet连接从根本上更加安全，可以对Socket加密。这可以保持事务的机密性、真实性和准确性。</p>
<p>JSSE允许你创建Socket和服务器Socket，可以透明地处理安全通信中心必要的协商和加密。Java安全Socket扩展（JSSE）分为四个包：</p>
<ul>
<li>javax.net.ssl：定义Java安全网络通信API的抽象类</li>
<li>javax.net: 替代构造函数创建安全Socket的抽象Socket工厂类</li>
<li>java.security.cert: 处理SSL所需公开密钥证书的类</li>
<li>com.sun.net.ssl: Sun的JSSE参考实现中实现加密算法和协议的具体类。从理论上讲，它们不属于JSSE标准的一部分。</li>
</ul>
<h5 id="创建安全客户端Socket"><a href="#创建安全客户端Socket" class="headerlink" title="创建安全客户端Socket"></a>创建安全客户端Socket</h5><p>创建安全客户端Socket并不是用构造函数来构造一个java.net.Socket对象，而是从javax.net.ssl.SSLSocketFactory使用其createSocket()方法得到一个Socket对象。SSLSocketFactory是一个遵循抽象工厂设计模式的抽象类。要通过调用静态SSLSocketFactory.getDefault()方法得到一个实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SocketFactory sslSocketFactory = SSLSocketFactory.getDefault();</span><br><span class="line">Socket socket = sslSocketFactory.createSocket();</span><br></pre></td></tr></table></figure>
<p>创建安全客户端Socket还有以下方法：</p>
<ul>
<li>public abstract Socket createSocket(String var1, int var2) throws IOException, UnknownHostException</li>
<li>public abstract Socket createSocket(String var1, int var2, InetAddress var3, int var4) throws IOException, UnknownHostException</li>
<li>public abstract Socket createSocket(InetAddress var1, int var2) throws IOException</li>
<li>public abstract Socket createSocket(InetAddress var1, int var2, InetAddress var3, int var4) throws IOException</li>
</ul>
<h6 id="选择密码组"><a href="#选择密码组" class="headerlink" title="选择密码组"></a>选择密码组</h6><p>JSSE的不同实现支持认证和加密算法的不同组合。默认情况下，JDK 1.7实现启用了所有加密认证密码组。如果想要无认证的事务或认证但不加密的事务，必须用setEnalbledCipherSuites（）方法显式启用这些密码组。同时要避免名字中包含NULL、ANON或EXPORT的密码组。</p>
<p>强制连接使用密码组可以使用这样的代码段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SocketFactory sslSocketFactory = SSLSocketFactory.getDefault();</span><br><span class="line">SSLSocket socket = sslSocketFactory.createSocket();</span><br><span class="line">String[] suites = &#123;&quot;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256&quot;&#125;;</span><br><span class="line">socket.setEnabledCipherSuites(suites);</span><br></pre></td></tr></table></figure>
<p>每个密码组中的算法都分为四个部分：协议、密钥交换算法、加密算法和校验和。</p>
<blockquote>
<p>除了选择密码组，还有管理会话和确立客户端是否需要自行认证的方法。</p>
</blockquote>
<h5 id="创建安全服务器Socket"><a href="#创建安全服务器Socket" class="headerlink" title="创建安全服务器Socket"></a>创建安全服务器Socket</h5><p>与安全客户端Socket相似，创建安全服务器Socket同样是工厂模式。但是需要注意的是，为了同时进行加密，服务端安全Socket需要更多的初始化和设置，如以下步骤所示：</p>
<ol>
<li>使用keytool生成公开密钥和证书</li>
<li>花钱请可信任的第三方认证你的证书</li>
<li>为你使用的算法创建一个SSLContext</li>
<li>为你要使用的证书源创建一个TrustManagerFactory</li>
<li>为你要使用的密钥类型创建一个KeyManagerFactory</li>
<li>为密钥和证书数据库创建一个KeyStore对象</li>
<li>用密钥和证书填充KeyStore对象</li>
<li>用KeyStore及其口令短语初始化KeyManagerFactory</li>
<li>用KeyManagerFactory中的密钥管理器（必要）、TrustManagerFactory中的信任管理器和一个随机源来初始化上下文</li>
</ol>
]]></content>
      <categories>
        <category>Android网络开发</category>
      </categories>
  </entry>
  <entry>
    <title>URL、URI和代理</title>
    <url>/2018/11/20/URL%E4%B8%8EURLconnection/</url>
    <content><![CDATA[<h4 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h4><p>java.net.URL类是对统一资源定位符的抽象。它扩展了java.lang.Object，是一个final类，不能对其派生子类。它不依赖于继承来配置不同类型URL的实例，而使用了策略设计模式。<em>协议处理器</em> 就是策略，URL类构成上下文，通过它来选择不同的策略。</p>
<p>URL类支持的协议取决于虚拟机支持哪些协议，如下所示，可以用来确定一个虚拟机支持哪些协议。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.net.URL;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        testProtocol(&quot;http://www.abc.org&quot;);</span><br><span class="line">        testProtocol(&quot;https://www.baidu.com&quot;);</span><br><span class="line">        testProtocol(&quot;jdbc:mysql://luna.ibiblio.org:3306/NEWS&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void testProtocol(String url) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            URL url1 = new URL(url);</span><br><span class="line">            System.out.print(url1.getProtocol() + &quot; is Supported\n&quot;);</span><br><span class="line">        &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">            String protocol = url.substring(0, url.indexOf(&apos;:&apos;));</span><br><span class="line">            System.out.print(protocol + &quot; is not supported\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http is Supported</span><br><span class="line">https is Supported</span><br><span class="line">jdbc is not supported</span><br></pre></td></tr></table></figure>
<h4 id="URI类"><a href="#URI类" class="headerlink" title="URI类"></a>URI类</h4><p>URI是对URL的抽象，不仅包括URL，还包括URN（统一资源名）。这个类与java.net.URL类的区别表现在3个重要的方面：</p>
<ol>
<li>URI类完全有关于资源的标识和URI的解析。它没有提供方法来获取URI所标识资源的表示。</li>
<li>相比URL类，URI类与相关的规范更一致。</li>
<li>URI对象可以表示相对URI。URL类在存储URI之前会将其绝对化。</li>
</ol>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>许多系统通过代理服务器访问Web，有时还会访问Internet的其他非HTTP部分。代理服务器接收到从本地客户端到远程服务器的请求。代理服务器向远程服务器发出请求，再将结果转发回本地客户端。有时这样做是出于安全原因，如防止远程主机了解关于本地网络配置的秘密细节。</p>
<p>基于URL类的Java程序可以使用大多数常见的代理服务器和协议。</p>
<h5 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h5><p>Proxy类允许从Java程序中对代理服务器进行更细粒度的控制。确切地讲，它允许你为不同的远程主机选择不同的代理服务器。代理本身用java.net.Proxy类的实例来表示。仍然只有三种代理：HTTP、SOCKS、和直接连接（即没有代理），分别用Proxy.Type枚举中的三个常量来表示：</p>
<ul>
<li>Proxy.Type.DIRECT</li>
<li>Proxy.Type.HTTP</li>
<li>Proxy.Type.SOCKS</li>
</ul>
<p>除了类型之外，关于代理的其他重要信息包括它的地址和端口，用SocketAddress对象表示。例如，下面的代码段创建了一个Proxy对象，表示proxy.example.com的端口80上的一个HTTP<br>代理服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SocketAddress address = new InetSocketAddress(&quot;proxy.example.com&quot;, 80);</span><br><span class="line">Proxy proxy = new Proxy(Proxy.Type.HTTP, address);</span><br></pre></td></tr></table></figure>
<p>虽然只有三种代理对象，但是对于不同主机上的不同代理服务器，可以有相同类型的多个不同代理。</p>
<h4 id="与网站认证相关的类"><a href="#与网站认证相关的类" class="headerlink" title="与网站认证相关的类"></a>与网站认证相关的类</h4><p>很多流行的网站需要提供用户名和口令才能访问。有些网站（如W3C成员页面）通过HTTP认证来实现这一点。其他的网站，如New York Times网站，则通过cookie和HTML表单来实现。Java的URL类可以访问使用HTTP认证的网站，不过，当然需要提供用户名和口令。</p>
<p>对于使用基于cookie的非标准认证的网站，要提供支持会更有难度，很重要的一个原因是：不同网站的cookie认证有很大区别。实现cookie认证往往要实现一个完整的Web浏览器，而且需要提供充分的HTML表单和cookie支持。</p>
<h5 id="Authenticator类"><a href="#Authenticator类" class="headerlink" title="Authenticator类"></a>Authenticator类</h5><p>包java.net包括一个Authenticator类，可以用它为使用HTTP认证自我保护的网站提供用户名和口令，由于Authenticator是一个抽象类，所以必须派生子类，不同子类可以采用不同的方式获取信息。</p>
<blockquote>
<p>需要注意的是，Authenticator类中没有抽象方法</p>
</blockquote>
<p>为了让URL使用这个子类，要把它传递给Authenticator.setDefault()静态方法，将它安装为默认的认证程序（Authenticator）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authenticator.setDefault(new Authenticator() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected PasswordAuthentication getPasswordAuthentication() &#123;</span><br><span class="line">                return super.getPasswordAuthentication();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            protected URL getRequestingURL() &#123;</span><br><span class="line">                return super.getRequestingURL();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            protected RequestorType getRequestorType() &#123;</span><br><span class="line">                return super.getRequestorType();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>只需要安装一次。此后，当URL类需要用户名和口令时，它就会使用Authenticator.requestPasswordAuthentication()静态方法询问这个Authenticator类的子类,这个方法的源代码如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static PasswordAuthentication requestPasswordAuthentication(</span><br><span class="line">                                    String host,</span><br><span class="line">                                    InetAddress addr,</span><br><span class="line">                                    int port,</span><br><span class="line">                                    String protocol,</span><br><span class="line">                                    String prompt,</span><br><span class="line">                                    String scheme,</span><br><span class="line">                                    URL url,</span><br><span class="line">                                    RequestorType reqType) &#123;</span><br><span class="line"></span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        if (sm != null) &#123;</span><br><span class="line">            NetPermission requestPermission</span><br><span class="line">                = new NetPermission(&quot;requestPasswordAuthentication&quot;);</span><br><span class="line">            sm.checkPermission(requestPermission);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Authenticator a = theAuthenticator;</span><br><span class="line">        if (a == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            synchronized(a) &#123;</span><br><span class="line">                a.reset();</span><br><span class="line">                a.requestingHost = host;</span><br><span class="line">                a.requestingSite = addr;</span><br><span class="line">                a.requestingPort = port;</span><br><span class="line">                a.requestingProtocol = protocol;</span><br><span class="line">                a.requestingPrompt = prompt;</span><br><span class="line">                a.requestingScheme = scheme;</span><br><span class="line">                a.requestingURL = url;</span><br><span class="line">                a.requestingAuthType = reqType;</span><br><span class="line">                return a.getPasswordAuthentication();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如源代码中所示,它使用了getPasswordAuthentication()方法,所以这个方法也是必须被重写的</p>
<p>requestPasswordAuthentication()函数中各个参数如下:</p>
<ol>
<li><p>String host: 主机名</p>
</li>
<li><p>InetAddress addr: 需要认证的主机</p>
</li>
<li><p>int port: 该主机上的端口</p>
</li>
<li><p>String protocol: 访问网站的应用层协议</p>
</li>
<li><p>String prompt: 需要认证的域的域名</p>
</li>
<li><p>String scheme: 认证模式</p>
</li>
<li><p>URL url: 引发身份验证的请求URL</p>
</li>
<li><p>RequestorType reqType: 认证类型(请求认证的是服务器还是代理服务器)</p>
</li>
</ol>
<h5 id="PasswordAuthentication类"><a href="#PasswordAuthentication类" class="headerlink" title="PasswordAuthentication类"></a>PasswordAuthentication类</h5><p>非常简单的final类,它支持两个只读属性:用户名和口令</p>
<h5 id="JPasswordField类"><a href="#JPasswordField类" class="headerlink" title="JPasswordField类"></a>JPasswordField类</h5><p>Swing中的组件,能以稍安全的方式来询问用户口令。</p>
]]></content>
      <categories>
        <category>Android网络开发</category>
      </categories>
  </entry>
  <entry>
    <title>传输层协议：UDP与TCP（三）</title>
    <url>/2018/11/15/UDP-and-TCP2/</url>
    <content><![CDATA[<h4 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h4><p>TCP的窗口管理将正确接收段的确认和接收端的接收缓冲区分配分离开来。例如，假设接收端有一个4096字节的缓冲区，如下图所示。</p>
<p><img src="https://i.loli.net/2018/11/15/5bed35516ae56.png" alt="tcp21.PNG"></p>
<p>详细过程如下：</p>
<ol>
<li>如果发送了一个2048字节的数据段，并且该数据段已被正确地接收，那么，接收端将确认该数据段。然而，由于接收端现在只剩下2048字节的缓冲区空间（在应用程序从缓冲区取走数据之前），所以它将宣告下一个期望字节开始窗口为2048。</li>
<li>发送端又传输了另一个2048字节长的段，该段被确认了，但是接收端宣告的窗口大小变成了0。因此，发送端不得不停止，等待接收主机上的应用程序从缓冲区取走一些数据。到那时候，TCP实体可以向发送端宣告一个更大的窗口，发送端才能发送数据。</li>
<li>当窗口变为0时，发送端不能如通常那样发送段了，但这里有两种意外情形。第一，紧急数据仍可以发送，比如，允许用户杀掉远程机器上运行的某一个进程。第二，<em>发送端可以发送一个1字节的段，以便强制接收端重新宣告下一个期望的字节和窗口大小，这种数据包称为窗口探测。TCP标准明确地提供了这个选项，来防止窗口更新数据包丢失后发生死锁。</em></li>
<li>发送端并不一定一接到应用程序传递来的数据马上将数据传送出去；同样，接收端也不一定必须尽可能快地发送确认段。TCP实体可以充分利用这种自由度来提高传输性能。</li>
</ol>
<h5 id="TCP性能问题"><a href="#TCP性能问题" class="headerlink" title="TCP性能问题"></a>TCP性能问题</h5><h6 id="带宽紧缺"><a href="#带宽紧缺" class="headerlink" title="带宽紧缺"></a>带宽紧缺</h6><blockquote>
<p>带宽：是指在固定的时间可传输的资料数量，亦即在传输管道中可以传递数据的能力。</p>
</blockquote>
<p>在带宽紧缺的场合，在同一时间间隔内多次发送应答报文不合适，会浪费珍贵的带宽资源</p>
<p>解决方法：延迟确认，基本想法是将确认和窗口更新延迟50毫秒，希望能够获得一些数据免费搭载过去。不过尽管通过延迟确认减少了接收端给与网络的负载，但是发送端发送多个小数据包的工作方式依然非常低效。避免这种用法的一种方法是采用Nagle算法：当数据每次以很少量方式进入到发送端时，发送端只是发送第一次到达的数据字节，然后将其余后面到达的字节缓冲起来，直到发送出去的那个数据包被确认。然后将所有缓冲的字节放在一个TCP段中发送出去，并且继续开始缓冲字节，直到下一个段被确认。这种算法可以大大地减少所需的带宽。</p>
<blockquote>
<p>当需要一个快速的短数据包流时（比如在Internet上玩互动游戏时），可以禁用Nagle算法</p>
</blockquote>
<h6 id="低能窗口综合症"><a href="#低能窗口综合症" class="headerlink" title="低能窗口综合症"></a>低能窗口综合症</h6><p>当每次接收端缓冲区只有1个字节的空闲，而发送端也发送一字节，接收端也对这1字节的数据段进行确认，同时设置窗口大小为0。这种行为可能会永久地持续下去。</p>
<p>解决方法：如同发送端的TCP一样，接收端的TCP也可以缓冲数据，它可以阻塞上层应用的读请求，直至它累积来大块的数据。这样做可以减少调用TCP的次数，而从减少额外的开销。当然，这样做也增加了响应的时间，但是，对于像文件传输这样的非交互式应用来说，效率可能比单个请求的响应时间更加重要。</p>
<h6 id="数据段乱序"><a href="#数据段乱序" class="headerlink" title="数据段乱序"></a>数据段乱序</h6><p>乱序到达的数据段到达时，没有什么比丢弃乱序到达的段更糟糕的事，因为丢弃这些段，那么它们将被发送端重传。</p>
<p>解决方法：只有当确认字节之前的所有数据都到达之后才能发送确认，这种方法称为累计确认。如果接收端已经获得0、1、2、4、5、6、7，它可以确认直到段2（包括段2）之前的数据。当发送端超时，然后重发段3.因为接收端已经缓冲了段4~段7，一旦它收到段3就可以立即确认直到段7的全部字节。</p>
<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><p>当提供给任何网络的负载超过它的处理能力时，拥塞便会产生。Internet也不例外。当路由器上的队列增长到很大时，网络层检测到拥塞，并试图通过丢弃数据包来管理拥塞。传输层接收到从网络层反馈来的拥塞信息，并减慢它发送到网络的流量速率。</p>
<p>TCP的拥塞控制是在AIMD（加法递增乘法递减）的基础山实现的，它使用了一个窗口，并且把丢包当作二进制信号。要做到这一点，<em>TCP维持一个拥塞窗口，窗口大小是任何时候发送端可以往网络发送的字节数。</em> 响应的速率则是窗口大小除以连接的往返时间。TCP根据AIMD规则来调整该窗口的大小。</p>
<p>除了维护一个拥塞窗口外，还有一个流量控制窗口，该窗口指出了接收端可以缓冲的字节数。<em>要并发跟踪这两个窗口，可能发送的字节数是两个窗口中较小的那个。因此，有效窗口是发送端认为的应该大小和接收端认为的应该大小中的较小者。</em> 如果拥塞窗口或流量控制窗口暂时已满，则TCP将停止发送数据。如果接收端说“发送64KB数据”，但发送端直到超过32KB的突发将阻塞网络，它就只发送32KB；另一方面，如果接收端说“发送64KB数据”，发送端知道高达128KB的突发通过网络都毫不费力，它会发送要求的全部64KB。</p>
<h5 id="现代拥塞控制算法"><a href="#现代拥塞控制算法" class="headerlink" title="现代拥塞控制算法"></a>现代拥塞控制算法</h5><ol>
<li>慢速启动</li>
</ol>
<p>当建立连接时，发送端用一个很小的值初始化拥塞窗口，最多不超过4个段，然后发送端发送该初始窗口大小的数据。数据包必须通过一个往返时间才被确认。结果是每一个被确认的段允许发送两个段，每经过一个往返时间拥塞窗口增加一倍。</p>
<p>但是，慢启动下按照指数级增长拥塞窗口，当网络管道已经为满时，发送端把额外的数据包放置到网络中将在路由器产生队列，因为它们被传递到接收器的速度不够快。拥塞和丢包即将产生。<em>为了保持对慢速启动的控制，发送端为每个连接维持一个称为慢启动阙值的阙值，最初，这个值被设置得任意高，可以达到流量控制窗口的大小，因此它不会限制连接速度。TCP以慢速启动方式不断增加拥塞窗口，直到发生超时，或者拥塞窗口超过该阙值。每当检测到丢包，比如超时了慢启动阙值就被设置为当前拥塞窗口的一半，整个过程再++<del>~~重新启动</del>~~++。一旦慢启动超过了阙值，TCP就从慢速启动切换到线性增加（即加法递增）。</em></p>
<blockquote>
<p>发送端有一个快速方法来识别它的包已经被丢失。当丢失数据包的后续数据包到达接收端时，它们出发给发送端返回确认。这些段携带着相同的确认号，称为 <em>重复确认</em> 。发送端每次收到重复确认时，很可能另一个包已经到达接收端，而丢失的那个包仍然没有出现。因为包可以选择网络中不同的路径，所以它们可能不按发送顺序到达接收端。这样就会出发重复确认，即使没有数据包丢失。</p>
</blockquote>
<ol>
<li>快速重传</li>
</ol>
<p>TCP假设三个重复确认意味着丢失一个包。<em>丢失包的序号可以从确认号推断出来，这个包可以被立即重传，这种启发式机制称为快重传。</em> 重传后，慢启动阙值被设置为当前拥塞窗口的一般，就像发生了超时一样。重新开始慢启动过程，拥塞窗口被设置成一个包。有了这个窗口大小，如果在一个往返时间内确认了该重传的数据包以及丢包之前已发送的所有数据，则发出一个新的数据包。</p>
<ol>
<li>快速恢复</li>
</ol>
<p>在快速重传时，连接还工作在一个太大的拥塞窗口，但它仍然同样以<em>确认时钟</em> 的速率在运行。每次到达另一个重复确认时，可能另一个数据包已经离开网络。使用重复确认来计算网络中的数据包，有可能让一些包离开网络，并继续为每一个额外的重复确认发送一个新的包。，<em>快速恢复就是实现这种行为的启发式机制。这是一个临时模式，其目的是保持拥塞窗口上运行确认时钟，该拥塞窗口有一个新阙值或者快速重传时把拥塞窗口减半。</em>要做到这一点，对重复确认要计数，直到网络内的数据包数量下降到新阙值，当丢失的包都被重传并确认时，重复确认流将停止，快速恢复模式就此退出。拥塞窗口将被设置到新的慢启动阙值，并开始按线性增长。</p>
<blockquote>
<p>确认时钟：确认返回到发送端的速率恰好是数据包通过路径上最慢链路时的速率。</p>
</blockquote>
<p>这种启发式的结果是TCP避免了慢速启动，只有第一次启动或者发生超时时才进入真正的慢速启动。</p>
<h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><ul>
<li>选择确认</li>
</ul>
<p>TCP从一个反复确认流中推断出已经到达和已经丢失的数据包。累计确认号无法提供这种确切的消息。一个简单的解决方法是使用选择确认，该确认列出了3个已接收的字节范围。有了这个信息，发送端在实现拥塞窗口时可以更直接地确定哪些数据包需要重传，并跟踪那些还在途中的数据包。</p>
<ul>
<li>显式拥塞通知（ECN）</li>
</ul>
<p>ECN是IP层的机制，主要用来通知主机发生了拥塞，有了它，除了用丢包作为拥塞信号外，TCP也可以接收来自IP的拥塞信号。可以在标识位中设置。</p>
]]></content>
      <categories>
        <category>Android网络开发</category>
      </categories>
  </entry>
  <entry>
    <title>传输层协议：UDP与TCP（二）</title>
    <url>/2018/11/13/UDP-and-TCP1/</url>
    <content><![CDATA[<h4 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h4><p>TCP使用了三次握手法来建立连接，如下图所示</p>
<p><img src="https://i.loli.net/2018/11/13/5bea910814091.png" alt="捕获1.PNG"></p>
<p>TCP三次握手详细过程：</p>
<ol>
<li>客户机器A上的一个应用程序发出连接请求，本地的TCP实体创建一条连接记录，并将它标记为SYN SENT状态，然后发送一个SYN段，此SYN段中包含了主机A选择的序号x</li>
<li>服务器执行监听，当收到一个SYN时，服务器就确认该段发出SYN+ACK并且进入到SYN RCVD状态。其中ACK段是作为对x的确认，同时宣告自己的初始序号y</li>
<li>最后，主机1对服务器选择的序号进行确认，当主机A发出最后一个ACK段后，主机A切换到ESTABLISHED状态，服务器收到ACK段后也切换到ESTACLISHED状态</li>
</ol>
<h5 id="三次握手的漏洞"><a href="#三次握手的漏洞" class="headerlink" title="三次握手的漏洞"></a>三次握手的漏洞</h5><ul>
<li>SYN泛洪</li>
</ul>
<p>当监听进程接受一个连接请求，并立即以SYN段作为响应时，它必须记住该SYN段的序号。这意味着一个恶意的发送端很容易地占据一个主机资源。具体的做法是这样的：恶意用户绵绵不断地发送SYN段请求服务器连接，但又故意不完成连接建立的后续过程，由此可消耗掉一台主机的资源。这种攻击称为SYN泛洪。</p>
<p>抵御这种攻击的一种方法是使用SYN“小甜饼”（SYN Cookie）。主机不去记忆序号，而是选择一个加密生成的序号，将它放在出境段中，并且忘记它。如果三次握手完成后，该序号（加1）将返回主机。主机运行相同的加密函数进行解密，重新生成正确的序号。这个过程允许主机检查确认号是否正确，而不必记住单独的序号。这里存在一些注意事项，比如无法处理TCP选项，所以只有当主机容易受到SYN泛洪时，才可以使用SYN Cookie。</p>
<ul>
<li>其他</li>
</ul>
<p>如伪造连接，可使用伪随机的初始序号，保证在一个时间间隔内初始序号不能重复，防止序号回绕（PAWS）</p>
<h4 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h4><p>TCP使用四次挥手来释放连接，如图所示</p>
<p><img src="https://i.loli.net/2018/11/14/5bebd91cddcf3.png" alt="tcp1.PNG"></p>
<p>TCP挥手详细过程：</p>
<ol>
<li>主机中的应用程序执行CLOSE原语，从而使本地的TCP实体发送一个FIN段，并切换到FIN WAIT 1状态</li>
<li>当服务器收到FIN段后，向主机发送ACK段，当ACK到达主机时，它的状态会切换到FIN WAIT 2，连接的一个方向被关闭</li>
<li>服务器发送完所有数据包后，它也会执行CLOSE，TCP实体给客户发送一个FIN段</li>
<li>主机确认了服务器发来的FIN，发送给服务器ACK段，服务器收到确认返回后便释放该连接并删除响应的连接记录，客户主机的TCP等待一段长度为最大数据包生存期两倍的时间，当计时器超时后，TCP删除该连接记录</li>
</ol>
<h5 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h5><p>第一个ACK和第二个FIN有可能被组合在同一段中，从而将所需段总数降低到三个。如下图所示：</p>
<p><img src="https://i.loli.net/2018/11/14/5bebd93323ab9.png" alt="tcp2.PNG"></p>
<h5 id="非对称释放"><a href="#非对称释放" class="headerlink" title="非对称释放"></a>非对称释放</h5><p>连接的两端在发送完自己的数据之后都用一个FIN段和ACK来释放连接的方式叫做对称释放方式，但许多Web服务器给客户端发送一个RST包，导致突然关闭连接，这种方式就是非对称方式释放连接。或者在超时的时候，也会有非对称释放方式（这种方式往往由心跳机制实现）。</p>
]]></content>
      <categories>
        <category>Android网络开发</category>
      </categories>
  </entry>
  <entry>
    <title>传输层协议：UDP与TCP（一）</title>
    <url>/2018/11/08/UDP-and-TCP/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>协议</th>
<th>特点</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>UDP</td>
<td>无连接，给应用提供发送数据包功能并允许它们在所需的层次之上架构自己的协议</td>
<td>客户-服务器交互和多媒体应用</td>
</tr>
<tr>
<td>TCP</td>
<td>面向连接，建立连接并通过重传机制增加了可靠性，同时还进行流量控制和拥塞控制，为使用它的应用程序做了所有的一切</td>
<td>为大多数Internet应用提供可靠的、按序递交的传输</td>
</tr>
</tbody>
</table>
<blockquote>
<p>TCP是为数据的可靠传输而设计的。如果数据在传输中丢失或损坏，TCP会保证再次发送数据。如果数据包乱序到达，TCP会将其置回正确的顺序。对于连接来说，如果数据到来的速度太快，TCP会降低速度，以免数据报丢失。程序永远不需要担心接收到乱序或不正确的数据。不过，这种可靠性是有代价的。这个代价就是速度。建立和撤销TCP连接会花费相当长的时间。UDP是在IP之上发送数据的另一种传输层协议，速度很快，但不可靠。当发送UDP数据时，无法知道数据是否会到达，也不知道数据的各个部分是否会以发送时的顺序到达。不过，确实能到达的部分一般都会很快到达。可以用电话系统和邮局的关系来对照解释TCP与UDP的区别。</p>
</blockquote>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP（用户数据包协议）为应用程序提供了一种无需建立连接就可发送封装的IP数据包的方法。</p>
<h5 id="UDP的段"><a href="#UDP的段" class="headerlink" title="UDP的段"></a>UDP的段</h5><p>UDP传输的段由8字节的头和有效载荷字段构成。头信息中包含的两个端口（port）分别用来标识源机器和目标机器内部的端点。当一个UDP数据包到来时，它的有效载荷被递交给与目标端口相关联的哪个进程。采用UDP而不是原始IP的最主要价值在于增加了源端口和目标端口。</p>
<p>UDP段中还包含了一个可选的校验和来提供额外的可靠性，当不使用校验和时，则将该字段填为0。</p>
<h5 id="功能总结"><a href="#功能总结" class="headerlink" title="功能总结"></a>功能总结</h5><p>UDP只是提供了一个与IP协议的接口，并在此接口上通过端口号复用多个进程的功能，以及可选的端到端错误检测功能。</p>
<h5 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h5><h6 id="客户机-服务器开发"><a href="#客户机-服务器开发" class="headerlink" title="客户机-服务器开发"></a>客户机-服务器开发</h6><p>客户端向服务器发送一个简短的请求报文，并期待来自服务器的简短服务报文。如果请求或回复报文丢失，客户端就会超时，然后再试一次。</p>
<blockquote>
<p>同时，这也是RPC（远程过程调用）的基础</p>
</blockquote>
<h6 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h6><p>一个程序需要查询某个主机名的IP地址，那么它可以给DNS服务器发送一个包含该主机名的UDP数据包。服务器用一个包含了该主机IP地址的UDP数据包作为应答。实现不需要建立连接，事后也不需要释放连接。只有两条消息通过网络就够了。</p>
<h6 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h6><p>RTP（实时传输协议）与RTCP（实时传输控制协议）都是位于UDP之上的协议，广泛应用于多媒体应用程序。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP（传输控制协议）是为了在不可靠的互联网上提供端到端字节流而专门设计的一个传输协议。</p>
<h5 id="TCP段"><a href="#TCP段" class="headerlink" title="TCP段"></a>TCP段</h5><p>TCP段由一个固定大小的20字节的头以及随后0个或者多个数据字节构成。TCP软件决定了段的大小。它可以将多次写操作中的数据累计起来，放到一个段中发送。有两个因素限制了段的长度。首先，包括TCP头在内的每个段，必须适合IP的65515个字节有效载荷；其次，每个网络都有一个最大传输单元（MTU）。发送端和接收端的每个段必须适合MTU，才能以单个不分段的数据包发送和接收。然而，当IP数据包穿过一条网络路径，其上某条链路有更小的MTU时，还是有可能要对携带TCP段的该IP数据包实行分段操作。TCP实体使用的基本协议是具有动态窗口大小的滑动窗口协议。当发送端传送一段时，它启动一个计时器。当该端到达接收方时，接收端的TCP实体返回一个携带确认号和剩余窗口大小的段，并且确认号的指等于接收端期望接收的下一个序号。如果发送端的计时器在确认段到达之前超时，则发送端再次发送原来的段。</p>
<h6 id="TCP段的头"><a href="#TCP段的头" class="headerlink" title="TCP段的头"></a>TCP段的头</h6><p>TCP段的结构如图所示。每个段的起始部分是一个固定格式的20字节头。固定的头部之后可能有头的选项。如果该数据段有数据部分的话，那么在选项之后是最多可达65535 - 20 -20 = 65495个字节的数据，这里的第一个20是指IP头，第二个20指TCP头。没有任何数据的TCP段也是合法的，通常被用作确认和控制消息。</p>
<p><img src="https://i.loli.net/2018/11/09/5be54f222d225.png" alt="捕获.PNG"></p>
<ul>
<li><p>源端口（Source port）和目标端口（Destination port）字段标识了连接的本地端点。TCP端口加上所在主机的IP地址组成了48位的唯一端点。</p>
</li>
<li><p>序号（Sequence number）和确认号（Acknowledgement number）字段执行它们的常规功能。请注意，后者指定的是下一个期待的字节，而不是已经正确接收到的最后一个字节。它是累计确认（cumulative acknowledgement），因为它用一个数字概括了接收到的所有数据，它不会超过丢失的数据。这两个字段都是32位长，因为一个TCP流中的每一个数据字节都已经被编号了。</p>
</li>
<li><p>TCP头长度（TCP header length）字段指明了TCP头包含多少个32位的字。这个信息是必需的，因为选项（Options）字段是可变长的，因而整个头也是边长的，这个字段实际上指明了数据部分在段内的起始位置。</p>
</li>
</ul>
<blockquote>
<p>TCP头长度字段之后为4位没有被使用的字段，用来备用（可用这些位来修正原来设计中的错误），原先有6位</p>
</blockquote>
<ul>
<li>8个1比特的标志位</li>
</ul>
<ol>
<li><p>CWR和ECE：用作拥塞控制的信号。当TCP接收端收到了来自网络的拥塞指示后，就设置ECE以便给TCP发送端发ECN-Echo信号，告诉发送端发慢发送速率。TCP发送端设置CWR，给TCP接收端发CWR信号，这样接收端就知道发送端已经放慢速率，不必再给发送端发ECN-Echo信号。</p>
</li>
<li><p>ACK：ACK被设置为1表示确认号字段是有效的。几乎所有的数据包都会用到这个标志位。如果ACK为0，则该段不包含确认信息，所以，确认号字段可以被忽略。</p>
</li>
<li><p>PSH：指出这是被推送的数据。特此请求接收端一旦收到数据后立即将数据递交给应用程序，而不是将它缓冲起来直到缓冲区满为止。</p>
</li>
<li><p>RST：被用于突然重置一个已经变得混乱的连接，混乱有可能是由于主机崩溃，或者其他什么原因造成的。<em>该标志位也可以用来拒收一个无效的段，或者拒绝一个连接请求。</em></p>
</li>
<li><p>SYN：被用于建立连接过程。在连接请求中，SYN=1和ACK=0表示该段没有使用捎带确认字段。但是，连接应答捎带了一个确认，因此SYN=1和ACK=1.</p>
</li>
<li><p>FIN被用来释放一个连接。它表示发送端已经没有数据需要传输了。然而，在关闭一个连接之后，关闭进程可能会在一段不确定的时间内继续接收数据。SYN和FIN段都有序号，从而保证了这两种段以正确的顺序被处理。</p>
</li>
</ol>
<ul>
<li><p>窗口大小（Window size）：TCP中的流量控制是通过一个可变大小的滑动窗口来处理的。窗口大小字段指定了从被确认的字节算起可以发送多少个字节。窗口大小字段为0是合法的，说明到现在为止已经接收到了多达确认号-1个字节，但是接收端没有更多的机会来消耗数据，希望别再发数据。以后，接收端可以通过发送一个具有同样确认号但是非零窗口大小字段的段来通知发送端继续发送端。</p>
</li>
<li><p>校验和（Checksum）提供了额外的可靠性。它校验的范围包括头、数据，以及与UDP一样的概念性伪头。</p>
</li>
<li><p>紧急指针（Urgent pointer）：如果使用了紧急指针，则将URG设置为1。紧急指针指向从当前序号开始找到紧急数据的字节偏移量。这个设施是中断消息的另一种途径。该设施允许发送端以少得不能再少的方式给接收端发送信号。</p>
</li>
<li><p>选项（Options）：选项字段提供了一种添加额外设施的途径，主要针对常规头覆盖不到的方面。协议定义了许多选项，有几个已经被广泛使用。</p>
</li>
</ul>
<blockquote>
<p>1.用途最广的选项允许每台主机指定它愿意接收的最大段长（MSS，Maximum Segment Size）。2.窗口尺度选项允许发送端和接收端在连接建立阶段协商窗口尺度因子。3.时间戳选项携带由发送端发送的时间戳，并被接收端回应，一旦在连接建立阶段启用了它，那么每个数据包都要包含这个选项，主要用来计算来回时间样值，该样值被用在估算多久之后数据包可以被认为丢失。4.选择确认选项使得接收端可以告诉发送端已经接收到端的序号范围。</p>
</blockquote>
<h5 id="TCP连接管理模型"><a href="#TCP连接管理模型" class="headerlink" title="TCP连接管理模型"></a>TCP连接管理模型</h5><p>建立连接和释放连接所需要的步骤可以用一个有限状态机来表示，该状态机的11中状态如图所示。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLOSED</td>
<td>没有活跃的连接或者挂起</td>
</tr>
<tr>
<td>LISTEN</td>
<td>服务器等待入境呼叫</td>
</tr>
<tr>
<td>SYN RCVD</td>
<td>到达一个连接请求，等待ACK</td>
</tr>
<tr>
<td>SYN SENT</td>
<td>应用以及启动了打开一个链接</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>正常的数据传送状态</td>
</tr>
<tr>
<td>FIN WAIT1</td>
<td>应用已经没有数据要发了</td>
</tr>
<tr>
<td>FIN WAIT2</td>
<td>另一端同意释放连接</td>
</tr>
<tr>
<td>TIME WAIT</td>
<td>等待所有数据包寿终正寝</td>
</tr>
<tr>
<td>CLOSING</td>
<td>两端同时试图关闭连接</td>
</tr>
<tr>
<td>CLOSE WAIT</td>
<td>另一端已经发起关闭连接</td>
</tr>
<tr>
<td>LAST ACK</td>
<td>等待所有数据包寿终正寝</td>
</tr>
</tbody>
</table>
<p>每个连接都从CLOSED状态开始。当它执行了一个被动打开操作（LISTEN），或者主动打开操作（CONNECT）后，它就离开CLOSED状态。如果另一端执行了相反的操作，则连接就建立起来，当前状态变成ESTABLISHED。连接的释放过程可以由任何一方发起。当释放完成时，状态又回到CLOSED。</p>
<blockquote>
<p>状态是针对每个连接的，并且每个连接的状态被记录在响应的连接记录中。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android网络开发</category>
      </categories>
  </entry>
  <entry>
    <title>DNS</title>
    <url>/2018/11/07/DNS/</url>
    <content><![CDATA[<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="概述及作用"><a href="#概述及作用" class="headerlink" title="概述及作用"></a>概述及作用</h4><p>我们平常在访问某个网站时不使用IP地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用TCP/IP进行通信时也不使用IP地址。而这样做正是因为有了DNS将字符串自动转换为具体的IP地址的功能。</p>
<h4 id="DNS的产生"><a href="#DNS的产生" class="headerlink" title="DNS的产生"></a>DNS的产生</h4><p>在互联网的起源ARPANET中，起初由互联网信息中心整体管理一份hosts文件。如果新增一台计算机接入到ARPANET网或者已有的计算机要进行IP地址变更，中心的这个hosts文件就得更新，而其他计算机则不得不定期下载最新的hosts文件才能正常使用网络。</p>
<p>随着网络规模的不断扩大、接入计算机的个数不断增加，使得这种集中管理主机名和IP地址的登陆、变更处理的可行性逐渐降低。</p>
<p>在上述背景之下，产生了一个可以有效管理主机名和IP地址之间对应关系的系统，就是DNS系统。在应用中，当用户输入主机名（域名）时，DNS会自动检索哪个注册了主机名和IP地址的数据库，并迅速定位对应的IP地址。而且，如果主机名和IP地址需要进行变更时，也只需要在组织机构内部进行处理即可，而没必要再向其他机构进行申请或报告。这样，有了DNS，无论网络规模变得多么庞大，都能在一个较小的范围内通过DNS进行管理，充分解决了ARPANET初期遇到的问题。</p>
<h4 id="DNS域名的构成"><a href="#DNS域名的构成" class="headerlink" title="DNS域名的构成"></a>DNS域名的构成</h4><p>域名是指为了识别主机名称和组织机构名称的一种具有分层的名称。例如，仓敷艺术科学大学的域名如下：</p>
<p><em>kusa.ac.jp</em></p>
<p>域名由几个英文字母用点号链接构成。在上述域名中最左边的“kusa”表示仓敷艺术科学大学固有的域名。而“ac”代表大学或其他高等教育机构。最后边的“jp”则代表日本。</p>
<p>在使用域名时，可以在每个主机名后面追加上组织机构的域名。例如，由pepper、piyo、kinoko等主机时，它们完整的带域名的主机名将呈如下形式：</p>
<p><em>pepper.kusa.ac.jp</em><br><em>piyo.kusa.ac.jp</em><br><em>kinoko.kusa.ac.jp</em></p>
<h5 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h5><p>DNS的分层结构如图所示，由于看起来像一颗倒挂的树，人们也罢这种分层结构叫做树形结构。</p>
<p><img src="https://i.loli.net/2018/11/07/5be2a0f9ba1b0.png" alt="捕获.PNG"></p>
<p>每个分层中，都设有一个域名服务器，它可以管理所在分层的域的相关信息。根部所设置的DNS叫做根域名服务器。它对DNS的检索数据功能起着至关重要的作用。根域名服务器中注册着根一下第一层域名服务器的IP地址。如果想要增加顶级域名或者修改顶级域名，就得在根域名服务器中进行追加或变更。类似地，如果想要修改该分层的域名或重新设置域名服务器的IP地址，还必须得在其上层的域名服务器中进行追加或修改。</p>
<h4 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h4><p>例如，当处于kusa.co.jp域中的计算机想要访问网站 www.ietf.org ，会经过如下流程</p>
<ol>
<li>向DNS服务器查询IP地址</li>
<li>由于kusa的DNS服务器并不知道 www.ietf.org 的IP地址是什么，它向根域名服务器请求进行查询</li>
<li>由于根域名服务器知道 www.ietf.org 的域名服务器的地址，所以将地址返回</li>
<li>DNS服务器向 ietf.org 查询 www.ietf.org 的IP地址</li>
<li>将查询到的IP地址返回给客户端</li>
<li>计算机开始与 www.ietf.org 进行通信</li>
</ol>
<p>解析器（进行DNS查询的主机和软件）为了查询IP地址，向域名服务器（不仅可以访问域中的域名服务器，还可以访问其他域的域名服务器）进行查询处理。接收这个查询请求的域名服务器首先会在自己的数据库进行查找。如果有该域名所对应的IP地址就返回。如果没有，则域名服务器再向上一层根域名服务器进行查询处理。上一层根服务器则对下层进行遍历，直到找到指定的域名服务器，否则再向上层根服务器查询。</p>
<p>解析器和域名服务区将最新了解到的信息暂时保存再缓存里，这样，可以减少每次查询时的性能消耗。</p>
]]></content>
      <categories>
        <category>Android网络开发</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟存储器</title>
    <url>/2018/10/31/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h4 id="虚拟存储器的引入"><a href="#虚拟存储器的引入" class="headerlink" title="虚拟存储器的引入"></a>虚拟存储器的引入</h4><p>一个系统中的进程与其他进程共享CPU和主存资源的。然而，共享内存会形成一些特殊的挑战。随着对CPU需求的增长，进程以某种合理的平滑方式慢了下来。但是如果太多的进程需要太多的存储器，那么它们中的一些根本就无法运行。有一些程序可能没有空间可用，存储器还很容易被破坏，如果某个进程不小心写了另一个进程使用的存储器，它就可能以某种完全和程序逻辑无关的令人困惑的方式失败。为了更加有效地管理存储器并且少出错，现代系统提供了一种对贮存的抽象概念，就是虚拟存储器（VM）。</p>
<h4 id="虚拟存储器的作用"><a href="#虚拟存储器的作用" class="headerlink" title="虚拟存储器的作用"></a>虚拟存储器的作用</h4><p>虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟存储器提供了三个重要的能力：</p>
<ol>
<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存</li>
<li>它为每个进程提供了一致的地址空间，从而简化了存储器管理</li>
<li>它保护了每个进程的地址空间不被其他进程破坏</li>
</ol>
<h5 id="虚拟存储器是如何工作的"><a href="#虚拟存储器是如何工作的" class="headerlink" title="虚拟存储器是如何工作的"></a>虚拟存储器是如何工作的</h5><h6 id="物理和虚拟地址"><a href="#物理和虚拟地址" class="headerlink" title="物理和虚拟地址"></a>物理和虚拟地址</h6><p>计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每个字节都有一个唯一的物理地址。第一个字节的地址为0，接下来的字节地址为1，再下一个为2，依此类推。CPU访问存储器的最自然的方式就是使用物理地址。当CPU执行加载指令时，它会生成一个有效的物理地址，通过存储器总线，把它传递给主存，主存取出从指令指定物理地址加载的字节，并将它返回给CPU，CPU会将它存放再一个寄存器里。</p>
<p>而现代处理器使用的则是一种称为虚拟寻址的寻址方式。使用虚拟寻址时，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被传送到存储器之前先转换成适当的物理地址。将一个虚拟地址转换成物理地址的任务叫做地址翻译。就像异常处理一样，地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做存储器管理单元（MMU）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容是由操作系统管理的。</p>
<ul>
<li>地址空间</li>
</ul>
<p>地址空间是一个非负数地址的有序集合：{0， 1， 2， …}</p>
<p>如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间。为了简化讨论，我们总是假设使用的是线性地址空间。在一个带虚拟存储器的系统中，CPU从一个由N = 2^n个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间：{0， 1， 2， …， N - 1},一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如，一个包含N = 2^n的虚拟地址空间就叫做一个n位地址空间。现代系统典型地支持32位或者64位虚拟地址空间。</p>
<p>一个系统还有一个物理地址空间，它与系统中物理存储器的M个字节相对应：{0, 1, 2, …, M - 1},M不要求是2的幂，但是为了简化讨论，我们假设M= 2^m。</p>
<p>允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟存储器的基本思想。主存中每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>
<h6 id="虚拟页面"><a href="#虚拟页面" class="headerlink" title="虚拟页面"></a>虚拟页面</h6><p>虚拟存储器（VM）被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。磁盘上数组的内容被缓存到主存中。和存储器层次结构中其他缓存一样，磁盘（较低层）上的数据被分割成块，这些块作为磁盘和主存（较高层）之间的传输单元。VM系统通过将虚拟存储器分割为虚拟页的大小固定的块来处理这个问题。每个虚拟页的大小为P = 2^p字节。类似地，物理存储器被分割为物理页，大小也有P字节（物理页也称为页帧）。</p>
<p>虚拟页面可被分为如下几个部分：</p>
<ul>
<li><p>未分配的：VM系统还未分配（或者创建）的页</p>
</li>
<li><p>缓存的：当前缓存在物理存储器中的已分配页</p>
</li>
<li><p>未缓存的：没有缓存在物理存储器中的已分配页</p>
</li>
</ul>
<h6 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h6><p>虚拟存储器必须有某种方法来判定一个虚拟页是否存放在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到缓存，替换这个牺牲页。而虚拟页与物理页的映射关系都存储在一个叫做页表的数据结构中。</p>
<p>页表就是一个页表条目的数组，虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE，可假设PTE是由一个有效位和一个n位地址字段组成的。有效位表明了该虚拟页是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中响应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么空地址就代表了这个虚拟页还未被分配，否则这个地址就指向该虚拟页在磁盘上的起始位置。</p>
<ul>
<li>页命中</li>
</ul>
<p>当CPU读取字节时，地址翻译硬件将虚拟地址作为一个索引来定位PTE，并从存储器读取它。因为设置了有效位，那么地址翻译硬件就知道这个字节是缓存在存储器当中的了，所以它使用PTE中的物理存储器地址，构造出这个字的物理地址。</p>
<ul>
<li>缺页</li>
</ul>
<p>当CPU读取字节，但是这个字节并没有被缓存时，就是缺页的情况。当发生缺页情况时，系统就会进行交换或者页面调度。页从磁盘换入DRAM和从DRAM换出磁盘。当由不命中发生时才换入页面的这种策略称为按需页面调度，所有现代系统都使用的是按需页面调度的方式。</p>
<blockquote>
<p>缺页处理步骤：缺页处理程序选择牺牲页，并从磁盘上选取目标页来取代它。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>堆排序实现</title>
    <url>/2018/09/27/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>说到堆排序，我们就得先知道什么是堆，而堆又分为最大堆（大顶堆）和最小堆（小顶堆）</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>在元素序列满足如下关系时，可称为堆</p>
<p><img src="https://i.loli.net/2018/10/16/5bc595290c0bb.png" alt="duiPNG.PNG"></p>
<h5 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h5><p>堆顶元素为最大值，如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/16/5bc595bdc5963.png" alt="大顶.PNG"></p>
<h5 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h5><p>堆顶元素为最小值，如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/16/5bc595bdc40be.png" alt="小丁PNG.PNG"></p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>堆排序是利用堆所设计的一种排序方法，它的各类复杂度如下：</p>
<table>
<thead>
<tr>
<th>时间复杂度(最好、最差、平均)</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(nlogN)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><ol>
<li>将无序队列构建为堆，若是n个元素的序列，然后从n/2个元素开始，到第一个元素结束，进行反复筛选。</li>
<li>输出顶堆的最大值或最小值，与堆中最后一个元素交换位置，使得处理的序列范围减一</li>
<li>将剩下的n-1个元素重复上述步骤，重新调整为新的堆，筛选出新的最大值或最小值</li>
<li>得到新的序列</li>
</ol>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void heapSort(int[] arr) &#123;</span><br><span class="line">    for(int i=arr.length/2-1;i&gt;=0;i--)&#123;</span><br><span class="line">        heapAdjust(arr,i,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j=arr.length-1;j&gt;0;j--)&#123;</span><br><span class="line">        swap(arr,0,j);</span><br><span class="line">        heapAdjust(arr,0,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void heapAdjust(int[] arr, int i, int length) &#123;</span><br><span class="line">    int temp = arr[i];</span><br><span class="line">    for(int k=i*2+1;k&lt;length;k=k*2+1)&#123;</span><br><span class="line">        if(k+1&lt;length &amp;&amp; arr[k]&lt;arr[k+1])&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(arr[k] &gt;temp)&#123;</span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">    nums[i] ^= nums[j];</span><br><span class="line">    nums[j] ^= nums[i];</span><br><span class="line">    nums[i] ^= nums[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>常见排序算法汇总及Java中默认实现</title>
    <url>/2018/09/15/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%E5%8F%8AJava%E4%B8%AD%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="基本排序算法的分类及比较"><a href="#基本排序算法的分类及比较" class="headerlink" title="基本排序算法的分类及比较"></a>基本排序算法的分类及比较</h3><p>首先，上一张各种排序算法比较的图</p>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>平均时间复杂度</th>
<th>最好情况下的时间复杂度</th>
<th>最坏情况下的时间复杂度</th>
<th>空间复杂度(辅助存储)</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O（n^1.5)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>直接选择排序</td>
<td>O（n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog2(n))</td>
<td>O(nlog2(n))</td>
<td>O(nlog2(n))</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog2(n))</td>
<td>O(nlog2(n))</td>
<td>O(nlog2(n))</td>
<td>O(nlog2(n))</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog2(n))</td>
<td>O(nlog2(n))</td>
<td>O(nlog2(n))</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<p>其中又可以分为四个大类，即插入排序、选择排序、交换排序与归并排序</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>插入排序</th>
<th>选择排序</th>
<th>交换排序</th>
<th>归并排序</th>
</tr>
</thead>
<tbody>
<tr>
<td>代表排序方法</td>
<td>直接插入排序、希尔排序</td>
<td>选择排序、堆排序</td>
<td>冒泡排序、快速排序</td>
<td>归并排序</td>
</tr>
</tbody>
</table>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h5 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h5><blockquote>
<p> 原理:它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序在实现上，通常采用in-place排序，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</blockquote>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void sort(int[] numbers)&#123;</span><br><span class="line">        for (int i = 1; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            int currentNumber = numbers[i];</span><br><span class="line">            int j = i - 1;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; numbers[j] &gt; currentNumber) &#123;</span><br><span class="line">                numbers[j + 1] = numbers[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[j + 1] = currentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><blockquote>
<p>原理：希尔排序实质是分组插入排序，基本思想是希尔排序是将待排序的数组元素 按下标的一定增量分组 ，分成多个子序列，然后对各个子序列进行直接插入排序算法排序；然后依次缩减增量再进行排序，直到增量为1时，进行最后一次直接插入排序，排序结束。</p>
</blockquote>
<p>具体代码实现可参考以下链接</p>
<p><a href="https://blog.csdn.net/MoreWindows/article/details/6668714" target="_blank" rel="noopener">希尔排序</a></p>
<p>当希尔排序的增量为1时，它就退化成了直接插入排序。</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h5><blockquote>
<p>原理：对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将该记录的位置与第一个记录的位置交换；接着对不包括第一个记录以外的其他记录进行第二次比较，得到最小记录并与第二个位置记录交换；重复该过程，知道进行比较的记录只剩下一个为止。</p>
</blockquote>
<p>具体实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void selectSort(int[] a) &#123;</span><br><span class="line">        if (a == null || a.length &lt;= 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            int temp = a[i];</span><br><span class="line">            int flag = i; // 将当前下标定义为最小值下标</span><br><span class="line">            for (int j = i + 1; j &lt; a.length; j++) &#123;</span><br><span class="line">                if (a[j] &lt; temp) &#123;// a[j] &lt; temp 从小到大排序；a[j] &gt; temp 从大到小排序</span><br><span class="line">                    temp = a[j];</span><br><span class="line">                    flag = j; // 如果有小于当前最小值的关键字将此关键字的下标赋值给flag</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag != i) &#123;</span><br><span class="line">                a[flag] = a[i];</span><br><span class="line">                a[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><blockquote>
<p>原理：堆排序就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中次大的值。如此反复执行，便能得到一个有序序列了。 堆排序的实现需要解决的两个关键问题：</p>
<ol>
<li>将一个无序序列构成一个堆。</li>
<li>输出堆顶元素后，调整剩余元素成为一个新堆。</li>
</ol>
</blockquote>
<p>具体实现可参考如下链接</p>
<p><a href="https://blog.csdn.net/jianyuerensheng/article/details/51263453" target="_blank" rel="noopener">堆排序</a></p>
<h4 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h4><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><blockquote>
<p>原理：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。</p>
</blockquote>
<p>具体代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void BubbleSort(int[] arr) &#123;</span><br><span class="line">        int temp;//定义一个临时变量</span><br><span class="line">        for(int i=0;i&lt;arr.length-1;i++)&#123;//冒泡趟数</span><br><span class="line">            for(int j=0;j&lt;arr.length-i-1;j++)&#123;</span><br><span class="line">                if(arr[j+1]&lt;arr[j])&#123;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+1];</span><br><span class="line">                    arr[j+1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><blockquote>
<p>原理：快速排序也是分治法思想的一种实现，他的思路是使数组中的每个元素与基准值（Pivot，通常是数组的首个值，A[0]）比较，数组中比基准值小的放在基准值的左边，形成左部；大的放在右边，形成右部；接下来将左部和右部分别递归地执行上面的过程：选基准值，小的放在左边，大的放在右边。直到排序结束。</p>
</blockquote>
<p>具体实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void quickSort(int[] nums, int low, int height) &#123;</span><br><span class="line">        if (low &gt; height) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = low;</span><br><span class="line">        int j = height;</span><br><span class="line">        int key = nums[low];</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            while (i &lt; j &amp;&amp; nums[j] &gt; key) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            while (i &lt; j &amp;&amp; nums[i] &lt;= key) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; j) &#123;</span><br><span class="line">                int temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int temp = nums[low];</span><br><span class="line">        nums[low] = nums[i];</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">        quickSort(nums, low, i - 1);</span><br><span class="line">        quickSort(nums, i + 1, height);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在整个数组已经完成排序或已经完全倒序的情况下，快速排序会退化成冒泡排序，这时每次选取的划界元素为最小值或最大值。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><blockquote>
<p>归并排序的原理大致可分为三步：</p>
<ol>
<li>分解：把待排序的 n 个元素的序列分解成两个子序列, 每个子序列包括 n/2 个元素</li>
<li>治理：对每个子序列分别调用归并排序MergeSort, 进行递归操作</li>
<li>合并：合并两个排好序的子序列,生成排序结果</li>
</ol>
</blockquote>
<p>具体实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void sort(int[] nums, int low, int height) &#123;</span><br><span class="line">        int mid = (low + height) / 2;</span><br><span class="line">        if (low &lt; height) &#123;</span><br><span class="line">            sort(nums, low, mid);</span><br><span class="line">            sort(nums, mid + 1, height);</span><br><span class="line">            merge(nums, low, mid, height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void merge(int[] nums, int low, int mid, int height) &#123;</span><br><span class="line">        int[] temp = new int[height - low + 1];</span><br><span class="line">        int i = low;</span><br><span class="line">        int j = mid + 1;</span><br><span class="line">        int index = 0;</span><br><span class="line">        while (i &lt;= mid &amp;&amp; j &lt;= height) &#123;</span><br><span class="line">            if(nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                temp[index ++] = nums[i ++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp[index ++] = nums[j ++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (i &lt;= mid) &#123;</span><br><span class="line">            temp[index ++] = nums[i ++];</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &lt;= height) &#123;</span><br><span class="line">            temp[index ++] = nums[j ++];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int n = 0; n &lt; temp.length; n ++) &#123;</span><br><span class="line">            nums[low + n] = temp[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java中排序算法的默认实现"><a href="#Java中排序算法的默认实现" class="headerlink" title="Java中排序算法的默认实现"></a>Java中排序算法的默认实现</h3><h4 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort"></a>Arrays.sort</h4><p>当我们调用了这个方法的时候，实际上这个方法会根据当前传入的参数是基本类型的数组还是对象数据来选择不同的排序策略</p>
<h5 id="当为基本类型的数组时"><a href="#当为基本类型的数组时" class="headerlink" title="当为基本类型的数组时"></a>当为基本类型的数组时</h5><p>判断数组当中的元素是否超过了使用插入排序的阙值，若超过了，则使用双轴快排进行排序，否则则使用插入排序。</p>
<blockquote>
<p>双轴快排对普通的快速排序进行了优化，每次选取两个划界元素，且会把与划界元素相近的指放在它附近</p>
</blockquote>
<h5 id="当为Object数组时"><a href="#当为Object数组时" class="headerlink" title="当为Object数组时"></a>当为Object数组时</h5><p>采用归并排序</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>OkHttp中拦截器流程解析</title>
    <url>/2018/09/10/OkHttp%E4%B8%AD%E6%8B%A6%E6%88%AA%E5%99%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>OkHttp中，我们对请求报文和返回报文的处理都是在拦截器中进行的，所以熟悉OkHttp中的各个拦截器以及它们是怎样的处理流程是理解OkHttp的重点</p>
</blockquote>
<h4 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h4><p>首先，我们所最后得到的Response是通过这个函数得到的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Response result = getResponseWithInterceptorChain();</span><br></pre></td></tr></table></figure>
<p>而这个函数当中，就定义了各个拦截器的处理位置，并把每个拦截器都加入到了拦截器链当中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">    // Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">        originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到拦截器的顺序大概是：</p>
<ol>
<li>自定义的拦截器（可定义多个）</li>
<li>retryAndFollowUpInterceptor</li>
<li>BridgeInterceptor</li>
<li>CacheInterceptor</li>
<li>ConnectInterceptor</li>
<li>自定义networkInterceptors（可定义多个）</li>
<li>CallServerInterceptor</li>
</ol>
<p>我们来一个个看看各个拦截器都做了什么，或者说能做什么（自定义拦截器）</p>
<h4 id="各个拦截器的作用"><a href="#各个拦截器的作用" class="headerlink" title="各个拦截器的作用"></a>各个拦截器的作用</h4><h5 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OkHttpClient client = new OkHttpClient.Builder().addInterceptor(new Interceptor() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public okhttp3.Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">                Request request = chain.request();</span><br><span class="line">                Request.Builder builder = request.newBuilder();</span><br><span class="line">                builder.addHeader(..., ...); //添加Header</span><br><span class="line">                okhttp3.Response response= chain.proceed(builder.build());</span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).build();</span><br></pre></td></tr></table></figure>
<p>自定义拦截器是对初始的请求报文进行最先的预处理，我们可以在请求报文中加入统一的Header，比如说可以加入Authorization的Header,这样在认证失效后可以进行自动重新认证。</p>
<h5 id="retryAndFollowUpInterceptor"><a href="#retryAndFollowUpInterceptor" class="headerlink" title="retryAndFollowUpInterceptor"></a>retryAndFollowUpInterceptor</h5><p>我们可以看到它的intercept分发如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Call call = realChain.call();</span><br><span class="line">    EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">    StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">        createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class="line">    this.streamAllocation = streamAllocation;</span><br><span class="line"></span><br><span class="line">    int followUpCount = 0;</span><br><span class="line">    Response priorResponse = null;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      if (canceled) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Response response;</span><br><span class="line">      boolean releaseConnection = true;</span><br><span class="line">      try &#123;</span><br><span class="line">        response = realChain.proceed(request, streamAllocation, null, null);</span><br><span class="line">        releaseConnection = false;</span><br><span class="line">      &#125; catch (RouteException e) &#123;</span><br><span class="line">        // The attempt to connect via a route failed. The request will not have been sent.</span><br><span class="line">        if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123;</span><br><span class="line">          throw e.getLastConnectException();</span><br><span class="line">        &#125;</span><br><span class="line">        releaseConnection = false;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        // An attempt to communicate with a server failed. The request may have been sent.</span><br><span class="line">        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);</span><br><span class="line">        if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;</span><br><span class="line">        releaseConnection = false;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        // We&apos;re throwing an unchecked exception. Release any resources.</span><br><span class="line">        if (releaseConnection) &#123;</span><br><span class="line">          streamAllocation.streamFailed(null);</span><br><span class="line">          streamAllocation.release();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Attach the prior response if it exists. Such responses never have a body.</span><br><span class="line">      if (priorResponse != null) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                    .body(null)</span><br><span class="line">                    .build())</span><br><span class="line">            .build();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Request followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line"></span><br><span class="line">      if (followUp == null) &#123;</span><br><span class="line">        if (!forWebSocket) &#123;</span><br><span class="line">          streamAllocation.release();</span><br><span class="line">        &#125;</span><br><span class="line">        return response;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">      if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (followUp.body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">            createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">        this.streamAllocation = streamAllocation;</span><br><span class="line">      &#125; else if (streamAllocation.codec() != null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Closing the body of &quot; + response</span><br><span class="line">            + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      request = followUp;</span><br><span class="line">      priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其实顾名思义，我们可以从它的名字就看出来它的作用就是在失败时进行重试，以及遇到重定向后决定是否进行后续请求。</p>
<h5 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h5><p>BridgeInterceptor所做的事情很多，它可以说是将一些必要的Header都加入到了请求报文当中。它的Intercept方法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    if (body != null) &#123;</span><br><span class="line">      MediaType contentType = body.contentType();</span><br><span class="line">      if (contentType != null) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      long contentLength = body.contentLength();</span><br><span class="line">      if (contentLength != -1) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Host&quot;) == null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Connection&quot;) == null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also decompressing</span><br><span class="line">    // the transfer stream.</span><br><span class="line">    boolean transparentGzip = false;</span><br><span class="line">    if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;</span><br><span class="line">      transparentGzip = true;</span><br><span class="line">      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    if (!cookies.isEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line"></span><br><span class="line">    if (transparentGzip</span><br><span class="line">        &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))</span><br><span class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody = new GzipSource(networkResponse.body().source());</span><br><span class="line">      Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">          .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">          .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">          .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      String contentType = networkResponse.header(&quot;Content-Type&quot;);</span><br><span class="line">      responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseBuilder.build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，BridgeInterceptor将请求报文的长度，以及能够接收传输的方法（分块），以及请求报文内容的格式等都加入了，需要特别注意的是，这里也加入了<em>保持长连接</em> 与 <em>可接收压缩格式</em> 的Header，在加入可接受压缩格式的Header的同时，它也在获得返回报文后对报文进行了解压，也就是说，如果返回报文没有经过BridgeInterceptor的话，我们看到的将是压缩的响应报文。</p>
<h5 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h5><p>CacheInterceptor可以说是在真正地进行网络请求时的最后一重关卡，如果发现当前请求报文所请求的数据已经请求过了并存放在Cache当中，那么将会直接使用Cache（缓存）中的数据进行返回，它的Intercept方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    Response cacheCandidate = cache != null</span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : null;</span><br><span class="line"></span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">      cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we&apos;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">    if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">      return new Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(504)</span><br><span class="line">          .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-1L)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we don&apos;t need the network, we&apos;re done.</span><br><span class="line">    if (networkRequest == null) &#123;</span><br><span class="line">      return cacheResponse.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.</span><br><span class="line">      if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we have a cache response too, then we&apos;re doing a conditional get.</span><br><span class="line">    if (cacheResponse != null) &#123;</span><br><span class="line">      if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">        networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">        // Update the cache after combining headers but before stripping the</span><br><span class="line">        // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">        cache.trackConditionalCacheHit();</span><br><span class="line">        cache.update(cacheResponse, response);</span><br><span class="line">        return response;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">      if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        // Offer this request to the cache.</span><br><span class="line">        CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">        return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          cache.remove(networkRequest);</span><br><span class="line">        &#125; catch (IOException ignored) &#123;</span><br><span class="line">          // The cache cannot be written.</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们需要注意的是，我们如果需要让CacheInterceptor发挥作用，那么我们必须手动配置Cache，且OkHttp中存在着两个Cache（Cache与InteralCache），只能选择配置其中的一个。</p>
<h5 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h5><p>在ConnectInterceptor中，会开始建立真正的连接，具体是TCP连接还是TLS连接则需要看具体的网络请求。</p>
<p>它的Intercept方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    // We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">    boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="networkInterceptors-自定义）"><a href="#networkInterceptors-自定义）" class="headerlink" title="networkInterceptors(自定义）"></a>networkInterceptors(自定义）</h5><p>这里也是添加自定义的拦截器，添加方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.addNetworkInterceptor(new Interceptor() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public okhttp3.Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).build();</span><br></pre></td></tr></table></figure>
<p>与之前的自定义拦截器不同的是，这个拦截器可以看到最完整的请求报文与最原始的响应报文</p>
<h5 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h5><p>这个拦截器是请求报文的最后一个拦截器，也是响应报文的第一个拦截器，它是真正与服务器进行交互的拦截器，它负责请求与响应的I/O工作，Intercept方法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">    long sentRequestMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class="line">    httpCodec.writeRequestHeaders(request);</span><br><span class="line">    realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = null;</span><br><span class="line">    if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123;</span><br><span class="line">      // If there&apos;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span><br><span class="line">      // Continue&quot; response before transmitting the request body. If we don&apos;t get that, return</span><br><span class="line">      // what we did get (such as a 4xx response) without ever transmitting the request body.</span><br><span class="line">      if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123;</span><br><span class="line">        httpCodec.flushRequest();</span><br><span class="line">        realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">        responseBuilder = httpCodec.readResponseHeaders(true);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (responseBuilder == null) &#123;</span><br><span class="line">        // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">        realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">        long contentLength = request.body().contentLength();</span><br><span class="line">        CountingSink requestBodyOut =</span><br><span class="line">            new CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line"></span><br><span class="line">        request.body().writeTo(bufferedRequestBody);</span><br><span class="line">        bufferedRequestBody.close();</span><br><span class="line">        realChain.eventListener()</span><br><span class="line">            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">      &#125; else if (!connection.isMultiplexed()) &#123;</span><br><span class="line">        // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, prevent the HTTP/1 connection</span><br><span class="line">        // from being reused. Otherwise we&apos;re still obligated to transmit the request body to</span><br><span class="line">        // leave the connection in a consistent state.</span><br><span class="line">        streamAllocation.noNewStreams();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    httpCodec.finishRequest();</span><br><span class="line"></span><br><span class="line">    if (responseBuilder == null) &#123;</span><br><span class="line">      realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">      responseBuilder = httpCodec.readResponseHeaders(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(streamAllocation.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    int code = response.code();</span><br><span class="line">    if (code == 100) &#123;</span><br><span class="line">      // server sent a 100-continue even though we did not request one.</span><br><span class="line">      // try again to read the actual response</span><br><span class="line">      responseBuilder = httpCodec.readResponseHeaders(false);</span><br><span class="line"></span><br><span class="line">      response = responseBuilder</span><br><span class="line">              .request(request)</span><br><span class="line">              .handshake(streamAllocation.connection().handshake())</span><br><span class="line">              .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      code = response.code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    realChain.eventListener()</span><br><span class="line">            .responseHeadersEnd(realChain.call(), response);</span><br><span class="line"></span><br><span class="line">    if (forWebSocket &amp;&amp; code == 101) &#123;</span><br><span class="line">      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .build();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .body(httpCodec.openResponseBody(response))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))</span><br><span class="line">        || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) &#123;</span><br><span class="line">      streamAllocation.noNewStreams();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123;</span><br><span class="line">      throw new ProtocolException(</span><br><span class="line">          &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android网络开发</category>
      </categories>
  </entry>
  <entry>
    <title>Android绘制流程总结</title>
    <url>/2018/08/25/Android%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>我们在自定义实现一个自定义view的时候，往往需要重写它的onDraw()方法，在这个方法中，我们可以获取到它的Canvas对象，那么，这个Canvas对象是怎么得到的呢？</p>
<p>首先我们知道Activity的视图是由一个Window来进行显示的，具体来说是一个Phone Window对象，而每个窗口又都会包含一个Surface，而Canvas就是由这个得到的，具体流程如下：</p>
<ol>
<li>当窗口需要绘制UI时，调用关联的Surface的lockCanvas方法获得Canvas</li>
<li>获得Canvas后将调用View.draw()方法将内容绘制到Canvas上</li>
<li>第二步完成之后，调用unLockCanvasAndPost方法将Canvas显示到屏幕上</li>
</ol>
<p>而我们最需要关心的是第二步中View.draw()方法，因为在它里面调用了我们熟悉的onDraw（）方法以及平常不被注意的一些方法，我们先来看它的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">        final int privateFlags = mPrivateFlags;</span><br><span class="line">        final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">                (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">        mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Draw traversal performs several drawing steps which must be executed</span><br><span class="line">         * in the appropriate order:</span><br><span class="line">         *</span><br><span class="line">         *      1. Draw the background</span><br><span class="line">         *      2. If necessary, save the canvas&apos; layers to prepare for fading</span><br><span class="line">         *      3. Draw view&apos;s content</span><br><span class="line">         *      4. Draw children</span><br><span class="line">         *      5. If necessary, draw the fading edges and restore layers</span><br><span class="line">         *      6. Draw decorations (scrollbars for instance)</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        // Step 1, draw the background, if needed</span><br><span class="line">        int saveCount;</span><br><span class="line"></span><br><span class="line">        if (!dirtyOpaque) &#123;</span><br><span class="line">            drawBackground(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // skip step 2 &amp; 5 if possible (common case)</span><br><span class="line">        final int viewFlags = mViewFlags;</span><br><span class="line">        boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;</span><br><span class="line">        boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;</span><br><span class="line">        if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">            // Step 3, draw the content</span><br><span class="line">            if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">            // Step 4, draw the children</span><br><span class="line">            dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            // Overlay is part of the content and draws beneath Foreground</span><br><span class="line">            if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Step 6, draw decorations (foreground, scrollbars)</span><br><span class="line">            onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">            // Step 7, draw the default focus highlight</span><br><span class="line">            drawDefaultFocusHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            if (debugDraw()) &#123;</span><br><span class="line">                debugDrawFocus(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // we&apos;re done...</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Here we do the full fledged routine...</span><br><span class="line">         * (this is an uncommon case where speed matters less,</span><br><span class="line">         * this is why we repeat some of the tests that have been</span><br><span class="line">         * done above)</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        boolean drawTop = false;</span><br><span class="line">        boolean drawBottom = false;</span><br><span class="line">        boolean drawLeft = false;</span><br><span class="line">        boolean drawRight = false;</span><br><span class="line"></span><br><span class="line">        float topFadeStrength = 0.0f;</span><br><span class="line">        float bottomFadeStrength = 0.0f;</span><br><span class="line">        float leftFadeStrength = 0.0f;</span><br><span class="line">        float rightFadeStrength = 0.0f;</span><br><span class="line"></span><br><span class="line">        // Step 2, save the canvas&apos; layers</span><br><span class="line">        int paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">        final boolean offsetRequired = isPaddingOffsetRequired();</span><br><span class="line">        if (offsetRequired) &#123;</span><br><span class="line">            paddingLeft += getLeftPaddingOffset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int left = mScrollX + paddingLeft;</span><br><span class="line">        int right = left + mRight - mLeft - mPaddingRight - paddingLeft;</span><br><span class="line">        int top = mScrollY + getFadeTop(offsetRequired);</span><br><span class="line">        int bottom = top + getFadeHeight(offsetRequired);</span><br><span class="line"></span><br><span class="line">        if (offsetRequired) &#123;</span><br><span class="line">            right += getRightPaddingOffset();</span><br><span class="line">            bottom += getBottomPaddingOffset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ScrollabilityCache scrollabilityCache = mScrollCache;</span><br><span class="line">        final float fadeHeight = scrollabilityCache.fadingEdgeLength;</span><br><span class="line">        int length = (int) fadeHeight;</span><br><span class="line"></span><br><span class="line">        // clip the fade length if top and bottom fades overlap</span><br><span class="line">        // overlapping fades produce odd-looking artifacts</span><br><span class="line">        if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</span><br><span class="line">            length = (bottom - top) / 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // also clip horizontal fades if necessary</span><br><span class="line">        if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</span><br><span class="line">            length = (right - left) / 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (verticalEdges) &#123;</span><br><span class="line">            topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));</span><br><span class="line">            drawTop = topFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">            bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));</span><br><span class="line">            drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (horizontalEdges) &#123;</span><br><span class="line">            leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));</span><br><span class="line">            drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">            rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));</span><br><span class="line">            drawRight = rightFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        saveCount = canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">        int solidColor = getSolidColor();</span><br><span class="line">        if (solidColor == 0) &#123;</span><br><span class="line">            final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">            if (drawTop) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, right, top + length, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawBottom) &#123;</span><br><span class="line">                canvas.saveLayer(left, bottom - length, right, bottom, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawLeft) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, left + length, bottom, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawRight) &#123;</span><br><span class="line">                canvas.saveLayer(right - length, top, right, bottom, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Step 3, draw the content</span><br><span class="line">        if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        // Step 4, draw the children</span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        // Step 5, draw the fade effect and restore layers</span><br><span class="line">        final Paint p = scrollabilityCache.paint;</span><br><span class="line">        final Matrix matrix = scrollabilityCache.matrix;</span><br><span class="line">        final Shader fade = scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">        if (drawTop) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * topFadeStrength);</span><br><span class="line">            matrix.postTranslate(left, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawBottom) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * bottomFadeStrength);</span><br><span class="line">            matrix.postRotate(180);</span><br><span class="line">            matrix.postTranslate(left, bottom);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(left, bottom - length, right, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawLeft) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * leftFadeStrength);</span><br><span class="line">            matrix.postRotate(-90);</span><br><span class="line">            matrix.postTranslate(left, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(left, top, left + length, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawRight) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * rightFadeStrength);</span><br><span class="line">            matrix.postRotate(90);</span><br><span class="line">            matrix.postTranslate(right, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(right - length, top, right, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">        drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">        // Overlay is part of the content and draws beneath Foreground</span><br><span class="line">        if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Step 6, draw decorations (foreground, scrollbars)</span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">        if (debugDraw()) &#123;</span><br><span class="line">            debugDrawFocus(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将View的绘制流程总结下，完整的绘制分别是以下几步：</p>
<ol>
<li>背景（private，无法重写）</li>
<li>主体（onDraw()）</li>
<li>子 View（dispatchDraw()）</li>
<li>滑动边缘渐变和滑动条</li>
<li>前景</li>
</ol>
<p>需要注意的有两点，因为我们最常重写的方法是onDraw（）方法，但是实际上onDraw方法在View中是一个空方法，如果我们是直接继承View而不是其他的子类的话，其实super.onDraw（）是可以被省略掉的，还有一点就是，dispatchDraw（）方法其实在Canvas中也是一个空方法，因为View是没有子类的，我们可以看看ViewGroup中是怎么实现它的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void dispatchDraw(Canvas canvas) &#123;</span><br><span class="line">        boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);</span><br><span class="line">        final int childrenCount = mChildrenCount;</span><br><span class="line">        final View[] children = mChildren;</span><br><span class="line">        int flags = mGroupFlags;</span><br><span class="line"></span><br><span class="line">        if ((flags &amp; FLAG_RUN_ANIMATION) != 0 &amp;&amp; canAnimate()) &#123;</span><br><span class="line">            final boolean buildCache = !isHardwareAccelerated();</span><br><span class="line">            for (int i = 0; i &lt; childrenCount; i++) &#123;</span><br><span class="line">                final View child = children[i];</span><br><span class="line">                if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;</span><br><span class="line">                    final LayoutParams params = child.getLayoutParams();</span><br><span class="line">                    attachLayoutAnimationParameters(child, params, i, childrenCount);</span><br><span class="line">                    bindLayoutAnimation(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final LayoutAnimationController controller = mLayoutAnimationController;</span><br><span class="line">            if (controller.willOverlap()) &#123;</span><br><span class="line">                mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            controller.start();</span><br><span class="line"></span><br><span class="line">            mGroupFlags &amp;= ~FLAG_RUN_ANIMATION;</span><br><span class="line">            mGroupFlags &amp;= ~FLAG_ANIMATION_DONE;</span><br><span class="line"></span><br><span class="line">            if (mAnimationListener != null) &#123;</span><br><span class="line">                mAnimationListener.onAnimationStart(controller.getAnimation());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int clipSaveCount = 0;</span><br><span class="line">        final boolean clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;</span><br><span class="line">        if (clipToPadding) &#123;</span><br><span class="line">            clipSaveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);</span><br><span class="line">            canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,</span><br><span class="line">                    mScrollX + mRight - mLeft - mPaddingRight,</span><br><span class="line">                    mScrollY + mBottom - mTop - mPaddingBottom);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We will draw our child&apos;s animation, let&apos;s reset the flag</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION;</span><br><span class="line">        mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED;</span><br><span class="line"></span><br><span class="line">        boolean more = false;</span><br><span class="line">        final long drawingTime = getDrawingTime();</span><br><span class="line"></span><br><span class="line">        if (usingRenderNodeProperties) canvas.insertReorderBarrier();</span><br><span class="line">        final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size();</span><br><span class="line">        int transientIndex = transientCount != 0 ? 0 : -1;</span><br><span class="line">        // Only use the preordered list if not HW accelerated, since the HW pipeline will do the</span><br><span class="line">        // draw reordering internally</span><br><span class="line">        final ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties</span><br><span class="line">                ? null : buildOrderedChildList();</span><br><span class="line">        final boolean customOrder = preorderedList == null</span><br><span class="line">                &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">        for (int i = 0; i &lt; childrenCount; i++) &#123;</span><br><span class="line">            while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;</span><br><span class="line">                final View transientChild = mTransientViews.get(transientIndex);</span><br><span class="line">                if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                        transientChild.getAnimation() != null) &#123;</span><br><span class="line">                    more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">                &#125;</span><br><span class="line">                transientIndex++;</span><br><span class="line">                if (transientIndex &gt;= transientCount) &#123;</span><br><span class="line">                    transientIndex = -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">            if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123;</span><br><span class="line">                more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (transientIndex &gt;= 0) &#123;</span><br><span class="line">            // there may be additional transient views after the normal views</span><br><span class="line">            final View transientChild = mTransientViews.get(transientIndex);</span><br><span class="line">            if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                    transientChild.getAnimation() != null) &#123;</span><br><span class="line">                more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">            &#125;</span><br><span class="line">            transientIndex++;</span><br><span class="line">            if (transientIndex &gt;= transientCount) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (preorderedList != null) preorderedList.clear();</span><br><span class="line"></span><br><span class="line">        // Draw any disappearing views that have animations</span><br><span class="line">        if (mDisappearingChildren != null) &#123;</span><br><span class="line">            final ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren;</span><br><span class="line">            final int disappearingCount = disappearingChildren.size() - 1;</span><br><span class="line">            // Go backwards -- we may delete as animations finish</span><br><span class="line">            for (int i = disappearingCount; i &gt;= 0; i--) &#123;</span><br><span class="line">                final View child = disappearingChildren.get(i);</span><br><span class="line">                more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (usingRenderNodeProperties) canvas.insertInorderBarrier();</span><br><span class="line"></span><br><span class="line">        if (debugDraw()) &#123;</span><br><span class="line">            onDebugDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (clipToPadding) &#123;</span><br><span class="line">            canvas.restoreToCount(clipSaveCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // mGroupFlags might have been updated by drawChild()</span><br><span class="line">        flags = mGroupFlags;</span><br><span class="line"></span><br><span class="line">        if ((flags &amp; FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) &#123;</span><br><span class="line">            invalidate(true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((flags &amp; FLAG_ANIMATION_DONE) == 0 &amp;&amp; (flags &amp; FLAG_NOTIFY_ANIMATION_LISTENER) == 0 &amp;&amp;</span><br><span class="line">                mLayoutAnimationController.isDone() &amp;&amp; !more) &#123;</span><br><span class="line">            // We want to erase the drawing cache and notify the listener after the</span><br><span class="line">            // next frame is drawn because one extra invalidate() is caused by</span><br><span class="line">            // drawChild() after the animation is over</span><br><span class="line">            mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;</span><br><span class="line">            final Runnable end = new Runnable() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void run() &#123;</span><br><span class="line">                   notifyAnimationListener();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            post(end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，ViewGrup在dispatchDraw方法中调用了drawChild方法，而drawChild方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123;</span><br><span class="line">        return child.draw(canvas, this, drawingTime);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其实里面就是调用了子View的draw方法，这实际上是一个递归的过程。</p>
<p>总结Window绘制UI的流程如下：</p>
<ol>
<li>通过Surface获得Canvas对象</li>
<li>调用Draw方法递归地绘制（View则绘制自身，ViewGroup则绘制自身和子View）</li>
<li>显示UI</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Lock接口实现解析：到底什么是非重入锁和可重入锁</title>
    <url>/2018/08/12/Lock%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/</url>
    <content><![CDATA[<p>Java中接口的实现只给了ReentrantLock这一个默认的实现，也就是重入锁，它的概念是在获得锁后可以重复获得该资源的锁，但是这是一个听起来很绕的概念，重复获得该资源的锁是什么意思？如果不能获得，也就是这个锁是不可重入的，又会是怎么样的呢？请看下文</p>
<h4 id="重入锁与不可重入锁的区别"><a href="#重入锁与不可重入锁的区别" class="headerlink" title="重入锁与不可重入锁的区别"></a>重入锁与不可重入锁的区别</h4><p>先给出结论：</p>
<blockquote>
<p>重入锁是可重复获得资源的锁，已经获得锁的线程可以对当前的资源重入加锁而不会引起阻塞；不可重入锁是不可重复获得资源的锁，当已经获得锁的线程对当前资源再次加锁时，会把自己阻塞。</p>
</blockquote>
<h5 id="重入锁与不可重入锁区别的本质：AQS-AbstractQueuedSynchronizer-的实现"><a href="#重入锁与不可重入锁区别的本质：AQS-AbstractQueuedSynchronizer-的实现" class="headerlink" title="重入锁与不可重入锁区别的本质：AQS(AbstractQueuedSynchronizer)的实现"></a>重入锁与不可重入锁区别的本质：AQS(AbstractQueuedSynchronizer)的实现</h5><p>Lock接口为我们提供了两个获取锁的方法，一个是tryLock()，另一个是Lock()方法，tryLock()方法是不会引起阻塞的，而Lock方法在无法获得锁的情况下，会将自己挂起。首先，我们来看看重入锁中Lock方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">            acquire(1);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在这里可以看到，他调用了acquire方法，这个方法的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这里可以看到，它首先进行了!tryAcquire(arg)的操作，然后再进行后续操作，但实际上在&amp;&amp;后面的判断是由AQS来完成的，意思就是将当前的线程包装成一个Node然后加入到同步队列中去。在这里我们只关心tryAcquire方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在ReentrantLock中tryAcquire的方法如下，先获得当前AQS的state，当state为0时代表现在没有线程获得这个锁，当前线程就可以获得这个锁，并返回true表示锁是可获得的，<em>但是后面还有一个判断，就是当state不为0，但是是当前的线程获得的锁的话，也是返回true，这里其实就是重入锁实现的关键</em> 。如果我们自己重写Lock接口，在继承AQS并重写的时候不做这个判断，得到的就是一个不可重入锁。可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这样就是一个不可重入锁的结构，因为已获得锁的线程再次尝试获得锁的话会返回false，在acquire方法中就会将自己阻塞。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>不可重入锁与重入锁的区别实质其实就是在tryAcquire方法中，如果不对是否是当前的线程持有的锁进行判断，而直接返回false的话，它就是一个不可重入锁，反之，如果进行了判断，则是可重入锁。tryAcquire方法中返回true表示当前锁是可获得的，返回false则表示当前锁不可获得。</p>
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
  </entry>
  <entry>
    <title>synchronized关键字与volatile原理浅析</title>
    <url>/2018/08/05/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8Evolatile%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p>synchronized关键字与volatile关键字可以说是Java多线程的基础，无论是各种同步锁，还是我们所遇到的线程安全问题，都与这两个关键字有联系。</p>
<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><p>Synchronized关键字我们经常用来执行线程间的互斥操作，使用示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x;</span><br><span class="line">public synchronized void setX(int x) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例十分地简单，如果两个线程访问这个函数，他们是互斥的访问的，Synchronized关键字在这里对函数进行了类似原子操作的包装，在JMM（Java memory model）里面，Synchronized操作是这样的，当线程允许到使用Synchronized关键字修饰的代码时，它会先获取到Synchronized函数所对应的Monitor对象，如果两个线程获取到的需要获取同一个Monitor对象时，他们之间就会互斥。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">public synchronized void setX(int x) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void setY(int y) &#123;</span><br><span class="line">    this.y = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，如果线程A在执行setX函数，而线程B在执行setY函数，他们之间也是互斥地进行的，因为他们所需要获取到的Monitor是同一个。</p>
<p>那有没有办法让两条线程不互斥地进行呢？因为两个函数当中资源并没有抢占的情况，所以，我们可以这样解决:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line"></span><br><span class="line">private final Object object1 = new Object();</span><br><span class="line">private final Object object2 = new Object();</span><br><span class="line"></span><br><span class="line">public void setX(int x) &#123;</span><br><span class="line">    synchronized (object1) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void setY(int y) &#123;</span><br><span class="line">    synchronized (object2) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样A线程访问setX与B线程访问setY是不会互斥的，因为他们所需要获得的Monitor不是同一个。</p>
<h4 id="Synchronize关键字与工作内存和共享内存"><a href="#Synchronize关键字与工作内存和共享内存" class="headerlink" title="Synchronize关键字与工作内存和共享内存"></a>Synchronize关键字与工作内存和共享内存</h4><p>从线程角度来说，内存可分为两种，一种是线程内的工作内存，另一种是线程间的共享内存，当使用Synchronized的时候，它主要做了三件事</p>
<ol>
<li>在执行之前，到共享内存读取到所需变量</li>
<li>读取变量之后，其他线程无法再对此变量进行操作（其他线程将采取自旋或阻塞的方式等待）</li>
<li>函数结束之后，将该变量的值刷新并解除锁定</li>
</ol>
<h5 id="锁的四种状态"><a href="#锁的四种状态" class="headerlink" title="锁的四种状态"></a>锁的四种状态</h5><p>在Synchronizationd中的锁是隐式锁，在Java对它进行优化之后，它是会进行自动升级的，升级的阶段有四个，分别如下：</p>
<ul>
<li>无锁</li>
<li>偏向锁</li>
<li>轻量级锁</li>
<li>重量级锁</li>
</ul>
<p>其中偏向锁是Synchronizationd关键字所做的优化，它将获取锁的代价降到了最低，但是只适合单线程使用，当发生竞争时，偏向锁会升级成轻量级锁，这时如果锁已经被持有，则线程就会采取自旋的方式等待（自旋其实就是循环），如果竞争再升级，就会升级成重量级锁，这时如果再要获取锁，就会采取阻塞的方式等待。</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile关键字所做的事情其实就是在改变volatile所修饰的变量时，它是会强制刷新到共享内存的，我们可以这样理解，volatile的每一步操作都和包裹在synchronized代码块中一样，但是！特别需要注意的是，这里的每一步并不是指的一行代码，而是指的每一步原子操作。</p>
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
  </entry>
  <entry>
    <title>Android事件分发机制总结</title>
    <url>/2018/07/30/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>Android中的事件分发机制是我们实现触摸反馈、拦截等等的基础，了解了事件分发机制，对于触摸反馈事件失灵、多点触控等等的实现和疑难解决，都有一个敏感的认知。</p>
</blockquote>
<h4 id="一切的开始-Activity的处理"><a href="#一切的开始-Activity的处理" class="headerlink" title="一切的开始: Activity的处理"></a>一切的开始: Activity的处理</h4><p>当我们的Android手机接收到手指的触摸动作的时候，手机会把这个动作包装成 <em>MotionEvent</em> ，之后这个 <em>MotionEvent</em> 事件会首先被Activity处理，源码如下：</p>
<p><img src="https://i.loli.net/2018/07/30/5b5f15e0bc0e6.png" alt="1.png"></p>
<p>从这里可以看到，首先这个事件会被Activity的 <em>dispatchTouchEvent</em> 处理，如果这个 <em>dispatchTouchEvent</em> 返回了true，则代表事件被消费了，如果这个事件没有被消费，则会被Activity中的 <em>onTouchEvent</em> 处理。</p>
<h4 id="ViewGroup与View的dispatchTouchEvent"><a href="#ViewGroup与View的dispatchTouchEvent" class="headerlink" title="ViewGroup与View的dispatchTouchEvent"></a>ViewGroup与View的dispatchTouchEvent</h4><p>在Activity中，事件是先被getWindow的superDispatchTouchEven方法处理掉的，那么这个superDispatchTouchEvent方法干了什么呢？其实就是把这个事件交给DecorView处理，然后DecorView再把这个事件通过自己的dispatch方法来进行传递，具体逻辑可用这段伪代码表示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">            return super.dispatchTouchEvent(ev);</span><br><span class="line">        &#125;</span><br><span class="line">        if (touchTargets == null) &#123;</span><br><span class="line">            return super.dispatchTouchEvent(ev);</span><br><span class="line">        &#125;  else &#123;</span><br><span class="line">            //遍历touchTargets，寻找能够处理这个事件的view</span><br><span class="line">            if (view.dispatchTouchEvent(ev)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return super.dispatchTouchEvent(ev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先，<em>ViewGroup</em> 会使用自己的 <em>onInterceptTouchEvent</em> 方法来判断是否要拦截这个事件，如果要拦截（即方法返回true),则使用自己的 <em>super.onTouchEvent</em> 方法进行处理，如果不拦截，则查看这个点击事件是否落在了它包含的某个View上（这是用TouchTargets来记录的，TouchTargets我们可以认为是一个链表结构，用来记录每个view的被点击位置），遍历TouchTargets就可以得到被点击的具体是那个View，然后调用这个View的 <em>dispatchTouchEvent</em> 来对它进行处理，如果事件还是没有被消费或者没有被点击的view，则调用 <em>super.dispatchTouchEvent</em> 进行处理。</p>
<p>看到这里可能就有些懵了，view的dispatchTouchEvent和super.dispatchTouchEvent，看着就烦心，其实，这两个的具体实现是一样的，因为ViewGroup的父类就是View，而View的dispatchTouchEvent方法可用如下伪代码表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (null == onTouchListener) &#123;</span><br><span class="line">            return onTouchEvent(ev);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (onTouchListener.onTouchEvent(ev)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先View的dispatchTouchEvent方法会先检查有没有设置OnTouchListener，如果设置了，则先用OnTouchListener来对这个事件进行处理，处理后事件没有被消费，则再调用自己的onTouchEvent对事件进行处理，如果没有设置OnTouchListener，则直接调用OnTouchEvent进行处理。</p>
<p>如果ViewGroup里面包含的不是View而是ViewGroup呢？ 那就是相当于一个递归调用了，就是再把事件交给里面的ViewGroup处理的过程了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>事件分发概括为：</p>
<ul>
<li>Activity把事件传递给Window，Window再把事件交给包裹的ViewGroup</li>
<li>ViewGroup通过DispatchTouchEvent方法对事件进行分发<ul>
<li>使用OnIntercept方法判断是否对事件进行拦截， 拦截则直接调用super.dispatchTouchEvent方法（即View的dispatchTouchEvent）</li>
<li>不拦截则查看有没有包裹的view能处理这个事件，有则调用这个View的dispatchTouchEvent进行处理</li>
<li>没有View对事件进行处理，则调用super.dispatchTouchEvent处理并返回</li>
</ul>
</li>
<li>没有View或ViewGroup消费事件，事件最终由Activity.onTouchEvent处理</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Https连接建立过程</title>
    <url>/2018/07/15/Https%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>Https的全称是Http over SSL，而SSL是在TCP协议之上的保密层，但是它也是属于传输层的，如果直接传输Http，报文的信息安全是无法被保障的，因为它在应用层的信息传输是明文传输的。</p>
</blockquote>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>Https传输建立的过程可以分为两个过程，信任建立的过程和连接建立的过程，如果再细分可以分为九个步骤，分别是：</p>
<ol>
<li>Client Hello</li>
<li>Server Hello</li>
<li>服务端向客户端发送CA证书</li>
<li>客服端发送Pre-master Secret</li>
<li>客户端发送消息：将使用加密通信</li>
<li>客户端发送：Finished</li>
<li>服务器发送消息：将使用加密通信</li>
<li>服务端发送：Finished</li>
<li>连接正式建立，发送正式报文</li>
</ol>
<h4 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h4><p><img src="https://i.loli.net/2018/07/15/5b4b1028c325e.png" alt="https1.PNG"></p>
<p>客户端首先会给服务器发送Client Hello， Client Hello中主要包含了以下这几个消息：</p>
<ul>
<li>客户端可以使用的SSL/TLS版本</li>
<li>Ciper Suites</li>
<li>服务器名称</li>
<li><em>客户端随机数</em></li>
</ul>
<p>其中Ciper Suites其实就是Ciper Suite的集合，也就是说Ciper Suites包含了一个或多个Ciper Suite，那么Ciper Suite到底是什么呢？其实就是对称加密算法，非对称加密算法和Hash算法的一个组合，下面就是一个例子</p>
<p>Ciper Suite：<em>AES_RSA_SHA1</em></p>
<p>Ciper Suites就是几个Ciper Suite的集合，像这样：</p>
<p><em>AES_RSA_SHA1</em>、<em>DES_DSA_MD5</em>、<em>AES_RSA_MD5</em></p>
<h4 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h4><p><img src="https://i.loli.net/2018/07/15/5b4b1028d5f2e.png" alt="https2.PNG"></p>
<p>客户端收到服务器收到的这一系列消息之后，它会从客户端发送的Ciper Suites中挑选出一个Ciper Suite和SSL/TLS版本，然后和自己生成的客户端随机数一起发送给客户端，就是这几个部分：</p>
<ul>
<li>服务器挑选出的SSL/TLS版本</li>
<li>服务端挑选出的Ciper Suite</li>
<li><em>服务端随机数</em></li>
</ul>
<h4 id="服务端CA证书验证"><a href="#服务端CA证书验证" class="headerlink" title="服务端CA证书验证"></a>服务端CA证书验证</h4><p><img src="https://i.loli.net/2018/07/15/5b4b1028d6371.png" alt="https3.PNG"></p>
<p>服务端得向客户端证明自己就是刚刚客户端发送消息的那个服务器，而CA证书里面就包含了这样的信息，需要注意的是，服务端发送给客户端的证书包含的信息并不只是证书本身，也包含了给它发证的签发机构的信息。证书包含的信息大概如下：</p>
<ul>
<li>本身信息<ul>
<li>证书信息（域名等）</li>
<li>证书公钥</li>
<li>证书签名算法</li>
<li>证书签名</li>
</ul>
</li>
<li>签发机构证书信息<ul>
<li>证书信息</li>
<li>签发机构公钥</li>
<li>签发机构签名算法</li>
<li>签发机构的签发机构</li>
</ul>
</li>
</ul>
<p>验证证书的过程是这样的：</p>
<ol>
<li>证书对自身的证书信息使用证书的签名算法做一个Hash</li>
<li>利用签发机构的公钥去对步骤1得到的信息做一次验证，如果验证成功则说明CA证书本身的信息是可信赖的，但签发机构自身还需要验证自己是可信赖但</li>
<li>用客户端自身的证书公钥去对2得到的信息做验证，验证成功则说明证书的签发机构是可信赖的，服务端与客户端的信任就建立起来了，如果验证失败则需要进行提示，如是否信任此证书等等</li>
</ol>
<blockquote>
<p>有些机构，如银行等，可能会对客户端也做一次验证，大致过程和服务端验证相似</p>
</blockquote>
<h4 id="客户端发送Pre-master-Secret"><a href="#客户端发送Pre-master-Secret" class="headerlink" title="客户端发送Pre-master Secret"></a>客户端发送Pre-master Secret</h4><p><img src="https://i.loli.net/2018/07/15/5b4b1028dabe6.png" alt="https4.PNG"></p>
<p>Pre-master Secret是由客户端通过自身信息算出来的，客户端将会把Pre-master Secret使用刚刚在证书中获得的证书公钥加密后发送给服务器，服务器收到Pre-master后，客户端和服务器都将协商出一个Master Secret, 因为客户端和服务器都拥有 <em>客户端随机数、服务器随机数、Pre-Master Secret</em>,如图所示</p>
<p><img src="https://i.loli.net/2018/07/15/5b4b1028e8d11.png" alt="https5.PNG"></p>
<p>得到Master Secret之后客户端和服务器将使用 <em>Ciper Suite和Master Secret</em>一起计算出<em>客户端密钥和服务端密钥以及客户端MAC Secret和服务器MAC Secret</em>，如图：</p>
<p><img src="https://i.loli.net/2018/07/15/5b4b1028e8da5.png" alt="https6.PNG"></p>
<p>做完这步之后客户端和服务器会继续建立通信</p>
<h4 id="客户端通知：将使用加密通信"><a href="#客户端通知：将使用加密通信" class="headerlink" title="客户端通知：将使用加密通信"></a>客户端通知：将使用加密通信</h4><p>这里其实仅仅只是发送了一个几字节的通知而已，客户端告诉服务器将使用加密通信</p>
<p><img src="https://i.loli.net/2018/07/15/5b4b1028e92ae.png" alt="https7.PNG"></p>
<h4 id="客户端发送Finished消息"><a href="#客户端发送Finished消息" class="headerlink" title="客户端发送Finished消息"></a>客户端发送Finished消息</h4><p><img src="https://i.loli.net/2018/07/15/5b4b1028e9688.png" alt="https8.PNG"></p>
<p>在这里客户端将发送一个Finished消息，这个Finished消息实际上是对上述客户端与服务端发送的消息的一个汇总，用来使服务器来验证客户端是不是刚刚建立信任的客户端，Finished消息结果了两步加工：</p>
<ol>
<li>使用HMAC对消息进行HASH</li>
<li>使用客户端密钥对消息进行加密</li>
</ol>
<blockquote>
<p>HMAC是在获得了客户端MAC Secret和服务端MAC Secret后服务器和客户端都得到的HASH算法</p>
</blockquote>
<p>服务端在收到客户端发送的Finished消息后将对消息进行验证，步骤如下：</p>
<ol>
<li>服务端对之前所有的消息也做一个HMAC</li>
<li>服务端对客户端发送过来的Finished消息进行解密（因为服务端也有客户端密钥)</li>
<li>服务端对1和2得到的消息进行比对，如果一样则说明发送消息的客户端是之前建立起信任的客户端，将进行之后步骤</li>
</ol>
<h4 id="服务器发送将使用加密通信和Finished消息"><a href="#服务器发送将使用加密通信和Finished消息" class="headerlink" title="服务器发送将使用加密通信和Finished消息"></a>服务器发送将使用加密通信和Finished消息</h4><p>这两个步骤其实跟前面客户端发送加密通信和Finished消息是一样的，所有这里就略过了</p>
<h4 id="客户端发送正式的报文"><a href="#客户端发送正式的报文" class="headerlink" title="客户端发送正式的报文"></a>客户端发送正式的报文</h4><p>从这个步骤开始客户端和服务器就开始正式的通信了，从应用层看发送的报文的话只会得到这是一个应用层的消息，具体的消息只能看到类似与乱码，与Http明文通信对比十分鲜明。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以用一张图来概括</p>
<p><img src="https://i.loli.net/2018/07/15/5b4b1029081d8.png" alt="https9.PNG"></p>
]]></content>
      <categories>
        <category>Android网络开发</category>
      </categories>
  </entry>
  <entry>
    <title>同步器-倒计时门闩</title>
    <url>/2018/07/08/%E5%90%8C%E6%AD%A5%E5%99%A8-%E5%80%92%E8%AE%A1%E6%97%B6%E9%97%A8%E9%97%A9/</url>
    <content><![CDATA[<p>Java中虽然提供了synchronized关键字对临界区进行线程同步访问，但是基于synchronized很难正确地编写同步代码，而倒计时门闩可以让一条或多条线程在“门口”一直等待，直到门闩的计数变量为0，线程才可以继续执行。</p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>类java.util.concurrent.CountDownLatch实现了倒计时门闩同步器，它是由一个计数变量和两个操作数组成的，这两个操作分别是“导致一条线程等待直到计数变为0”以及“递减计数变量”</p>
<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><ul>
<li><p>CountDownLatch（int count)：count是计数个数，当count的值是负数时，会抛出Exception</p>
</li>
<li><p>void await（）：除非线程被中断，否则强制调用线程一直等到计数倒数到0.中断时会抛出Exception</p>
</li>
<li><p>void countDown()：递减计数，当计数降至0时，释放所有等待线程。当该方法被调用时count已经为0，那么 <em>什么也不会发生</em></p>
</li>
<li><p>long getCount（）：返回当前的计数</p>
</li>
</ul>
<h4 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(3);</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.print(Thread.currentThread() + &quot;: in this thread latch count is &quot; + countDownLatch.getCount() + &quot;\n&quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.print(Thread.currentThread() +&quot;: after count down, latch count is &quot; + countDownLatch.getCount() + &quot;\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(3);</span><br><span class="line">        System.out.print(&quot;before latch await\n&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">            executorService.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;main thread work again\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，有三个子线程和一个主线程，主线程调用await方法之后一直等待，直到倒计时门闩中的计数变量变为0才继续执行，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before latch await</span><br><span class="line">Thread[pool-1-thread-2,5,main]: in this thread latch count is 3</span><br><span class="line">Thread[pool-1-thread-1,5,main]: in this thread latch count is 3</span><br><span class="line">Thread[pool-1-thread-2,5,main]: after count down, latch count is 2</span><br><span class="line">Thread[pool-1-thread-3,5,main]: in this thread latch count is 3</span><br><span class="line">Thread[pool-1-thread-1,5,main]: after count down, latch count is 1</span><br><span class="line">Thread[pool-1-thread-3,5,main]: after count down, latch count is 0</span><br><span class="line">main thread work again</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意的是，并不是每次都会先打印子线程中的信息，可能会出现在子线程执行完countDown（）方法之后，countLatchDown中的计数变量已经为0，主线程已经可以执行，这时cpu先执行了主线程中的print语句，之后再去执行子线程中的print语句。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
  </entry>
  <entry>
    <title>Android NDK调用不符合jni规范的so文件</title>
    <url>/2018/06/30/Android%20NDK%E8%B0%83%E7%94%A8%E4%B8%8D%E7%AC%A6%E5%90%88jni%E8%A7%84%E8%8C%83%E7%9A%84so%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>我们在使用Android静态加载so库的时候，一般都需要这个so库是符合jni命名规范的，像这样：</p>
<blockquote>
<p>Java<em>全类名</em>方法名</p>
</blockquote>
<p>但是可能会遇到一些比较特殊的情况，同事只给了你一个so库，这个so库并不是用的jni命名，除此之外，他还给了你一个so库中函数的头文件，这时候我们就需要自己再次包装这个so库了。</p>
<h4 id="建立java文件"><a href="#建立java文件" class="headerlink" title="建立java文件"></a>建立java文件</h4><p>这里建立的java文件命名可以是自定义的，而不需要遵守某种规范，所在包名也没有讲究，因为这些都是我们需要自己包装的，所以可以随意些。</p>
<p>但是，需要注意的是，虽然说函数名字可以随意，但是我们一定得先想好函数的返回值，例如要头文件中函数返回的类型可能是int，但是我们希望在java中收到的是不是int，而是经过“二次加工”的其他值，这时候就应该把返回值设为其他类型，例如，在头文件中参数类型是char<em>， 如果我们使用java直接封装的话，返回值应该为char[],若我们还要二次封装，如要判断头文件中函数返回的char </em>是不是我们想要的字符，把判断结果返回，则可以自己任意定义返回值。</p>
<p>我们刚开始最需要关心的是头文件中定义的返回值并不是jni中已存在的类型，但是如果我们需要返回给java，则需要返回的是jni中定义的类型，这些类型有些是可以通过强制转换得到的，另一些则稍微麻烦，需要通过env提供的函数来进行转换。</p>
<p>具体可以参考下面的链接：</p>
<p><a href="https://blog.csdn.net/Chuekup/article/details/8030038" target="_blank" rel="noopener">Jni中本地类型和java类型对应表</a></p>
<p>当然这之中也有可能会有特殊的情况，例如，若在cpp中返回的数据类型为void *，我们应该使用jlong返回给java。具体例子如下：</p>
<p>我在 <em>com.example.jnitest.jnicontact</em> 文件夹下建立了.java文件，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.jnitest.jnicontact;</span><br><span class="line">public class JniDefine &#123;</span><br><span class="line">    public native int p2ptest(String localId);</span><br><span class="line">    public native long getp2psession(String remoteId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="根据编写的-java文件生成-h头文件"><a href="#根据编写的-java文件生成-h头文件" class="headerlink" title="根据编写的.java文件生成.h头文件"></a>根据编写的.java文件生成.h头文件</h4><p>因为我们需要使用命令行来生成，我们需要把打开终端，进入到com.example.jnitest的上层目录，在Android studio中目录名一般为java。</p>
<blockquote>
<p>使用Android studio的话别忘了把目录切换为Project</p>
</blockquote>
<p>进入到上层目录后执行以下语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javah -jni com.example.jnitest.jnicontact.JniDefine</span><br></pre></td></tr></table></figure>
<p>这里的格式很简单，<em>javah -jni 全类名</em> 即可。</p>
<p>之后我们会在执行javah命令的目录下找到头文件,比如我这里生成的头文件名就是 <em>com_example_jnitest_jnicontact_JniDefine.h</em>，这个文件名是可以修改的，比如我这里就修改成了<em>jni_typ2p.h</em>，在下文可以看到。</p>
<h4 id="编写cpp文件，关联so库"><a href="#编写cpp文件，关联so库" class="headerlink" title="编写cpp文件，关联so库"></a>编写cpp文件，关联so库</h4><p>上一步我们已经得到了一个头文件，这时我们就需要关联so库，以及so库提供的头文件，还有刚刚我们得到的头文件了。</p>
<p>首先，我们得在main目录下新建名为cpp的目录，并将so库，so库头文件，刚刚编译得到的头文件全都放入，我的目录是这样的</p>
<p><img src="https://i.loli.net/2018/06/30/5b3728da0f680.png" alt="fadf.png"></p>
<blockquote>
<p>注意：我在cpp文件夹下新建了一个文件夹（文件夹命名与后面写的cpp文件名一致），这个文件夹又包含了两个自文件夹，include包含的是so库的头文件，lib里放的是so库，jni_typ2p.h是刚刚编译出来的头文件，Android.mk和jni_typ2p.cpp这两个文件则是我们需要新建的文件。</p>
</blockquote>
<ol>
<li>编写cpp文件</li>
</ol>
<p>添加cpp文件位置与图中位置一致即可，添加完后在cpp文件首行加上包含头文件的名字，如例子中就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;jni_typ2p.h&quot;</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">#include &quot;typ2p/include/typ2p.h&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个头文件都是我们必须在cpp文件中包含进去的，我这里添加so库的头文件使用了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是因为提供的so库是使用c语言写的，在此处可以和提供so库的同事确认下，如果是用cpp写的，则不需要这样写，直接包含即可。</p>
<p>昨晚这一步因为代码还没有与so库关联，所以我们看到的代码是没有代码提示的，所以我们在这里先不对编译出的头文件中的函数进行实现，而是先编写Android.mk文件</p>
<ol>
<li>根据所在文件目录，编写Android.mk文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">cmd-strip:=</span><br><span class="line">LOCAL_MODULE    := typ2p </span><br><span class="line">LOCAL_SRC_FILES := typ2p/lib/libtyp2p.so</span><br><span class="line">LOCAL_CFLAGS := -g -gdwarf-2</span><br><span class="line">LOCAL_CPPFLAGS := -g -gdwarf-2</span><br><span class="line">LOCAL_LDFLAGS := -Wl,--build-id</span><br><span class="line">LOCAL_LDLIBS += -landroid #动态链接库</span><br><span class="line">LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib</span><br><span class="line">LOCAL_EXPORT_C_INCLUDES:=$(LOCAL_PATH)/typ2p/include #so库头文件所在文件夹</span><br><span class="line">include $(PREBUILT_SHARED_LIBRARY) #预构建库</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">cmd-strip:=</span><br><span class="line">LOCAL_MODULE:=jni_typ2p #生成的库文件名，与文件夹名一致</span><br><span class="line">LOCAL_SRC_FILES:=jni_typ2p.cpp #我们编写的cpp文件</span><br><span class="line">LOCAL_SHARED_LIBRARIES := typ2p </span><br><span class="line">LOCAL_CFLAGS := -g</span><br><span class="line">LOCAL_LDLIBS := -llog</span><br><span class="line">LOCAL_LDLIBS += -landroid </span><br><span class="line">LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib</span><br><span class="line">LOCAL_LDFLAGS := -Wl,--build-id</span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure>
<p>这里是本项目中的Android.mk文件，Android.mk文件的具体编写可查看官方文档</p>
<p><a href="https://developer.android.com/ndk/guides/android_mk" target="_blank" rel="noopener">Android.mk官方文档</a></p>
<p>编写完Android.mk文件之后，我们就可以把so库关联起来了。</p>
<h4 id="关联so库"><a href="#关联so库" class="headerlink" title="关联so库"></a>关联so库</h4><p>关联so库的步骤比较奇怪，我们需要先把目录切换到Android,然后在项目上点击右键Link C++ Project with Gradle,操作图示如下：</p>
<p><img src="https://i.loli.net/2018/06/30/5b372f661d13a.png" alt="屏幕快照 2018-06-30 下午3.18.22.png"></p>
<p>之后添加刚刚编写的Android.mk文件即可</p>
<p><img src="https://i.loli.net/2018/06/30/5b372f9ea4d1a.png" alt="屏幕快照 2018-06-30 下午3.18.34.png"></p>
<blockquote>
<p>当然是选择ndk-build了</p>
</blockquote>
<p>做完这步之后，我们就可以在编写的cpp代码中看到提示了。</p>
<h4 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h4><p>我们还需要在本模块的gradle中增加一些配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> android &#123;</span><br><span class="line">    compileSdkVersion 27</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId &quot;com.example.jackdow.testv1demo&quot;</span><br><span class="line">        minSdkVersion 15</span><br><span class="line">        targetSdkVersion 27</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">        ndk &#123;</span><br><span class="line">            abiFilters &quot;armeabi-v7a&quot; //so库平台，一定要同事给的so库平台一致</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123; //这里包含的是调试cpp代码的选项</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">            debuggable true</span><br><span class="line">            jniDebuggable true</span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            jniDebuggable true</span><br><span class="line">            debuggable true</span><br><span class="line">            packagingOptions &#123;</span><br><span class="line">                doNotStrip &quot;**/*/*.so&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        ndkBuild &#123;</span><br><span class="line">            path &apos;src/main/cpp/Android.mk&apos; // 此处是刚刚关联so库生成的</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现cpp的小例子"><a href="#实现cpp的小例子" class="headerlink" title="实现cpp的小例子"></a>实现cpp的小例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jlong JNICALL Java_com_example_jackdow_testv1demo_jni_JniDefine_typ2popen</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring arr) &#123;</span><br><span class="line">    const char * array = env-&gt;GetStringUTFChars(arr, JNI_FALSE); //上方的参考链接中有此方法</span><br><span class="line">  jint *sesson = (int *)typ2p_open((char *) array); //typ2p_open函数是so库中的函数</span><br><span class="line">  env-&gt;ReleaseStringChars(arr, (jchar *)array);</span><br><span class="line">    if (sesson == NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    jlong result = (jlong)sesson; //void *与jlong之间可强制互转</span><br><span class="line">  return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="在java代码中加载库"><a href="#在java代码中加载库" class="headerlink" title="在java代码中加载库"></a>在java代码中加载库</h4><p>很简单，一行代码即可，注意加载库的.java文件和我们声明jni函数的文件是同一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">        System.loadLibrary(&quot;jni_typ2p&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就能像java函数一样调用之前声明的native函数了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>git flow</title>
    <url>/2018/06/03/git-flow/</url>
    <content><![CDATA[<blockquote>
<p>git flow是产品进行迭代开发时流行的工作流，在公司当中很受欢迎</p>
</blockquote>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>git flow包含了master、develop、feature、release、hotfix这五个分支，其中主要以master和develop进行分类</p>
<h5 id="master"><a href="#master" class="headerlink" title="master"></a>master</h5><p>master是已发布的产品的代码分支，不能在这个分支上直接改动，如果出现了急需修复的问题，则新建hotfix分支进行修改，之后再merge到master分支上去</p>
<ul>
<li>hotfix分支</li>
</ul>
<p>因为在增加新功能时开发代码都是在develop分支上进行的，修复时再到develop分支上开发显然是不合适的，所以我们一般都新建hotfix分支来对代码进行修复，修复完之后直接合并到主分支</p>
<blockquote>
<p>此分支合并到master分支之后也需要被合并到develop分支</p>
</blockquote>
<h5 id="develop"><a href="#develop" class="headerlink" title="develop"></a>develop</h5><p>develop分支衍生出的分支有feature和release，develop中存放的是新功能开发完毕的代码，develop中的代码不能直接合并到master分支，需要拉出release，经过测试之后再合并release到master分支上去，feature分支则是用来开发新功能的，新功能开发完毕后再合并到develop分支上去</p>
<ul>
<li>feature</li>
</ul>
<p>开发新功能的分支，新功能开发完毕后被develop分支merge，feature分支可能有多个，用来并行开发不同到功能</p>
<ul>
<li>release</li>
</ul>
<p>develop功能开发完毕之后的分支，经过测试之后被merge到master分支</p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>如下图所示：</p>
<p><img src="https://i.loli.net/2018/06/03/5b13870a74d91.png" alt="git-workflow-release-cycle-4maintenance.png"></p>
<blockquote>
<p>图片来自网络</p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>类与实例的初始化顺序</title>
    <url>/2018/04/25/Class-init/</url>
    <content><![CDATA[<blockquote>
<p>在Java中，static修饰符一直都是很重要的知识点，特别是当它修饰为一个静态代码块的时候，还有它被用来修饰变量的时候，当发生继承关系或者是内部类关系的时候，我们这里分几种情况进行讨论</p>
</blockquote>
<h4 id="当发生继承关系的时候"><a href="#当发生继承关系的时候" class="headerlink" title="当发生继承关系的时候"></a>当发生继承关系的时候</h4><p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public  class SuperClass &#123;</span><br><span class="line">    private static int superInt = 12345;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Super Class init! superInt = &quot; + superInt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Super Class non-static init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SuperClass() &#123;</span><br><span class="line">        System.out.println(&quot;SuperClass Build Method work!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final void show() &#123;</span><br><span class="line">        System.out.println(&quot;SuperClass show()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doIt() &#123;</span><br><span class="line">        System.out.println(&quot;SuperClass do it!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class SonClass extends SuperClass &#123;</span><br><span class="line">    private static  int sonInt = 987654321;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Son Class static init! sonInt = &quot; + sonInt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Son Class non-static init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SonClass() &#123;</span><br><span class="line">        System.out.println(&quot;SonClass Build Method work!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final void showT() &#123;</span><br><span class="line">        System.out.println(&quot;SonClass show()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doIt() &#123;</span><br><span class="line">        System.out.println(&quot;SonClass do it!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里定义了一个静态函数，而静态函数是属于类的，而并不属于示例，我们可以通过一下两个方式验证</p>
<ol>
<li>当使用静态函数的时候</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        SonClass.showT();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果为</p>
<p><img src="https://i.loli.net/2018/04/25/5adfe2da8ad3c.png" alt="捕获0.PNG"></p>
<ol>
<li>当new对象的时候</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        SonClass sonClass = new SonClass();</span><br><span class="line">        sonClass.doIt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果为</p>
<p><img src="https://i.loli.net/2018/04/25/5adfe3e1d37c2.png" alt="捕获1.PNG"></p>
<ol>
<li>两种情况全部存在的时候</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        SonClass.showT();</span><br><span class="line">        SonClass sonClass = new SonClass();</span><br><span class="line">        sonClass.doIt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果为</p>
<p><img src="https://i.loli.net/2018/04/25/5adfe5ca17d7b.png" alt="捕获2.PNG"></p>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>当使用静态函数的时候，先初始化父类的静态变量，然后执行父类的静态代码块，然后再是子类的静态变量，静态代码块。当我们构造出一个对象的时候，也是先进行类的初始化，同上，在初始化完静态变量后，先是执行父类的非静态变量，然后是非静态代码块，最后才是父类的构造函数，然后是子类的这个过程，具体如下：</p>
<ol>
<li>父类的静态变量及静态代码块</li>
<li>子类的静态变量及静态代码块</li>
<li>父类的非静态变量、非静态代码块、构造函数</li>
<li>子类的非静态变量、非静态代码块、构造函数</li>
</ol>
<p>这里我们还可以得出的结论有</p>
<blockquote>
<p>类的初始化只有一次，若实例化对象的时候，类已经进行了初始化，则不需要再重复进行</p>
</blockquote>
<p>还有静态常量等在程序初始化的时候就已经初始化了，这是必须知道的。</p>
<h4 id="静态内部类与非静态内部类"><a href="#静态内部类与非静态内部类" class="headerlink" title="静态内部类与非静态内部类"></a>静态内部类与非静态内部类</h4><p>静态内部类如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final class SonInner &#123;</span><br><span class="line">        private static int sonInnerInt = 5;</span><br><span class="line">        static &#123;</span><br><span class="line">            System.out.println(&quot;SonInner Class init! sonInnerInt = &quot; + sonInnerInt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static final void showI() &#123;</span><br><span class="line">            System.out.println(&quot;SonInner Class show()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个类是在SonClass中的，我们可以实验一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        SonClass.SonInner.showI();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="https://i.loli.net/2018/04/25/5adfea1778035.png" alt="捕获3.PNG"></p>
<h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><p>静态内部类的初始化不依赖外围类的初始化。</p>
<p>若是非静态内部类，则会发现在内部类中不能使用静态代码块与静态函数，只能先创建外围类再创建内部类</p>
<p>这时的初始化过程如下：</p>
<ol>
<li>先按照父类子类的顺序初始化外围类</li>
<li>初始化内部类的非静态变量、非静态代码块</li>
</ol>
<blockquote>
<p>最后还需要注意的是，我们在静态函数中只需要定义函数是static的，不需要再加final关键字修饰</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java中的正则表达式</title>
    <url>/2018/03/26/PatternAndMatcher/</url>
    <content><![CDATA[<p>Java中应用正则表达式必须依靠Pattern与Matcher类，常用的正则规范一般如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>规范</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>\</td>
<td>表示反斜线（\）字符</td>
</tr>
<tr>
<td>2</td>
<td>\t</td>
<td>表示制表符</td>
</tr>
<tr>
<td>3</td>
<td>\n</td>
<td>表示换行</td>
</tr>
<tr>
<td>4</td>
<td>[abc]</td>
<td>字符a、b或c</td>
</tr>
<tr>
<td>5</td>
<td>[^abc]</td>
<td>表示除了a、b、c之外的任意字符</td>
</tr>
<tr>
<td>6</td>
<td>[a-z]</td>
<td>表示由字母a到z组成</td>
</tr>
<tr>
<td>7</td>
<td>\d</td>
<td>表示数字</td>
</tr>
<tr>
<td>8</td>
<td>\D</td>
<td>表示非数字</td>
</tr>
<tr>
<td>9</td>
<td>\w</td>
<td>表示字母、数字、下划线</td>
</tr>
<tr>
<td>10</td>
<td>\W</td>
<td>表示非字母、数字、下划线</td>
</tr>
<tr>
<td>11</td>
<td>\s</td>
<td>表示所有空白字符（换行、空格等）</td>
</tr>
<tr>
<td>12</td>
<td>\S</td>
<td>表示所有非空白字符</td>
</tr>
<tr>
<td>13</td>
<td>^</td>
<td>行的开头</td>
</tr>
<tr>
<td>14</td>
<td>$</td>
<td>行的结尾</td>
</tr>
<tr>
<td>15</td>
<td>.</td>
<td>匹配除换行符之外的任意字符</td>
</tr>
</tbody>
</table>
<p>如果说这一组是”质”的表示的话，那下一组就是量的表示</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>规范</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>X</td>
<td>必须出现一次</td>
</tr>
<tr>
<td>2</td>
<td>X？</td>
<td>可以出现0次或1次</td>
</tr>
<tr>
<td>3</td>
<td>X*</td>
<td>可以出现0次，1次或多次</td>
</tr>
<tr>
<td>4</td>
<td>X+</td>
<td>可以出现一次或多次</td>
</tr>
<tr>
<td>5</td>
<td>X{n}</td>
<td>必须出现n次</td>
</tr>
<tr>
<td>6</td>
<td>X{n.}</td>
<td>必须出现n次以上</td>
</tr>
<tr>
<td>7</td>
<td>X{n,m}</td>
<td>必须出现n~m次</td>
</tr>
</tbody>
</table>
<p>上面两组之后，就是逻辑运算符了，我们可以使用逻辑运算符来筛选更丰富的正则规范</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>规范</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>XY</td>
<td>既满足X规范又满足Y规范</td>
</tr>
<tr>
<td>2</td>
<td>X1Y</td>
<td>X规范或Y规范</td>
</tr>
<tr>
<td>3</td>
<td>（X）</td>
<td>作为一个捕获组规范</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>匹配的字符串</th>
<th>不匹配的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>(A1B)(C1D)</td>
<td>AC AD BC BD</td>
<td>其他所有字符串</td>
</tr>
<tr>
<td>A(B1C)*D</td>
<td>AD ABD ACD ABCCBD</td>
<td>BCD ADD ABCBC</td>
</tr>
<tr>
<td>A<em>1(A</em>BA<em>BA</em>)*</td>
<td>AAA BBAABB BABAAA</td>
<td>ABA BBB BABBAAA</td>
</tr>
</tbody>
</table>
<blockquote>
<p>因博客文章中表格无法正确识别”|”符号，故上述表格中”|”均用1替代</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Android编译时注解</title>
    <url>/2018/02/23/compileAnnotation/</url>
    <content><![CDATA[<blockquote>
<p>这个寒假用空闲时间做了一个基于编译时注解的RxBus，目前还没有做工程化处理，但是基本的功能已经写好，欢迎大家star和fork</p>
</blockquote>
<p><a href="https://github.com/JoshuaRogue/RxEventBus" target="_blank" rel="noopener">RxEventBus</a></p>
<p>趁着寒假最后一天来写一下开发过程。</p>
<h2 id="编译时注解总结"><a href="#编译时注解总结" class="headerlink" title="编译时注解总结"></a>编译时注解总结</h2><p>注解分为源码级注解、编译时注解与运行时注解，编译时注解和运行时注解时被经常用到的，但是运行时注解因为使用了反射机制，所以在性能上会有所降低，编译时注解就成了最受追捧的注解方式。</p>
<h3 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h3><p>既然说是编译时注解，第一步当然是写注解的模块了，步骤如下：</p>
<ol>
<li>新建java library（右键新建module）</li>
<li>编写注解，可以参考下面的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface Subscribe &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 订阅事件的线程</span><br><span class="line">     * @return 订阅线程</span><br><span class="line">     */</span><br><span class="line">    ThreadMode threadMode() default ThreadMode.MAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为我们的注解是用在函数上的，所以Target就是ElementType.METHOD，还有下面几种值可以选择</p>
</blockquote>
<p><img src="https://i.loli.net/2018/02/23/5a8fa806478e1.png" alt="XEVS(FO[`F]I67G1ZB}@ZBI.png"></p>
<p>根据需要注解的元素的类型来选择值。</p>
<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>顾名思义，注解处理器就是用来处理注解的，而且是仅用来处理编译时注解的，要实现一个编译处理器，我们也要新建一个Java library来存放注解处理器，具体步骤如下：</p>
<ol>
<li>新建Java library</li>
<li>在注解助力器的build.gradle中添加第一步所写的注解库，即</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile project(&apos;:rxeventbusannotation&apos;)</span><br></pre></td></tr></table></figure>
<ol>
<li>除了导入注解库外，我们还需要导入auto-service和javapoet这两个库，如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &apos;com.squareup:javapoet:1.10.0&apos;</span><br><span class="line">implementation &apos;com.google.auto.service:auto-service:1.0-rc4&apos;</span><br></pre></td></tr></table></figure>
<h4 id="编写注解处理器"><a href="#编写注解处理器" class="headerlink" title="编写注解处理器"></a>编写注解处理器</h4><p>在配置好依赖后，接下来就可以正式地来编写注解处理器了。</p>
<ol>
<li>新建一个processor.java文件，继承AbstractProcessor，如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RxEventBusProcessor extends AbstractProcessor&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>添加注解，标志该注解处理器所处理的注解和版本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SupportedAnnotationTypes(&quot;site.gemus.rxeventbusannotation.Subscribe&quot;)</span><br><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_7)</span><br><span class="line">public class RxEventBusProcessor extends AbstractProcessor&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>还有注解auto-service为我们提供的服务，完成后如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br><span class="line">@SupportedAnnotationTypes(&quot;site.gemus.rxeventbusannotation.Subscribe&quot;)</span><br><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_7)</span><br><span class="line">public class RxEventBusProcessor extends AbstractProcessor&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>重写函数</li>
</ol>
<p>我们一般只重写最主要的几个函数，如init和process，当然process是必须要重写的，而在init中我们可以获得必要的工具</p>
<p>像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Messager mMessager;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">    super.init(processingEnvironment);</span><br><span class="line">    mMessager = processingEnvironment.getMessager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Messager可以帮助我们打印信息，因为在注解处理器库中，我们无法使用log来进行打印</p>
<p>可以这样使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mMessager.printMessage(Diagnostic.Kind.WARNING, &quot;Elements is empty!&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：不要轻易使用ERROR，会导致编译错误</p>
</blockquote>
<h4 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h4><p>Element可以用来获得我们所注解的元素的信息，可以这样获得相应注解所标注的元素的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(Subscribe.class);</span><br></pre></td></tr></table></figure>
<p>Element的子类有TypeElement、PackageElement和VariableElement等，我们在获取信息时可以将它转换成这些子类来获得更详细的信息，但是需要注意，并不是Element能转换到任意一个子类，譬如说我使用的注解是用来标记函数的，就能转换为ExecutableElement，而不能转换为TypeElement、PackageElement等。</p>
<h5 id="Element的相关函数"><a href="#Element的相关函数" class="headerlink" title="Element的相关函数"></a>Element的相关函数</h5><ul>
<li>getEnclosingElement()</li>
</ul>
<p>getEnclosingElement()这个函数的作用是获取上一个闭包元素，譬如说我的注解是在<em>site.gemus.app.firstFragment</em>这个类当中注解函数的，它的上一个闭包元素就是<em>site.gemus.app.firstFragment</em>，使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.getEnclosingElement().toString();</span><br></pre></td></tr></table></figure>
<p>获取到的就是<em>site.gemus.app.firstFragment</em>这串字符</p>
<ul>
<li>asType()</li>
</ul>
<p>asType()函数的作用是获得元素的类型，而不是变量的名字</p>
<h4 id="javapoet的使用"><a href="#javapoet的使用" class="headerlink" title="javapoet的使用"></a>javapoet的使用</h4><p>javapoet最终的作用是生成一个.java文件，我们需要先设想好生成后的代码，然后再进行使用，网上关于javapoet的资料有很多，就不一一介绍了，可以参考</p>
<p><a href="http://blog.csdn.net/crazy1235/article/details/51876192" target="_blank" rel="noopener">javapoet基本使用</a></p>
<p>特别要注意的是，我们使用javapoet导入包（import）的时候，javapoet只提供了静态导入，如果想正常导入的话，就要有意识地使用 <em>$T</em> 来导入包，下面就是后来改正的例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassName eventMethodMessage = ClassName.get(&quot;site.gemus.rxeventbusannotation&quot;,&quot;EventMethodMessage&quot;);</span><br><span class="line">ClassName proxyMessageMethod = ClassName.get(&quot;site.gemus.rxeventbusannotation&quot;,&quot;ProxyMessageMethod&quot;);</span><br><span class="line">ClassName threadModeName = ClassName.get(&quot;site.gemus.rxeventbusannotation&quot;,&quot;ThreadMode&quot;);</span><br><span class="line">MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(&quot;addEventMethodMessage&quot;)</span><br><span class="line">                .addStatement(&quot;$T import1&quot;, eventMethodMessage)</span><br><span class="line">                .addStatement(&quot;$T import2&quot;, proxyMessageMethod)</span><br><span class="line">                .addStatement(&quot;$T import3&quot;, threadModeName);</span><br></pre></td></tr></table></figure>
<p>这样javapoet才会正常地导入我们自己所写的类。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Git高级命令</title>
    <url>/2018/02/15/gitpro/</url>
    <content><![CDATA[<h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><blockquote>
<p>git中比较复杂的命令如下表所示：</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>git rebase</td>
<td>在新位置重新提交</td>
</tr>
<tr>
<td>git revert</td>
<td>撤销commit</td>
</tr>
<tr>
<td>git reset</td>
<td>丢弃提交</td>
</tr>
<tr>
<td>git stash</td>
<td>临时存放工作目录的改动</td>
</tr>
<tr>
<td>git reflog</td>
<td>找回分支</td>
</tr>
</tbody>
</table>
<h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>rebase的意思是，给你的commit序列重新设置基础点（也就是父commit）。展开来说就是，把你指定的commit以及它所在的 commit 串，以指定的目标commit为基础，依次重新提交一次。这和merge的不同点在于merge会发生分支散开又合并的情况，而用rebase则不会。</p>
<blockquote>
<p>注意：当使用rebase时，必须先checkout到分支，不能在默认分支（master）上直接使用rebase，它会时主分支上新的commit消失。在使用rebase后，可以使用merge来移动到最新的提交。</p>
</blockquote>
<h4 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><p>revert的作用时撤销提交上去的commit，希望撤销哪个commit，就把哪个填在后面，用法为：git revert 提交名</p>
<blockquote>
<p>注意：使用revert并不会修改提交历史，而是生成新的commit，所以是一种安全的方法</p>
</blockquote>
<h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><h5 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h5><p>git reset的作用与git revert的作用比较相似，不同点在于git reset撤销的是还没有被push的提交，git revert撤销的则是已经被push的提交，因为git revert不会修改提交历史，而reset则会修改。</p>
<p>reset可加三种修饰，有着三种不同的作用，如下</p>
<table>
<thead>
<tr>
<th>修饰</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>– mixed</td>
<td>保留工作目录，并清空暂存区</td>
<td>重置位置的同时，保留工作目录的内容，也就是修改为新commit已完成，但是还没提交到本地仓库的样子</td>
</tr>
<tr>
<td>– hard</td>
<td>重置工作目录</td>
<td>重置位置的同时，清空工作目录的所有改动,恢复成目前head所值的commit的样子</td>
</tr>
<tr>
<td>– soft</td>
<td>保留工作目录</td>
<td>把后面修改的内容都放进暂存区</td>
</tr>
</tbody>
</table>
<h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h4><h5 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h5><p>stash的作用就是把当前工作目录先隐藏起来，等到需要的时候再拿出来，拿出来时就使用<em>git stash pop</em></p>
<h4 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h4><h5 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h5><p>reflog可以查看head的移动历史，如果我们刚刚删除了一个分支，可以通过reflog查看分支，再通过checkout切换到那个分支</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git基础命令汇总</title>
    <url>/2018/02/14/GitCommand/</url>
    <content><![CDATA[<blockquote>
<p>汇总表如下所示</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td>git clone</td>
<td>把远程仓库取到本地</td>
<td>可能会需要输入GitHub的帐户名和密码，其中密码时不显示输入的</td>
</tr>
<tr>
<td>git log</td>
<td>查看历史记录</td>
<td>加上后缀<em>-p</em>查看详细历史，<em>–stat</em>查看简要统计，查看完按q键退出</td>
</tr>
<tr>
<td>git status</td>
<td>查看工作目录当前状态</td>
<td></td>
</tr>
<tr>
<td>git show</td>
<td>查看具体的 commit</td>
<td>查看当前的commit可以直接使用<em>git show</em>，看指定的commit需要加上这个commit的引用或者SHA-1码</td>
</tr>
<tr>
<td>git diff</td>
<td>查看未提交的内容</td>
<td>直接使用查看工作目录和暂存区的不同，使用<em>git diff –staged</em>可以显示暂存区和上一条提交之间的不同，使用<em>git diff HEAD</em>可以显示工作目录和上一条提交之间的不同</td>
</tr>
<tr>
<td>git add</td>
<td>把文件提交到暂存区</td>
<td>可以使用<em>git add .</em>来直接把工作目录下的所有改动全部放进暂存区，也可以<em>git add 文件名</em>放入单个文件</td>
</tr>
<tr>
<td>git commit</td>
<td>把文件提交到本地仓库</td>
<td>一般还要通过<em>-m</em>参数提交描述信息，否则要进入编辑模式编辑提交信息,<em>commit –amend</em>可以修改已经提交到本地仓库的commit并生成新commit</td>
</tr>
<tr>
<td>git push</td>
<td>把当前 branch 的位置上传到远端仓库</td>
<td>如果当前分支并不是默认分支，则使用<em>git push origin 分支名</em>提交到远程仓库，使用<em>-f</em>可以忽略冲突，强制push</td>
</tr>
<tr>
<td>git pull</td>
<td>从远程仓库更新内容</td>
<td></td>
</tr>
<tr>
<td>git branch 分支名</td>
<td>创建新分支</td>
<td><em>git branch -d 名称</em>可以删除一个分支（默认分支不可删除）</td>
</tr>
<tr>
<td>git checkout 分支名</td>
<td>切换到分支</td>
<td>可以使用<em>git checkout -b 名称</em>来把创建分支和切换到分支的操作合并</td>
</tr>
<tr>
<td>git merge 分支名</td>
<td>把目标分支上的所有commit的内容与当前commit合并生成一个新的commit</td>
<td>可能需要手动解决冲突，放弃解决冲突的话可以使用<em>git merge –abort</em></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式的目标-面向对象的六大原则</title>
    <url>/2018/01/28/oopsix/</url>
    <content><![CDATA[<blockquote>
<p>设计模式有六大原则，分别时单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、迪米特原则和接口隔离原则，这些原则是设计模式的最终目标，不过并不是每一个设计模式都遵循了以上六个原则</p>
</blockquote>
<h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><h5 id="定义：就一个类而言，应该仅有一个引起它变化的原因"><a href="#定义：就一个类而言，应该仅有一个引起它变化的原因" class="headerlink" title="定义：就一个类而言，应该仅有一个引起它变化的原因"></a>定义：就一个类而言，应该仅有一个引起它变化的原因</h5><p>单一职责原则的划分界限并不是总是那么清晰，很多时候都需要依赖个人经验来界定，最大的问题就是对职责的定义，什么是类的职责，以及怎么划分类的职责。</p>
<p>一个类中应该是一组相关性很高的函数、数据的封装。</p>
<h4 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h4><h5 id="定义：类、模块、函数等应该是可以扩展的，但是不可修改"><a href="#定义：类、模块、函数等应该是可以扩展的，但是不可修改" class="headerlink" title="定义：类、模块、函数等应该是可以扩展的，但是不可修改"></a>定义：类、模块、函数等应该是可以扩展的，但是不可修改</h5><p>在软件开发过程中，最不会变化的就是变化本身，因为产品需要不断地升级、维护，而在这个过程中修改原来的代码就可能会引发其他的问题，所以，开闭原则的使用在这里就十分重要。</p>
<p>开闭原则主要是通过接口来实现，而不能是具体的类，下面举一个简单的例子。</p>
<ol>
<li><p>接口类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ImageCache &#123;</span><br><span class="line">    Bitmap get(String url);</span><br><span class="line">    void put(String url, Bitmap bitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口实现类</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StoreCache implements ImageCache &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Bitmap get(String url) &#123;</span><br><span class="line">        return new Bitmap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void put(String url, Bitmap bitmap) &#123;</span><br><span class="line">        System.out.println(&quot;put image&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>依赖类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImageLoader &#123;</span><br><span class="line">    ImageCache imageCache = new StoreCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这个例子当中，ImageLoader类依赖于ImageCache接口，而不是依赖于具体的实现ImageCache接口的类，这样我们可以方便地进行扩展（继承ImageCache接口的类），而不是直接修改代码</p>
</blockquote>
<h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><h5 id="定义：所有引用基类的地方必须能透明地使用其子类的对象"><a href="#定义：所有引用基类的地方必须能透明地使用其子类的对象" class="headerlink" title="定义：所有引用基类的地方必须能透明地使用其子类的对象"></a>定义：所有引用基类的地方必须能透明地使用其子类的对象</h5><p>里氏替换原则简单来说就是父类出现的地方，替换成子类不会产生任何错误或异常，但是子类出现的地方，替换成父类就不一定能够适应，其实就是抽象的概念</p>
<p>可以举一个Android中View的例子</p>
<ol>
<li>View：抽象父类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class View &#123;</span><br><span class="line">    public abstract void draw();</span><br><span class="line">    public void measure(int width, int height)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Button:具体子类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Button extends View&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>窗口类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Window&#123;</span><br><span class="line">   public void show(View child)&#123;</span><br><span class="line">     child.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，窗口类中所使用的View类均可以无副作用地替换成Button子类</p>
<h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><h5 id="定义：高层模块不应该依赖底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象"><a href="#定义：高层模块不应该依赖底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象" class="headerlink" title="定义：高层模块不应该依赖底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象"></a>定义：高层模块不应该依赖底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象</h5><p>依赖倒置原则就是在类中不应该依赖具体的类，而是应该依赖于抽象，具体的例子其实在开闭原则中已经有了，关键就在于以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ImageCache imageCache = new StoreCache();</span><br></pre></td></tr></table></figure>
<h4 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h4><h5 id="定义：一个软件实体应当尽可能少地与其他实体发生相互作用"><a href="#定义：一个软件实体应当尽可能少地与其他实体发生相互作用" class="headerlink" title="定义：一个软件实体应当尽可能少地与其他实体发生相互作用"></a>定义：一个软件实体应当尽可能少地与其他实体发生相互作用</h5><p>如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法，则可以通过第三者转发这个调用，简言之，就是引入一个合理的第三者来降低现有对象之间的耦合度</p>
<h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><h5 id="定义：一个类对另一个类的依赖应该建立在最小的接口上"><a href="#定义：一个类对另一个类的依赖应该建立在最小的接口上" class="headerlink" title="定义：一个类对另一个类的依赖应该建立在最小的接口上"></a>定义：一个类对另一个类的依赖应该建立在最小的接口上</h5><p>接口原则说白了就是，客户端依赖的接口经可能地小，臃肿的接口拆分成更小的和更具体的接口，在实际的运用当中就是：将一个包含有多个函数的接口拆分成多个，将函数一分为几，被分到同一接口的函数职责更为单一。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>抽象与实现之间的桥梁-桥接模式</title>
    <url>/2018/01/26/%E6%8A%BD%E8%B1%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%A1%A5%E6%A2%81-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>桥梁的作用其实就是连接“抽象部分”与“实现部分”，任何多维度变化类或者说树状类之间的耦合都可以使用桥接模式来进行解耦</p>
</blockquote>
<p>生活中桥接模式也十分地常见，例如咖啡的种类，电源插头的使用等等，这里就举一个咖啡的例子，由它来实现桥接模式</p>
<p>咖啡与糖的关系是多对多的，我们需要先建立咖啡与糖的抽象类，咖啡抽象类依赖糖的抽象类</p>
<h4 id="糖抽象类"><a href="#糖抽象类" class="headerlink" title="糖抽象类"></a>糖抽象类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class CoffeeAdditives &#123;</span><br><span class="line">    public abstract String addSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="糖具体类"><a href="#糖具体类" class="headerlink" title="糖具体类"></a>糖具体类</h4><ol>
<li><p>加糖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Sugar extends CoffeeAdditives &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String addSomething() &#123;</span><br><span class="line">        return &quot;add sugar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不加糖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Ordinary extends CoffeeAdditives &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String addSomething() &#123;</span><br><span class="line">        return &quot;ordinary&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="咖啡抽象类"><a href="#咖啡抽象类" class="headerlink" title="咖啡抽象类"></a>咖啡抽象类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Coffee &#123;</span><br><span class="line">    protected CoffeeAdditives coffeeAdditives;</span><br><span class="line">    public Coffee(CoffeeAdditives coffeeAdditives) &#123;</span><br><span class="line">        this.coffeeAdditives = coffeeAdditives;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void makeCoffee();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体咖啡类"><a href="#具体咖啡类" class="headerlink" title="具体咖啡类"></a>具体咖啡类</h4><ol>
<li>大杯咖啡</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LargeCoffee extends Coffee &#123;</span><br><span class="line">    public LargeCoffee(CoffeeAdditives coffeeAdditives) &#123;</span><br><span class="line">        super(coffeeAdditives);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void makeCoffee() &#123;</span><br><span class="line">        System.out.println(&quot;large &quot; + coffeeAdditives.addSomething() + &quot; coffee&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>小杯咖啡</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SmallCoffee extends Coffee &#123;</span><br><span class="line">    public SmallCoffee(CoffeeAdditives coffeeAdditives) &#123;</span><br><span class="line">        super(coffeeAdditives);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void makeCoffee() &#123;</span><br><span class="line">        System.out.println(&quot;small &quot; + coffeeAdditives.addSomething() + &quot; coffee&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ordinary ordinary = new Ordinary();</span><br><span class="line">        Sugar sugar = new Sugar();</span><br><span class="line">        LargeCoffee largeCoffee = new LargeCoffee(ordinary);</span><br><span class="line">        largeCoffee.makeCoffee();</span><br><span class="line">        SmallCoffee smallCoffee = new SmallCoffee(sugar);</span><br><span class="line">        smallCoffee.makeCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>轻量级的对象池-享元模式</title>
    <url>/2018/01/25/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>享元模式又称Flyweight，代表轻量级的意思，适用于可能存在大量可重复对象的场景</p>
</blockquote>
<p>这里举一个售卖火车票的例子</p>
<h4 id="共享对象的接口，这里是火车票接口"><a href="#共享对象的接口，这里是火车票接口" class="headerlink" title="共享对象的接口，这里是火车票接口"></a>共享对象的接口，这里是火车票接口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Ticket &#123;</span><br><span class="line">    void showTicketInfo(String bunk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体对象类"><a href="#具体对象类" class="headerlink" title="具体对象类"></a>具体对象类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TrainTicket implements Ticket &#123;</span><br><span class="line">    public String from;</span><br><span class="line">    public String to;</span><br><span class="line">    public String bunk;</span><br><span class="line">    public int price;</span><br><span class="line">    public TrainTicket(String from, String to) &#123;</span><br><span class="line">        this.from = from;</span><br><span class="line">        this.to = to;</span><br><span class="line">        price = new Random().nextInt(300);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void showTicketInfo(String bunk) &#123;</span><br><span class="line">        System.out.println(from + &quot;到&quot; + to + &quot;的&quot; + bunk +&quot;火车票价格：&quot; + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对象生产工厂"><a href="#对象生产工厂" class="headerlink" title="对象生产工厂"></a>对象生产工厂</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TickFactory &#123;</span><br><span class="line">    static Map&lt;String, Ticket&gt; stringTicketMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    public static Ticket getTicket(String from, String to) &#123;</span><br><span class="line">        String key = from + &quot;-&quot; + to;</span><br><span class="line">        if (stringTicketMap.containsKey(key)) &#123;</span><br><span class="line">            return stringTicketMap.get(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Ticket ticket =new TrainTicket(from, to);</span><br><span class="line">            stringTicketMap.put(from + &quot;-&quot; + to,ticket);</span><br><span class="line">            return ticket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们使用了一个map来存放已经存在的对象，这也是享元模式的关键，这样就不用每次都重新创建对象，减少内存的消耗</p>
<p>使用如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ticket ticket = TickFactory.getTicket(&quot;长兴&quot;, &quot;武汉&quot;);</span><br><span class="line">        ticket.showTicketInfo(&quot;上铺&quot;);</span><br><span class="line">        Ticket ticket1 = TickFactory.getTicket(&quot;武汉&quot;, &quot;长兴&quot;);</span><br><span class="line">        ticket1.showTicketInfo(&quot;软卧&quot;);</span><br><span class="line">        Ticket ticket2 = TickFactory.getTicket(&quot;长兴&quot;, &quot;武汉&quot;);</span><br><span class="line">        ticket2.showTicketInfo(&quot;上铺&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="https://i.loli.net/2018/01/24/5a67ffe46e7bc.png" alt="1.PNG"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>使用最频繁的粘合剂-适配器模式</title>
    <url>/2018/01/24/%E4%BD%BF%E7%94%A8%E6%9C%80%E9%A2%91%E7%B9%81%E7%9A%84%E7%B2%98%E5%90%88%E5%89%82-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>适配器模式可以说是开发Android过程中绕不开的一个设计模式，ListView到RecyclerVIew都需要使用适配器模式，相当于将两个类粘合在一起，这个模式在我们的生活中也能见到类似的例子，如电源适配器等等，适配器模式又分为类适配器与对象适配器，分别如下：</p>
</blockquote>
<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><h5 id="被转换的类"><a href="#被转换的类" class="headerlink" title="被转换的类"></a>被转换的类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IntegerInput &#123;</span><br><span class="line">    public int getIntegerInput() &#123;</span><br><span class="line">        return new Random().nextInt(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="目标接口"><a href="#目标接口" class="headerlink" title="目标接口"></a>目标接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface StringOutput &#123;</span><br><span class="line">    public String getString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="适配器类"><a href="#适配器类" class="headerlink" title="适配器类"></a>适配器类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AdapterIS extends IntegerInput implements StringOutput &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getString() &#123;</span><br><span class="line">        return &quot;String:&quot; + getIntegerInput();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p>对象适配器与类适配器有些许不同，使用了代理的思想，仅仅是适配器类与类适配器有所不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AdapterIS implements StringOutput &#123;</span><br><span class="line">    IntegerInput integerInput;</span><br><span class="line"></span><br><span class="line">    public AdapterIS(IntegerInput integerInput) &#123;</span><br><span class="line">        this.integerInput = integerInput;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getString() &#123;</span><br><span class="line">        return &quot;String:&quot; + integerInput.getIntegerInput();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>从不同角度看同一数据结构-访问者模式</title>
    <url>/2018/01/24/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>访问者模式是一种复杂的设计模式，使用频率不高，下面举一个公司对员工业绩考核的例子，CEO和CTO对员工的考核标准是不一样的</p>
</blockquote>
<h4 id="员工抽象类"><a href="#员工抽象类" class="headerlink" title="员工抽象类"></a>员工抽象类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Staff &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int kpi;</span><br><span class="line">    public Staff(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        kpi = new Random().nextInt(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void accept(Visitor visitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基类中只有员工的公共属性，这里是姓名和kpi</p>
<h4 id="员工具体类"><a href="#员工具体类" class="headerlink" title="员工具体类"></a>员工具体类</h4><ol>
<li><p>工程师类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Engineer extends Staff &#123;</span><br><span class="line">    public Engineer(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Visitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCodeLines() &#123;</span><br><span class="line">        return new Random().nextInt(10*10000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>产品经理类</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Manager extends Staff &#123;</span><br><span class="line">    public Manager(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Visitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getProducts() &#123;</span><br><span class="line">        return new Random().nextInt(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在具体类中加入独特的属性，这样访问者访问时就可以区别对待</p>
<h4 id="抽象访问者类"><a href="#抽象访问者类" class="headerlink" title="抽象访问者类"></a>抽象访问者类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Visitor &#123;</span><br><span class="line">    void visit(Engineer engineer);</span><br><span class="line">    void visit(Manager manager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体访问类"><a href="#具体访问类" class="headerlink" title="具体访问类"></a>具体访问类</h4><ol>
<li><p>CEO：只关心员工的姓名和KPI</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CEO implements Visitor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Engineer engineer) &#123;</span><br><span class="line">        System.out.println(&quot;Engineer：&quot;+ engineer.name + &quot;, kpi: &quot; +engineer.kpi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Manager manager) &#123;</span><br><span class="line">        System.out.println(&quot;Manager: &quot;+ manager.name + &quot;, kpi: &quot;+manager.kpi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CTO：根据岗位的不同关心不同的技术指标</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CTO implements Visitor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Engineer engineer) &#123;</span><br><span class="line">        System.out.println(&quot;Engineer: &quot; + engineer.name +&quot;, code: &quot; + engineer.getCodeLines());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(Manager manager) &#123;</span><br><span class="line">        System.out.println(&quot;Manager: &quot; + manager.name + &quot;, product: &quot;+ manager.getProducts());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BusinessReport businessReport = new BusinessReport();</span><br><span class="line">        System.out.println(&quot;======CEO=====&quot;);</span><br><span class="line">        businessReport.showReport(new CEO());</span><br><span class="line">        System.out.println(&quot;\n=====CTO=====&quot;);</span><br><span class="line">        businessReport.showReport(new CTO());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="https://i.loli.net/2018/01/18/5a603aac801a1.png" alt="捕获.PNG"></p>
<blockquote>
<p>访问者模式可以很方便地添加访问者，方便地从多种角度观察同一种数据结构</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式中的撤销-备忘录模式</title>
    <url>/2018/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%92%A4%E9%94%80-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>在开发过程中，我们可能会遇到保存对象目前的状态，到必要的时候再进行恢复的需求，这类似于数据库中的后援副本，到出现故障时数据库可以回到转储时的状态</p>
</blockquote>
<h4 id="备忘录模式的示例"><a href="#备忘录模式的示例" class="headerlink" title="备忘录模式的示例"></a>备忘录模式的示例</h4><p>在一般软件的开发中，备忘录模式是使用得比较少的设计模式，但是在游戏开发过程中，备忘录模式是使用得很频繁的，这里就举一个小游戏的例子</p>
<h5 id="游戏类"><a href="#游戏类" class="headerlink" title="游戏类"></a>游戏类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mario &#123;</span><br><span class="line">    private int checkPoint = 1;</span><br><span class="line">    private int lifeValue = 100;</span><br><span class="line">    private String state = &quot;正常&quot;;</span><br><span class="line"></span><br><span class="line">    public void play() &#123;</span><br><span class="line">        System.out.println(&quot;现在在：&quot; + String.format(&quot;第%d关&quot;, checkPoint));</span><br><span class="line">        lifeValue -= 10;</span><br><span class="line">        System.out.println(&quot;过关！&quot;);</span><br><span class="line">        checkPoint ++ ;</span><br><span class="line">        System.out.println(&quot;现在是&quot; + String.format(&quot;第%d关&quot;,checkPoint));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void quit() &#123;</span><br><span class="line">        System.out.println(&quot;退出前的游戏属性：&quot; + this.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Memoto createMemoto () &#123;</span><br><span class="line">        Memoto memoto = new Memoto();</span><br><span class="line">        memoto.checkPoint = checkPoint;</span><br><span class="line">        memoto.state = state;</span><br><span class="line">        memoto.lifeValue = lifeValue;</span><br><span class="line">        return memoto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void restore(Memoto memoto) &#123;</span><br><span class="line">        this.checkPoint = memoto.checkPoint;</span><br><span class="line">        this.lifeValue = memoto.lifeValue;</span><br><span class="line">        this.state = memoto.state;</span><br><span class="line">        System.out.println(&quot;恢复后的游戏属性：&quot; + this.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;CheckPoint:&quot; + checkPoint + &quot;, LifeValue：&quot; + lifeValue +&quot;, State:&quot; + state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="备忘录类"><a href="#备忘录类" class="headerlink" title="备忘录类"></a>备忘录类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Memoto &#123;</span><br><span class="line">    public int checkPoint;</span><br><span class="line">    public int lifeValue;</span><br><span class="line">    public String state;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;CheckPoint:&quot; + checkPoint + &quot;, LifeValue：&quot; + lifeValue +&quot;, State:&quot; + state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="备忘录管理类"><a href="#备忘录管理类" class="headerlink" title="备忘录管理类"></a>备忘录管理类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Caretaker &#123;</span><br><span class="line">    Memoto memoto;</span><br><span class="line"></span><br><span class="line">    public void archive(Memoto memoto) &#123;</span><br><span class="line">        this.memoto = memoto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Memoto getMemoto() &#123;</span><br><span class="line">        return memoto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Mario mario = new Mario();</span><br><span class="line">        mario.play();</span><br><span class="line">        Caretaker caretaker = new Caretaker();</span><br><span class="line">        caretaker.archive(mario.createMemoto());</span><br><span class="line">        mario.quit();</span><br><span class="line">        Mario mario1 = new Mario();</span><br><span class="line">        mario1.restore(caretaker.getMemoto());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://i.loli.net/2018/01/15/5a5c101d77b70.png" alt="1.PNG"></p>
<blockquote>
<p>当然，如果我们需要开发一个游戏，肯定是持久化存储与备忘录模式一起使用</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>特殊的继承关系-装饰模式</title>
    <url>/2018/01/20/%E7%89%B9%E6%AE%8A%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>装饰模式使用一种对客户端透明的方案来动态地扩展对象的功能，同时它也是继承方案的一种替代方案之一。</p>
</blockquote>
<p>这里举一个简答的汽车改装的例子来说明以下装饰模式的组成</p>
<h4 id="基本抽象类"><a href="#基本抽象类" class="headerlink" title="基本抽象类"></a>基本抽象类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Car &#123;</span><br><span class="line">    public abstract void have();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体类：继承基本抽象类"><a href="#具体类：继承基本抽象类" class="headerlink" title="具体类：继承基本抽象类"></a>具体类：继承基本抽象类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Limousine extends Car &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void have() &#123;</span><br><span class="line">        System.out.println(&quot;有基本的配置&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是需要装饰的类，所以只需要最基本的东西</p>
<h4 id="装饰抽象类"><a href="#装饰抽象类" class="headerlink" title="装饰抽象类"></a>装饰抽象类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class CarRefit extends Car &#123;</span><br><span class="line">    protected Car car;</span><br><span class="line">    public CarRefit(Car car) &#123;</span><br><span class="line">        this.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void have() &#123;</span><br><span class="line">        car.have();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在装饰类中我们需要持有一个基本类的对象，以便进行装饰操作</p>
<h4 id="具体装饰类"><a href="#具体装饰类" class="headerlink" title="具体装饰类"></a>具体装饰类</h4><p>1.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ExpensiveRefit extends CarRefit &#123;</span><br><span class="line">    public ExpensiveRefit(Car car) &#123;</span><br><span class="line">        super(car);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void have() &#123;</span><br><span class="line">        super.have();</span><br><span class="line">        haveHUD();</span><br><span class="line">        haveBetterEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void haveHUD() &#123;</span><br><span class="line">        System.out.println(&quot;加装了HUD&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void haveBetterEngine() &#123;</span><br><span class="line">        System.out.println(&quot;加装了更好的发动机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OtherRefit extends CarRefit &#123;</span><br><span class="line">    public OtherRefit(Car car) &#123;</span><br><span class="line">        super(car);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void have() &#123;</span><br><span class="line">        super.have();</span><br><span class="line">        havePaint();</span><br><span class="line">        haveEmpennage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void havePaint() &#123;</span><br><span class="line">        System.out.println(&quot;加装了个性喷漆&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void haveEmpennage() &#123;</span><br><span class="line">        System.out.println(&quot;加装了尾翼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Limousine limousine = new Limousine();</span><br><span class="line">        ExpensiveRefit expensiveRefit = new ExpensiveRefit(limousine);</span><br><span class="line">        expensiveRefit.have();</span><br><span class="line">        OtherRefit otherRefit = new OtherRefit(limousine);</span><br><span class="line">        otherRefit.have();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="https://i.loli.net/2018/01/23/5a6695d1aebc5.png" alt="1.PNG"></p>
<blockquote>
<p>由上可知，装饰模式不需要依靠继承来实现功能的扩展，最重要的一步是抽象装饰类</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>同一编程接口-外观模式</title>
    <url>/2018/01/20/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>外观模式接口比较简单，就是通过一个统一的接口对外提供服务，使得外部程序只通过一个类就可以实现系统内部的多种功能</p>
</blockquote>
<p>这里就举一个由用户来操控手机的小例子</p>
<h4 id="子系统接口类"><a href="#子系统接口类" class="headerlink" title="子系统接口类"></a>子系统接口类</h4><ol>
<li><p>手机通话系统接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Phone &#123;</span><br><span class="line">    void dail();</span><br><span class="line">    void hangup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>相机系统接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Camera &#123;</span><br><span class="line">    void open();</span><br><span class="line">    void tackPhoto();</span><br><span class="line">    void close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="子系统具体类"><a href="#子系统具体类" class="headerlink" title="子系统具体类"></a>子系统具体类</h4><ol>
<li><p>通话系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PhoneImpl implements Phone &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void dail() &#123;</span><br><span class="line">        System.out.println(&quot;call&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hangup() &#123;</span><br><span class="line">        System.out.println(&quot;hangup&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>相机系统</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PixelCamera implements Camera &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void open() &#123;</span><br><span class="line">        System.out.println(&quot;open camera&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void tackPhoto() &#123;</span><br><span class="line">        System.out.println(&quot;tack photo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        System.out.println(&quot;close camera&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="上层系统"><a href="#上层系统" class="headerlink" title="上层系统"></a>上层系统</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MobilePhone &#123;</span><br><span class="line">    private Phone phone = new PhoneImpl();</span><br><span class="line">    private Camera camera = new PixelCamera();</span><br><span class="line">    public void videoChat() &#123;</span><br><span class="line">        camera.open();</span><br><span class="line">        phone.dail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tackPhoto() &#123;</span><br><span class="line">        camera.open();</span><br><span class="line">        camera.tackPhoto();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void closeCamera() &#123;</span><br><span class="line">        camera.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MobilePhone pixel = new MobilePhone();</span><br><span class="line">        pixel.tackPhoto();</span><br><span class="line">        pixel.videoChat();</span><br><span class="line">        pixel.closeCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/2018/01/20/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>解释器模式时一种使用的比较少的行为类设计模式，也比较难以理解，但是在系统设计的时候，解释器模式则被广泛地使用了，比如说在解析文件的时候</p>
</blockquote>
<p>这里举一个解释器模式的简单例子</p>
<h4 id="抽象算数运算解释器"><a href="#抽象算数运算解释器" class="headerlink" title="抽象算数运算解释器"></a>抽象算数运算解释器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class ArithmeticExpression &#123;</span><br><span class="line">    public abstract int interpret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数字解释器"><a href="#数字解释器" class="headerlink" title="数字解释器"></a>数字解释器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NumExpression extends ArithmeticExpression &#123;</span><br><span class="line">    private int num;</span><br><span class="line">    public NumExpression(int num) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="符号解释器"><a href="#符号解释器" class="headerlink" title="符号解释器"></a>符号解释器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class  OperatorExpression extends ArithmeticExpression &#123;</span><br><span class="line">    protected ArithmeticExpression exp1,exp2;</span><br><span class="line">    public OperatorExpression(ArithmeticExpression exp1, ArithmeticExpression exp2) &#123;</span><br><span class="line">        this.exp1 = exp1;</span><br><span class="line">        this.exp2 = exp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加法运算解释器"><a href="#加法运算解释器" class="headerlink" title="加法运算解释器"></a>加法运算解释器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AdditionExpression extends OperatorExpression &#123;</span><br><span class="line">    public AdditionExpression(ArithmeticExpression exp1, ArithmeticExpression exp2) &#123;</span><br><span class="line">        super(exp1, exp2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int interpret() &#123;</span><br><span class="line">        return exp1.interpret() + exp2.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里只是举了一个简单的加法算术例子，可能会显得有些鸡肋，但是在复杂的解析当中，解释器模式会起到很好的作用</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Builder模式的简单示例</title>
    <url>/2018/01/19/Builder%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>Builder模式可以说是最简单的设计模式了，它的原理就是封装set方法，每一步都由Builder对象来完成，使构建过程和部件的表示隔离开来，这里就仿造Android中的AlterDialog中的Builder模式</p>
</blockquote>
<h4 id="例如，用Builder模式来构造一个Person对象，对象如下："><a href="#例如，用Builder模式来构造一个Person对象，对象如下：" class="headerlink" title="例如，用Builder模式来构造一个Person对象，对象如下："></a>例如，用Builder模式来构造一个Person对象，对象如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String sex;</span><br><span class="line">    private int height;</span><br><span class="line"></span><br><span class="line">    private void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setHeight(int height) &#123;</span><br><span class="line">        this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里的set函数全都是private的，因为属性应该由Builder对象进行设置，而不是直接使用Person对象设置，完整的代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String sex;</span><br><span class="line">    private int height;</span><br><span class="line"></span><br><span class="line">    private void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setHeight(int height) &#123;</span><br><span class="line">        this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Builder&#123;</span><br><span class="line">        private Person person = null;</span><br><span class="line">        public Builder() &#123;</span><br><span class="line">            person = new Person();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder setName(String name) &#123;</span><br><span class="line">            person.name = name;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder setSex(String sex) &#123;</span><br><span class="line">            person.sex = sex;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder setHeight(int height) &#123;</span><br><span class="line">            person.height = height;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Person create() &#123;</span><br><span class="line">            return person;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="这样就是一个简单Builder模式的实现了，因为Builder模式比较简单，大致都差不多"><a href="#这样就是一个简单Builder模式的实现了，因为Builder模式比较简单，大致都差不多" class="headerlink" title="这样就是一个简单Builder模式的实现了，因为Builder模式比较简单，大致都差不多"></a>这样就是一个简单Builder模式的实现了，因为Builder模式比较简单，大致都差不多</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>对象内部的策略改变-状态模式</title>
    <url>/2018/01/18/%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E7%9A%84%E6%94%B9%E5%8F%98-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>状态模式比较常见的是运用在登陆或未登陆的情况下进行，因为在用户登陆与未登陆这两种情况下，对相同的动作会有不同的反应</p>
</blockquote>
<p>状态模式的使用一般分为以下几步</p>
<h5 id="定义状态接口以及相应的动作"><a href="#定义状态接口以及相应的动作" class="headerlink" title="定义状态接口以及相应的动作"></a>定义状态接口以及相应的动作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface State &#123;</span><br><span class="line">    void statement();</span><br><span class="line">    void report();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="定义每种不同的状态相应的动画"><a href="#定义每种不同的状态相应的动画" class="headerlink" title="定义每种不同的状态相应的动画"></a>定义每种不同的状态相应的动画</h5><ol>
<li><p>登陆状态时的动作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LogOnState implements State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void statement() &#123;</span><br><span class="line">        System.out.println(&quot;statement  fail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void report() &#123;</span><br><span class="line">        System.out.println(&quot;report fail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>未登陆状态时的动作</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LogOutState implements State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void statement() &#123;</span><br><span class="line">        System.out.println(&quot;statement success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void report() &#123;</span><br><span class="line">        System.out.println(&quot;report success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="定义状态所对应的实体类，比如说这里的User类"><a href="#定义状态所对应的实体类，比如说这里的User类" class="headerlink" title="定义状态所对应的实体类，比如说这里的User类"></a>定义状态所对应的实体类，比如说这里的User类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private State state = new LogOutState();</span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setState(State state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void LogOn() &#123;</span><br><span class="line">        setState(new LogOnState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void LogOut() &#123;</span><br><span class="line">        setState(new LogOutState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void statement() &#123;</span><br><span class="line">        state.statement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void report() &#123;</span><br><span class="line">        state.report();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里定义了一个默认的状态就是未登陆的，这和实际中的场景相似</p>
</blockquote>
<h5 id="实现代码如下："><a href="#实现代码如下：" class="headerlink" title="实现代码如下："></a>实现代码如下：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.statement();</span><br><span class="line">        user.report();</span><br><span class="line">        user.LogOn();</span><br><span class="line">        user.statement();</span><br><span class="line">        user.report();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然，这里只是最简单的示例，在实际开发过程中状态模式的作用这里还没有体现出来，总结来说就是，策略模式时去掉了在“外部的”if-else，而状态模式则是去掉了内部的”“if-else，两种设计模式的不同就是：在策略模式下，策略是由用户选择的，而在状态模式下，策略则是由类内部自动改变，不需要用户的干预，适合于像处理用户的登陆状态与未登陆状态这样的情况。</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Java中内置的设计模式-观察者模式</title>
    <url>/2018/01/17/Java%E4%B8%AD%E5%86%85%E7%BD%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>观察者模式是jdk中内置的模式，也是使用频率最为广泛的设计模式之一，著名的开源项目如RxJava、EventBus中都能够看到它的影子，甚至在跨进程通信中，我们也经常用到观察者模式</p>
</blockquote>
<p>这里只举例一个使用jdk中内置观察者模式的例子：公众号发推送的例子，公众号发文章后，每个订阅该公众号的用户都会得到推送</p>
<h4 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Observer &#123;</span><br><span class="line">    private String Name;</span><br><span class="line">    public User(String Name) &#123;</span><br><span class="line">        this.Name = Name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void update(Observable o, Object arg) &#123;</span><br><span class="line">        System.out.println( Name + &quot; 收到新推送：&quot; + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，update函数中的arg即为被观察者发送出的消息，在这个例子中就是公众号发出来的消息</p>
<h4 id="被观察者：推送消息"><a href="#被观察者：推送消息" class="headerlink" title="被观察者：推送消息"></a>被观察者：推送消息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GongZhongHao extends Observable &#123;</span><br><span class="line">    public void push(String content) &#123;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setChanged和notifyObservers两个函数要一起使用</p>
<h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user1 = new User(&quot;User1&quot;);</span><br><span class="line">        User user2 = new User(&quot;User2&quot;);</span><br><span class="line">        User user3 = new User(&quot;User3&quot;);</span><br><span class="line">        GongZhongHao gongZhongHao = new GongZhongHao();</span><br><span class="line">        gongZhongHao.addObserver(user1);</span><br><span class="line">        gongZhongHao.addObserver(user2);</span><br><span class="line">        gongZhongHao.addObserver(user3);</span><br><span class="line">        gongZhongHao.push(&quot;比特币大跌&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://i.loli.net/2018/01/14/5a5ab91bc778d.png" alt="1.PNG"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2018/01/17/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>命令模式对简单的调用关系进行解耦，再大多数情况下我们可以使用直接调用的方式来做，但是如果调用比较繁琐，那么使用命令模式不失为一个好选择</p>
</blockquote>
<p>这里举一个超级马里奥移动的例子来讲解命令模式</p>
<h4 id="超级马里奥的动作类"><a href="#超级马里奥的动作类" class="headerlink" title="超级马里奥的动作类"></a>超级马里奥的动作类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mario &#123;</span><br><span class="line">    public void toLeft() &#123;</span><br><span class="line">        System.out.println(&quot;向左移&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void toRight() &#123;</span><br><span class="line">        System.out.println(&quot;向右移&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void toJump() &#123;</span><br><span class="line">        System.out.println(&quot;跳跃&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义执行方法接口"><a href="#定义执行方法接口" class="headerlink" title="定义执行方法接口"></a>定义执行方法接口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Command &#123;</span><br><span class="line">    void execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义具体命令类"><a href="#定义具体命令类" class="headerlink" title="定义具体命令类"></a>定义具体命令类</h4><ol>
<li><p>跳命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JumpCommand implements Command &#123;</span><br><span class="line">    private Mario mario;</span><br><span class="line">    public JumpCommand(Mario mario) &#123;</span><br><span class="line">        this.mario = mario;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        mario.toJump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>左移命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LeftCommand implements Command &#123;</span><br><span class="line">    private Mario mario;</span><br><span class="line">    public LeftCommand(Mario mario) &#123;</span><br><span class="line">        this.mario = mario;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        mario.toLeft();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右移命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RightCommand implements Command &#123;</span><br><span class="line">    private Mario mario;</span><br><span class="line">    public RightCommand(Mario mario) &#123;</span><br><span class="line">        this.mario = mario;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        mario.toRight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="命令的包装：按钮类"><a href="#命令的包装：按钮类" class="headerlink" title="命令的包装：按钮类"></a>命令的包装：按钮类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Button &#123;</span><br><span class="line">    private JumpCommand jumpCommand;</span><br><span class="line">    private LeftCommand leftCommand;</span><br><span class="line">    private RightCommand rightCommand;</span><br><span class="line"></span><br><span class="line">    public void setJumpCommand(JumpCommand jumpCommand) &#123;</span><br><span class="line">        this.jumpCommand = jumpCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeftCommand(LeftCommand leftCommand) &#123;</span><br><span class="line">        this.leftCommand = leftCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRightCommand(RightCommand rightCommand) &#123;</span><br><span class="line">        this.rightCommand = rightCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void jump() &#123;</span><br><span class="line">        jumpCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void left() &#123;</span><br><span class="line">        leftCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void right() &#123;</span><br><span class="line">        rightCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体执行"><a href="#具体执行" class="headerlink" title="具体执行"></a>具体执行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Mario mario = new Mario();</span><br><span class="line">        LeftCommand leftCommand = new LeftCommand(mario);</span><br><span class="line">        RightCommand rightCommand = new RightCommand(mario);</span><br><span class="line">        JumpCommand jumpCommand = new JumpCommand(mario);</span><br><span class="line">        Button button = new Button();</span><br><span class="line">        button.setJumpCommand(jumpCommand);</span><br><span class="line">        button.setLeftCommand(leftCommand);</span><br><span class="line">        button.setRightCommand(rightCommand);</span><br><span class="line">        button.jump();</span><br><span class="line">        button.left();</span><br><span class="line">        button.right();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命令类可以在相当程度上实现调用逻辑的解耦，但是像大家看到的一样，需要多出很多的类，但是这样设计模式的原则：对修改关闭，对扩展开放，才能提到体现</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>容器中的游标-迭代器模式</title>
    <url>/2018/01/17/%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E6%B8%B8%E6%A0%87-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>迭代器模式又称为游标模式，Java中的List遍历就可以使用迭代器，而不需要使用“明显”的遍历算法，下面举一个迭代器模式的小例子</p>
</blockquote>
<h4 id="迭代器接口"><a href="#迭代器接口" class="headerlink" title="迭代器接口"></a>迭代器接口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Iterator&lt;T&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line">    T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体迭代器类"><a href="#具体迭代器类" class="headerlink" title="具体迭代器类"></a>具体迭代器类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcreteIterator&lt;T&gt; implements Iterator &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;T&gt; list = new ArrayList&lt;T&gt;();</span><br><span class="line">    private int cursor = 0;</span><br><span class="line">    public ConcreteIterator(List&lt;T&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor != list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object next() &#123;</span><br><span class="line">        T obj = null;</span><br><span class="line">        if (this.hasNext()) &#123;</span><br><span class="line">            obj = this.list.get(cursor++);</span><br><span class="line">        &#125;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="容器接口"><a href="#容器接口" class="headerlink" title="容器接口"></a>容器接口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Aggregate&lt;T&gt; &#123;</span><br><span class="line">    void add(T obj);</span><br><span class="line">    void remove(T obj);</span><br><span class="line">    Iterator&lt;T&gt; iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体容器类"><a href="#具体容器类" class="headerlink" title="具体容器类"></a>具体容器类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcreteAggregate&lt;T&gt; implements Aggregate&lt;T&gt; &#123;</span><br><span class="line">    private List&lt;T&gt; list = new ArrayList&lt;T&gt;();</span><br><span class="line">    @Override</span><br><span class="line">    public void add(T obj) &#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(T obj) &#123;</span><br><span class="line">        list.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;T&gt; iterator() &#123;</span><br><span class="line">        return new ConcreteIterator&lt;T&gt;(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Aggregate&lt;String&gt; aggregate = new ConcreteAggregate&lt;&gt;();</span><br><span class="line">        aggregate.add(&quot;android&quot;);</span><br><span class="line">        aggregate.add(&quot;studio&quot;);</span><br><span class="line">        aggregate.add(&quot;Google&quot;);</span><br><span class="line">        Iterator&lt;String&gt; iterator = aggregate.iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，迭代器模式是一个不需要由开发者实现的模式，这里只是来解析以下迭代器是怎样构成的，实际上List容器有自带的迭代器，不需要我们自己实现</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2018/01/15/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>中介者模式主要是解决两个对象间相互作用时产生的耦合</p>
</blockquote>
<p>这里举一个简单的电脑组装的例子，电脑中的组件，如CPU、显卡、内存等等都是通过主板进行工作，主板就扮演着一个中介者的角色</p>
<h4 id="抽象中介者类"><a href="#抽象中介者类" class="headerlink" title="抽象中介者类"></a>抽象中介者类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Mediator &#123;</span><br><span class="line">    public abstract void changed(Colleague colleague);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="抽象组件类"><a href="#抽象组件类" class="headerlink" title="抽象组件类"></a>抽象组件类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Colleague &#123;</span><br><span class="line">    protected Mediator mediator;</span><br><span class="line">    public Colleague(Mediator mediator) &#123;</span><br><span class="line">        this.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体组件类"><a href="#具体组件类" class="headerlink" title="具体组件类"></a>具体组件类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CDDevice extends Colleague &#123;</span><br><span class="line"></span><br><span class="line">    private String data;</span><br><span class="line"></span><br><span class="line">    public CDDevice(Mediator mediator) &#123;</span><br><span class="line">        super(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String read() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void load() &#123;</span><br><span class="line">        data = &quot;VideoData,SoundData&quot;;</span><br><span class="line">        mediator.changed(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CPU extends Colleague &#123;</span><br><span class="line">    private String dataVideo,dataSound;</span><br><span class="line">    public CPU(Mediator mediator) &#123;</span><br><span class="line">        super(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDataSound() &#123;</span><br><span class="line">        return dataSound;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDataVideo() &#123;</span><br><span class="line">        return dataVideo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void decodeData(String data) &#123;</span><br><span class="line">        String[] tmp = data.split(&quot;,&quot;);</span><br><span class="line">        dataVideo = tmp[0];</span><br><span class="line">        dataSound = tmp[1];</span><br><span class="line">        mediator.changed(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GraphicsCard extends Colleague &#123;</span><br><span class="line">    public GraphicsCard(Mediator mediator) &#123;</span><br><span class="line">        super(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void videoPlay(String data) &#123;</span><br><span class="line">        System.out.println(&quot;Video: &quot;+ data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SoundCard extends Colleague &#123;</span><br><span class="line">    public SoundCard(Mediator mediator) &#123;</span><br><span class="line">        super(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void soundPlay(String data)&#123;</span><br><span class="line">        System.out.println(&quot;Sound: &quot;+data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体中介者"><a href="#具体中介者" class="headerlink" title="具体中介者"></a>具体中介者</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainBoard extends Mediator &#123;</span><br><span class="line">    private CDDevice cdDevice;</span><br><span class="line">    private CPU cpu;</span><br><span class="line">    private SoundCard soundCard;</span><br><span class="line">    private GraphicsCard graphicsCard;</span><br><span class="line">    @Override</span><br><span class="line">    public void changed(Colleague colleague) &#123;</span><br><span class="line">        if (colleague == cdDevice) &#123;</span><br><span class="line">            handleCD((CDDevice) colleague);</span><br><span class="line">        &#125; else if (colleague == cpu) &#123;</span><br><span class="line">            handleCPU((CPU)colleague);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void handleCD(CDDevice cdDevice) &#123;</span><br><span class="line">        cpu.decodeData(cdDevice.read());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void handleCPU(CPU cpu) &#123;</span><br><span class="line">        soundCard.soundPlay(cpu.getDataSound());</span><br><span class="line">        graphicsCard.videoPlay(cpu.getDataVideo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCdDevice(CDDevice cdDevice) &#123;</span><br><span class="line">        this.cdDevice = cdDevice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCpu(CPU cpu) &#123;</span><br><span class="line">        this.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSoundCard(SoundCard soundCard) &#123;</span><br><span class="line">        this.soundCard = soundCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGraphicsCard(GraphicsCard graphicsCard) &#123;</span><br><span class="line">        this.graphicsCard = graphicsCard;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MainBoard mainBoard = new MainBoard();</span><br><span class="line">        CDDevice cdDevice = new CDDevice(mainBoard);</span><br><span class="line">        CPU cpu = new CPU(mainBoard);</span><br><span class="line">        GraphicsCard graphicsCard = new GraphicsCard(mainBoard);</span><br><span class="line">        SoundCard soundCard = new SoundCard(mainBoard);</span><br><span class="line">        mainBoard.setCdDevice(cdDevice);</span><br><span class="line">        mainBoard.setCpu(cpu);</span><br><span class="line">        mainBoard.setGraphicsCard(graphicsCard);</span><br><span class="line">        mainBoard.setSoundCard(soundCard);</span><br><span class="line">        cdDevice.load();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>中介者类负责各个组件之间的配合,所以各个组件之间的耦合度会降低，最后只需要启动一个组件的动作，通信工作就由中介者负责</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>让函数有执行顺序-模板方法模式</title>
    <url>/2018/01/15/%E8%AE%A9%E5%87%BD%E6%95%B0%E6%9C%89%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>我们知道在一般情况下，Android中Activity的生命周期如图所示</p>
</blockquote>
<p><img src="https://i.loli.net/2018/01/17/5a5f170714b1e.png" alt="1.PNG"></p>
<p>执行顺序为onCreate()-&gt;onStart()-&gt;onResume()-&gt;onPause()-&gt;onStop()-&gt;onDestroy()，这个就是模板方法模式的使用之一</p>
<p>我们可以来模拟以下Activity所使用的模板方法模式，具体步骤如下：</p>
<h4 id="抽象类：定义算法框架，也就是执行顺序"><a href="#抽象类：定义算法框架，也就是执行顺序" class="headerlink" title="抽象类：定义算法框架，也就是执行顺序"></a>抽象类：定义算法框架，也就是执行顺序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractActivity &#123;</span><br><span class="line">    protected void onCreate() &#123;</span><br><span class="line">        System.out.println(&quot;onCreate()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onStart() &#123;</span><br><span class="line">        System.out.println(&quot;onStart()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        System.out.println(&quot;onResume()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onPause() &#123;</span><br><span class="line">        System.out.println(&quot;onPause()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onStop() &#123;</span><br><span class="line">        System.out.println(&quot;onStop&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        System.out.println(&quot;onDestroy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void work() &#123;</span><br><span class="line">        onCreate();</span><br><span class="line">        onStart();</span><br><span class="line">        onResume();</span><br><span class="line">        onPause();</span><br><span class="line">        onStop();</span><br><span class="line">        onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h4><ol>
<li><p>MainActivity</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AbstractActivity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        System.out.println(&quot;This is MainActivity&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SecondActivity</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SecondActivity extends AbstractActivity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        System.out.println(&quot;This is SecondActivity&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MainActivity mainActivity = new MainActivity();</span><br><span class="line">        mainActivity.work();</span><br><span class="line">        SecondActivity secondActivity = new SecondActivity();</span><br><span class="line">        secondActivity.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="https://i.loli.net/2018/01/17/5a5f1b4321431.png" alt="2.PNG"></p>
<blockquote>
<p>这里只是简单地举了个模板方法模式的小例子，我们还可以在不同的实现类加上函数，如登陆函数等等，这样一个模板方法就可以被大范围地使用</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>复杂对象的创建-工厂方法模式</title>
    <url>/2018/01/13/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>在Android开发中，最常见的工厂模式应该就是Bitmap的创建了，因为Bitmap的创建是分很多种方式的，我们可以使用本地文件来创建Bitmap对象，也可以使用网络上的资源来创建Bitmap对象，具体方法如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BitmapFactory.decodeResource(this.getResources(),R.drawable.haha); //使用本地文件</span><br><span class="line">HttpURLConnection con = (HttpURLConnection) conurl.openConnection();</span><br><span class="line">BitmapFactory.decodeStream(con.getInputStream()); //使用网络资源</span><br></pre></td></tr></table></figure>
<h4 id="下面来模拟一下Bitmap对象的创建过程"><a href="#下面来模拟一下Bitmap对象的创建过程" class="headerlink" title="下面来模拟一下Bitmap对象的创建过程"></a>下面来模拟一下Bitmap对象的创建过程</h4><ol>
<li>创建抽象产品类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class BitmapProduct &#123;</span><br><span class="line">    //定义属性及方法</span><br><span class="line">    public void method()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建具体产品类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class srcBiamapProduct extends BitmapProduct &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.print(&quot;srcBitmap&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本地文件生成的Bitmap对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class networkBitmapProduct extends BitmapProduct &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.print(&quot;networkBitmapProduct&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>网络资源生成的Bitmap对象</p>
</blockquote>
<ol>
<li>创建抽象工厂类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class BitmapFactory &#123;</span><br><span class="line">    public abstract BitmapProduct createBitmap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建具体工厂类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class concreteFactory extends BitmapFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public BitmapProduct createBitmap() &#123;</span><br><span class="line">        return new srcBiamapProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="使用如下："><a href="#使用如下：" class="headerlink" title="使用如下："></a>使用如下：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BitmapFactory bitmapFactory = new concreteFactory();</span><br><span class="line">        bitmapFactory.createBitmap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="这里的Bitmap创建和我们在Android开发时所使用的工厂模式还是有区别的，因为在Android中Bitmap创建采用的时静态工厂模式，像这样"><a href="#这里的Bitmap创建和我们在Android开发时所使用的工厂模式还是有区别的，因为在Android中Bitmap创建采用的时静态工厂模式，像这样" class="headerlink" title="这里的Bitmap创建和我们在Android开发时所使用的工厂模式还是有区别的，因为在Android中Bitmap创建采用的时静态工厂模式，像这样"></a>这里的Bitmap创建和我们在Android开发时所使用的工厂模式还是有区别的，因为在Android中Bitmap创建采用的时静态工厂模式，像这样</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public  class BitmapFactory &#123;</span><br><span class="line">    public static srcBiamapProduct createBitmap() &#123;</span><br><span class="line">        return new srcBiamapProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="除了上述的一般方法之外，我们也可以使用反射来进行创建，不过鉴于反射会对性能产生影响，要慎用"><a href="#除了上述的一般方法之外，我们也可以使用反射来进行创建，不过鉴于反射会对性能产生影响，要慎用" class="headerlink" title="除了上述的一般方法之外，我们也可以使用反射来进行创建，不过鉴于反射会对性能产生影响，要慎用"></a>除了上述的一般方法之外，我们也可以使用反射来进行创建，不过鉴于反射会对性能产生影响，要慎用</h4><ol>
<li>抽象工厂类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class BitmapFactory &#123;</span><br><span class="line">    public abstract &lt;T extends BitmapProduct&gt; T createBitmap(Class&lt;T&gt; tClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>具体工厂类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class concreteFactory extends BitmapFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T extends BitmapProduct&gt; T createBitmap(Class&lt;T&gt; tClass) &#123;</span><br><span class="line">        BitmapProduct bitmapProduct = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bitmapProduct = (BitmapProduct) Class.forName(tClass.getName()).newInstance();</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return (T) bitmapProduct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BitmapFactory bitmapFactory = new concreteFactory();</span><br><span class="line">        bitmapFactory.createBitmap(srcBiamapProduct.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>创建同一”类别“下的对象-抽象工厂模式</title>
    <url>/2018/01/12/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>抽象工厂模式看起来与工厂方法模式相似，但工厂方法模式构建的是继承同一抽象类的对象，而抽象工厂模式创建出的对象并不是继承于同一基类的，所以，我们无法使用工厂方法模式那样的反射来创建对象</p>
</blockquote>
<h3 id="抽象工厂模式的类主要分为四类，分别是：抽象工厂类、具体工厂类、抽象产品类、具体产品类。"><a href="#抽象工厂模式的类主要分为四类，分别是：抽象工厂类、具体工厂类、抽象产品类、具体产品类。" class="headerlink" title="抽象工厂模式的类主要分为四类，分别是：抽象工厂类、具体工厂类、抽象产品类、具体产品类。"></a>抽象工厂模式的类主要分为四类，分别是：抽象工厂类、具体工厂类、抽象产品类、具体产品类。</h3><blockquote>
<p>与工厂方法模式不同的地方是工厂方法模式的抽象产品类和具体工厂类只有一个，而抽象工厂模式的抽象产品类可能有许多个，具体工厂类也可能有许多个，其相当于每个产品都有不同的组件据称</p>
</blockquote>
<h4 id="抽象产品类"><a href="#抽象产品类" class="headerlink" title="抽象产品类"></a>抽象产品类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractPartA &#123;</span><br><span class="line">    public abstract void statement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractPartB &#123;</span><br><span class="line">    public abstract void statement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体产品类"><a href="#具体产品类" class="headerlink" title="具体产品类"></a>具体产品类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PartA1 extends AbstractPartA &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void statement() &#123;</span><br><span class="line">        System.out.println(&quot;PartA1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PartA2 extends AbstractPartA &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void statement() &#123;</span><br><span class="line">        System.out.println(&quot;PartA2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PartB1 extends AbstractPartB &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void statement() &#123;</span><br><span class="line">        System.out.println(&quot;PartB1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PartB2 extends AbstractPartB &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void statement() &#123;</span><br><span class="line">        System.out.println(&quot;PartB2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的具体产品类类似于一个产品的部件有很多的等级，A与B是两个不同的部件，而A1和A2则代表了两个不同的等级，可以假设这里的A1要比A2好一点，贵一些</p>
<h4 id="抽象工厂类"><a href="#抽象工厂类" class="headerlink" title="抽象工厂类"></a>抽象工厂类</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">    public abstract AbstractPartA createPartA();</span><br><span class="line">    public abstract AbstractPartB createPartB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体工厂类"><a href="#具体工厂类" class="headerlink" title="具体工厂类"></a>具体工厂类</h4><blockquote>
<p>具体工厂类类似于上面各种具体产品的组合</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProductFactoryOne extends AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public AbstractPartA createPartA() &#123;</span><br><span class="line">        return new PartA1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public AbstractPartB createPartB() &#123;</span><br><span class="line">        return new PartB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProductFactoryTwo extends AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public AbstractPartA createPartA() &#123;</span><br><span class="line">        return new PartA2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public AbstractPartB createPartB() &#123;</span><br><span class="line">        return new PartB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="当然，这里的组合方式不知这两种，应该有四种，这里就不一一列举出来了"><a href="#当然，这里的组合方式不知这两种，应该有四种，这里就不一一列举出来了" class="headerlink" title="当然，这里的组合方式不知这两种，应该有四种，这里就不一一列举出来了"></a>当然，这里的组合方式不知这两种，应该有四种，这里就不一一列举出来了</h5>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>原型模式与保护性拷贝</title>
    <url>/2018/01/09/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<blockquote>
<p>原型模式可以理解为直接从已存在的对象中拷贝出一个新对象，在重新创建一个对象消耗较大，但又需要用到两个相互不影响的对象的时候才用到，这是它与单例模式的区别所在</p>
</blockquote>
<h3 id="原型模式中拷贝的方法有浅拷贝和深拷贝两种，浅拷贝因为直接引用对象，所以在修改拷贝出的对象的时候可能会影响到原对象，下面用购物商城的用户举个简单的例子"><a href="#原型模式中拷贝的方法有浅拷贝和深拷贝两种，浅拷贝因为直接引用对象，所以在修改拷贝出的对象的时候可能会影响到原对象，下面用购物商城的用户举个简单的例子" class="headerlink" title="原型模式中拷贝的方法有浅拷贝和深拷贝两种，浅拷贝因为直接引用对象，所以在修改拷贝出的对象的时候可能会影响到原对象，下面用购物商城的用户举个简单的例子"></a>原型模式中拷贝的方法有浅拷贝和深拷贝两种，浅拷贝因为直接引用对象，所以在修改拷贝出的对象的时候可能会影响到原对象，下面用购物商城的用户举个简单的例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User&#123;</span><br><span class="line">    public User()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private String name;</span><br><span class="line">    private Image icon;</span><br><span class="line">    private ArrayList&lt;String&gt; address = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Image getIcon() &#123;</span><br><span class="line">        return icon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setIcon(Image icon) &#123;</span><br><span class="line">        this.icon = icon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ArrayList&lt;String&gt; getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(ArrayList&lt;String&gt; address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><blockquote>
<p>用户有用户名、头像、多个地址，如果要进行拷贝的话应该继承Cloneable接口并重写clone()函数，下面是浅拷贝的例子<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected User clone()  &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           User user = (User)super.clone();</span><br><span class="line">           user.icon = this.icon;</span><br><span class="line">           user.name = this.name;</span><br><span class="line">           user.address = this.address;</span><br><span class="line">           return user;</span><br><span class="line">       &#125; catch (CloneNotSupportedException e)&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么称它为浅拷贝呢？因为在User类中我们使用的是引用型字段，即ArrayList，如果我们对拷贝对象的ArrayList中的对象进行修改，原对象也会受到影响，和拷贝对象中的地址保持一致，所以我们应该使用深拷贝，对引用型字段也进行拷贝，而不是简单地赋值</p>
</blockquote>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected User clone()  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            User user = (User)super.clone();</span><br><span class="line">            user.icon = this.icon;</span><br><span class="line">            user.name = this.name;</span><br><span class="line">            user.address = (ArrayList&lt;String&gt;) this.address.clone(); //对引用型字段进行拷贝</span><br><span class="line">            return user;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>完整代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements Cloneable&#123;</span><br><span class="line">    public User()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private String name;</span><br><span class="line">    private Image icon;</span><br><span class="line">    private ArrayList&lt;String&gt; address = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected User clone()  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            User user = (User)super.clone();</span><br><span class="line">            user.icon = this.icon;</span><br><span class="line">            user.name = this.name;</span><br><span class="line">            user.address = (ArrayList&lt;String&gt;) this.address.clone();</span><br><span class="line">            return user;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Image getIcon() &#123;</span><br><span class="line">        return icon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setIcon(Image icon) &#123;</span><br><span class="line">        this.icon = icon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ArrayList&lt;String&gt; getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(ArrayList&lt;String&gt; address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h3><blockquote>
<p>保护性拷贝其实就是原型模式的一个实际应用，比如说上面举的商城的例子，如果我们在其他需要用到User对象的场景下不小心修改了User对象，那将使服务端和客户端的信息不一致，所以在这个场景下十分适合使用原型模式</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2018/01/08/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>组合模式也称为部分整体模式，它的作用是将一组相似的对象看作一个对象处理，然后提供同一的方法去访问相应对象，这样可以很容易地得到一个树形结构，操作系统中的文件就可以抽象成一个经典的组合模式，如下：</p>
</blockquote>
<h4 id="抽象根节点：抽象文件类"><a href="#抽象根节点：抽象文件类" class="headerlink" title="抽象根节点：抽象文件类"></a>抽象根节点：抽象文件类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Dir &#123;</span><br><span class="line">    protected List&lt;Dir&gt; dirs = new ArrayList&lt;&gt;();</span><br><span class="line">    private String name;</span><br><span class="line">    public Dir(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void addDir(Dir dir);</span><br><span class="line">    public abstract void removeDir(Dir dir);</span><br><span class="line">    public abstract void clear();</span><br><span class="line">    public abstract void print();</span><br><span class="line">    public abstract List&lt;Dir&gt; getFiles();</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体枝干节点：文件夹类"><a href="#具体枝干节点：文件夹类" class="headerlink" title="具体枝干节点：文件夹类"></a>具体枝干节点：文件夹类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Folder extends Dir &#123;</span><br><span class="line">    public Folder(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addDir(Dir dir) &#123;</span><br><span class="line">        dirs.add(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void removeDir(Dir dir) &#123;</span><br><span class="line">        dirs.remove(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        dirs.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.print(getName()+&quot;(&quot;);</span><br><span class="line">        Iterator&lt;Dir&gt; iterator = dirs.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Dir dir = iterator.next();</span><br><span class="line">            dir.print();</span><br><span class="line">            if (iterator.hasNext()) &#123;</span><br><span class="line">                System.out.print(&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;)&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Dir&gt; getFiles() &#123;</span><br><span class="line">        return dirs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体叶子节点：文件类"><a href="#具体叶子节点：文件类" class="headerlink" title="具体叶子节点：文件类"></a>具体叶子节点：文件类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class File extends Dir &#123;</span><br><span class="line">    public File(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addDir(Dir dir) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void removeDir(Dir dir) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.print(getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Dir&gt; getFiles() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;文件对象不支持该操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Dir diskC = new Folder(&quot;C&quot;);</span><br><span class="line">        diskC.addDir(new File(&quot;test.txt&quot;));</span><br><span class="line">        Dir dirWin = new Folder(&quot;Windows&quot;);</span><br><span class="line">        dirWin.addDir(new File(&quot;explorer.exe&quot;));</span><br><span class="line">        diskC.addDir(dirWin);</span><br><span class="line">        diskC.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="https://i.loli.net/2018/01/21/5a63f4efaf63c.png" alt="1.PNG"></p>
<blockquote>
<p>组合文件十分适合数据对象之间存在着递归关系的情景</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式的使用</title>
    <url>/2018/01/06/Intance%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>单例模式适用于重新构造消耗大，又时常需要用到的类，一般又懒汉模式、饿汉模式、DCL模式和静态内部类模式这几种</p>
</blockquote>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Example  &#123;</span><br><span class="line">    private static Example example;</span><br><span class="line">    private Example()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Example getInstance() &#123;</span><br><span class="line">        if (example == null) &#123;</span><br><span class="line">            example = new Example();</span><br><span class="line">        &#125;</span><br><span class="line">        return example;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="懒汉模式在每次获得单例的时候都使用synchronized（加内部锁方式的同步）关键字进行同步，消耗较大"><a href="#懒汉模式在每次获得单例的时候都使用synchronized（加内部锁方式的同步）关键字进行同步，消耗较大" class="headerlink" title="懒汉模式在每次获得单例的时候都使用synchronized（加内部锁方式的同步）关键字进行同步，消耗较大"></a>懒汉模式在每次获得单例的时候都使用synchronized（加内部锁方式的同步）关键字进行同步，消耗较大</h5><h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Example  &#123;</span><br><span class="line">    private static final Example example = new Example();</span><br><span class="line">    private Example()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Example getInstance() &#123;</span><br><span class="line">        return example;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="饿汉模式没有同步的问题，每次获取到的都是同一单例，但不管有没有用到都会创建对象，浪费空间"><a href="#饿汉模式没有同步的问题，每次获取到的都是同一单例，但不管有没有用到都会创建对象，浪费空间" class="headerlink" title="饿汉模式没有同步的问题，每次获取到的都是同一单例，但不管有没有用到都会创建对象，浪费空间"></a>饿汉模式没有同步的问题，每次获取到的都是同一单例，但不管有没有用到都会创建对象，浪费空间</h5><h4 id="DCL模式"><a href="#DCL模式" class="headerlink" title="DCL模式"></a>DCL模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Example  &#123;</span><br><span class="line">   private static volatile Example example = null;</span><br><span class="line">   private Example()&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    public static Example getInstance() &#123;</span><br><span class="line">        if (example == null) &#123;</span><br><span class="line">            synchronized (Example.class) &#123;</span><br><span class="line">                if (example == null) &#123;</span><br><span class="line">                    example = new Example();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return example;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="DCL方法有上面两种单例方法的优点，既保证了使用时才进行初始化，又保证了线程安全，但在某些情况下会有小概率出错，尽管如此，这仍然是用得最广泛的单例方法"><a href="#DCL方法有上面两种单例方法的优点，既保证了使用时才进行初始化，又保证了线程安全，但在某些情况下会有小概率出错，尽管如此，这仍然是用得最广泛的单例方法" class="headerlink" title="DCL方法有上面两种单例方法的优点，既保证了使用时才进行初始化，又保证了线程安全，但在某些情况下会有小概率出错，尽管如此，这仍然是用得最广泛的单例方法"></a>DCL方法有上面两种单例方法的优点，既保证了使用时才进行初始化，又保证了线程安全，但在某些情况下会有小概率出错，尽管如此，这仍然是用得最广泛的单例方法</h5><h4 id="静态内部类模式"><a href="#静态内部类模式" class="headerlink" title="静态内部类模式"></a>静态内部类模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Example  &#123;</span><br><span class="line"></span><br><span class="line">   private Example()&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static Example getInstance() &#123;</span><br><span class="line">       return ExampleHolder.example;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static class ExampleHolder &#123;</span><br><span class="line">       private static final Example example = new Example();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="既保证了线程安全，也达到了节省资源的目的，是推荐使用的单例模式"><a href="#既保证了线程安全，也达到了节省资源的目的，是推荐使用的单例模式" class="headerlink" title="既保证了线程安全，也达到了节省资源的目的，是推荐使用的单例模式"></a>既保证了线程安全，也达到了节省资源的目的，是推荐使用的单例模式</h5><h4 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Example &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void doSomething()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="枚举模式是实现单例最简单的模式，因为枚举本身就具有线程安全性，所以我们无需担心线程安全的问题，而且枚举安全也避免了序列化时重新生成对象的问题（当然，这个问题我们一般碰不到）"><a href="#枚举模式是实现单例最简单的模式，因为枚举本身就具有线程安全性，所以我们无需担心线程安全的问题，而且枚举安全也避免了序列化时重新生成对象的问题（当然，这个问题我们一般碰不到）" class="headerlink" title="枚举模式是实现单例最简单的模式，因为枚举本身就具有线程安全性，所以我们无需担心线程安全的问题，而且枚举安全也避免了序列化时重新生成对象的问题（当然，这个问题我们一般碰不到）"></a>枚举模式是实现单例最简单的模式，因为枚举本身就具有线程安全性，所以我们无需担心线程安全的问题，而且枚举安全也避免了序列化时重新生成对象的问题（当然，这个问题我们一般碰不到）</h5><h4 id="总结，单例模式分成了上面几种，一般推荐使用静态内部类实现单例，DCL模式虽然是应用最为广泛的模式，但因为java的内存模型还存在着小概率的问题，而Google官方不推荐使用枚举模式"><a href="#总结，单例模式分成了上面几种，一般推荐使用静态内部类实现单例，DCL模式虽然是应用最为广泛的模式，但因为java的内存模型还存在着小概率的问题，而Google官方不推荐使用枚举模式" class="headerlink" title="总结，单例模式分成了上面几种，一般推荐使用静态内部类实现单例，DCL模式虽然是应用最为广泛的模式，但因为java的内存模型还存在着小概率的问题，而Google官方不推荐使用枚举模式"></a>总结，单例模式分成了上面几种，一般推荐使用静态内部类实现单例，DCL模式虽然是应用最为广泛的模式，但因为java的内存模型还存在着小概率的问题，而Google官方不推荐使用枚举模式</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>策略模式：再见if-else</title>
    <url>/2018/01/05/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%86%8D%E8%A7%81if-else/</url>
    <content><![CDATA[<blockquote>
<p>在软件开发中，我们时常用到if-else来对进行条件判断，然后再进行相应的操作，但这样做会使得项目再日后的维护中出现困难，所以，当遇到比较复杂的if-else结构的时候，使用策略模式是很好的选择</p>
</blockquote>
<h4 id="举一个简单的计算小例子，如对两个数进行加减乘除"><a href="#举一个简单的计算小例子，如对两个数进行加减乘除" class="headerlink" title="举一个简单的计算小例子，如对两个数进行加减乘除"></a>举一个简单的计算小例子，如对两个数进行加减乘除</h4><h5 id="第一步，定义计算接口"><a href="#第一步，定义计算接口" class="headerlink" title="第一步，定义计算接口"></a>第一步，定义计算接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface CalculateStrategy &#123;</span><br><span class="line">    int calculateComeout(int number1, int number2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第二步，实现策略类"><a href="#第二步，实现策略类" class="headerlink" title="第二步，实现策略类"></a>第二步，实现策略类</h5><ol>
<li><p>加法策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PlusStrategy implements CalculateStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int calculateComeout(int number1, int number2) &#123;</span><br><span class="line">        return number1 + number2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>减法策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MinusStrategy implements CalculateStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int calculateComeout(int number1, int number2) &#123;</span><br><span class="line">        return number1 - number2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="实例运行"><a href="#实例运行" class="headerlink" title="实例运行"></a>实例运行</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       int number1 = 20, number2 = 10;</span><br><span class="line">       new PlusStrategy().calculateComeout(number1, number2);</span><br><span class="line">       new MinusStrategy().calculateComeout(number1,number2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然，这只是一个十分简单的实例，再实际应用中远没有这么“鸡肋”，比如我曾经开发过的一个小项目</p>
</blockquote>
<h4 id="策略模式实战"><a href="#策略模式实战" class="headerlink" title="策略模式实战"></a>策略模式实战</h4><blockquote>
<p>OpeningStartAnimation是一个开屏动画View，所以这里的策略模式是与绘画策略相关的</p>
</blockquote>
<ol>
<li>绘画策略接口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface DrawStrategy &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 绘制app名称文字</span><br><span class="line">     * @param canvas 画布</span><br><span class="line">     * @param fraction 完成时间百分比</span><br><span class="line">     * @param colorOfAppName 字体颜色</span><br><span class="line">     * @param name 文字</span><br><span class="line">     * @param widthAndHeightOfView view的宽和高</span><br><span class="line">     */</span><br><span class="line">    void drawAppName(Canvas canvas, float fraction, String name, int colorOfAppName,</span><br><span class="line">                     WidthAndHeightOfView widthAndHeightOfView);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 绘制app图标</span><br><span class="line">     * @param canvas 画布</span><br><span class="line">     * @param fraction 完成时间百分比</span><br><span class="line">     * @param colorOfIcon 绘制图标颜色</span><br><span class="line">     * @param icon 图标</span><br><span class="line">     * @param widthAndHeightOfView view的宽和高</span><br><span class="line">     */</span><br><span class="line">    void drawAppIcon(Canvas canvas, float fraction, Drawable icon, int colorOfIcon,</span><br><span class="line">                     WidthAndHeightOfView widthAndHeightOfView);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 绘制app一句话描述</span><br><span class="line">     * @param canvas 画布</span><br><span class="line">     * @param fraction 完成时间百分比</span><br><span class="line">     * @param statement 一句话描述</span><br><span class="line">     * @param colorOfStatement 字体颜色</span><br><span class="line">     * @param widthAndHeightOfView view的宽和高</span><br><span class="line">     */</span><br><span class="line">    void drawAppStatement(Canvas canvas, float fraction, String statement, int colorOfStatement,</span><br><span class="line">                          WidthAndHeightOfView widthAndHeightOfView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>其中的一个具体实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LineDrawStrategy implements DrawStrategy &#123;</span><br><span class="line"></span><br><span class="line">    public LineDrawStrategy()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void drawAppName(Canvas canvas, float fraction, String name, int colorOfAppName,</span><br><span class="line">                            WidthAndHeightOfView widthAndHeightOfView) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        paint.setColor(colorOfAppName);</span><br><span class="line">        paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        paint.setStrokeWidth(5);</span><br><span class="line">        paint.setTextSize(50);</span><br><span class="line">        paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class="line">        paint.setTextAlign(Paint.Align.LEFT);</span><br><span class="line">        float x = widthAndHeightOfView.getWidth() / 2;</span><br><span class="line">        int centerY = widthAndHeightOfView.getHeight() / 2;</span><br><span class="line">        float y = centerY - 275;</span><br><span class="line">        Path path = new Path();</span><br><span class="line">        path.moveTo(x, y);</span><br><span class="line">        if (fraction &lt;= 0.50) &#123;</span><br><span class="line">            path.lineTo(x, y + (25 + name.length() + 250) * (fraction / 0.50f));</span><br><span class="line">            canvas.drawPath(path, paint);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            path.lineTo(x, y + (25 + name.length() + 250) * ((1 - fraction)/ 0.50f));</span><br><span class="line">            canvas.drawPath(path, paint);</span><br><span class="line">            paint.setStyle(Paint.Style.FILL);</span><br><span class="line">            canvas.drawText(name, x + 20, y + 150, paint);</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void drawAppIcon(Canvas canvas, float fraction, Drawable icon, int colorOfIcon,</span><br><span class="line">                            WidthAndHeightOfView widthAndHeightOfView) &#123;</span><br><span class="line">        int centerX = widthAndHeightOfView.getWidth() / 2;</span><br><span class="line">        int centerY = widthAndHeightOfView.getHeight() / 2;</span><br><span class="line">        Bitmap bitmap = ((BitmapDrawable) icon).getBitmap();</span><br><span class="line">        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        paint.setColor(colorOfIcon);</span><br><span class="line">        paint.setStrokeWidth(3);</span><br><span class="line">        paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class="line">        paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        float bitmapLeft = centerX - 250;</span><br><span class="line">        float bitmapRight = bitmapLeft + bitmap.getWidth() * 1.7f;</span><br><span class="line">        float bitmapTop = centerY - 250;</span><br><span class="line">        float bitmapBottom = bitmapTop + bitmap.getHeight() * 1.7f;</span><br><span class="line">        canvas.save();</span><br><span class="line">        if (fraction &lt;= 0.75) &#123;</span><br><span class="line">            float newfraction = fraction / 0.75f;</span><br><span class="line">            if (newfraction &lt;= 0.25) &#123;</span><br><span class="line">                canvas.drawLine(bitmapLeft, bitmapBottom, bitmapLeft,</span><br><span class="line">                        bitmapBottom - (bitmapBottom - bitmapTop) * (newfraction / 0.25f), paint);</span><br><span class="line">              //  path.lineTo(bitmapLeft, bitmapBottom + (bitmapBottom - bitmapTop) * (newfraction / 0.25f));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                canvas.drawLine(bitmapLeft, bitmapBottom, bitmapLeft, bitmapTop, paint);</span><br><span class="line">              //  path.lineTo(bitmapLeft, bitmapTop);</span><br><span class="line">            &#125;</span><br><span class="line">            if (newfraction &gt; 0.25) &#123;</span><br><span class="line">                if (newfraction &lt;= 0.50) &#123;</span><br><span class="line">                    canvas.drawLine(bitmapLeft, bitmapTop,</span><br><span class="line">                            bitmapLeft + (bitmapRight - bitmapLeft) * ((newfraction - 0.25f)/0.25f),</span><br><span class="line">                            bitmapTop, paint);</span><br><span class="line">                  //  path.lineTo(bitmapLeft + (bitmapRight - bitmapLeft) * ((newfraction - 0.25f)/0.25f),</span><br><span class="line">                   //         bitmapTop);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    canvas.drawLine(bitmapLeft, bitmapTop, bitmapRight, bitmapTop, paint);</span><br><span class="line">                   // path.lineTo(bitmapRight, bitmapTop);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (newfraction &gt; 0.50) &#123;</span><br><span class="line">                if (newfraction &lt;= 0.75) &#123;</span><br><span class="line">                    canvas.drawLine(bitmapRight, bitmapTop, bitmapRight,</span><br><span class="line">                            bitmapTop + (bitmapBottom - bitmapTop) * ((newfraction - 0.50f) / 0.25f),</span><br><span class="line">                            paint);</span><br><span class="line">                    //path.lineTo(bitmapRight, bitmapTop + (bitmapBottom - bitmapTop) * ((fraction - 0.50f) / 0.25f));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    canvas.drawLine(bitmapRight, bitmapTop, bitmapRight, bitmapBottom, paint);</span><br><span class="line">                    //path.lineTo(bitmapRight, bitmapBottom);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (newfraction &gt; 0.75) &#123;</span><br><span class="line">                if (newfraction &lt;= 1) &#123;</span><br><span class="line">                    canvas.drawLine(bitmapRight, bitmapBottom, bitmapRight - (bitmapRight - bitmapLeft) * ((newfraction - 0.75f)/ 0.25f),</span><br><span class="line">                                     bitmapBottom, paint);</span><br><span class="line">                   // path.lineTo(bitmapLeft + (bitmapRight - bitmapLeft) * ((fraction - 0.75f)/ 0.25f),</span><br><span class="line">                   //         bitmapBottom);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    canvas.drawLine(bitmapRight, bitmapBottom, bitmapLeft, bitmapBottom, paint);</span><br><span class="line">                   // path.lineTo(bitmapLeft, bitmapBottom);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.restore();</span><br><span class="line">        canvas.save();</span><br><span class="line">        if (fraction &gt; 0.75) &#123;</span><br><span class="line">            canvas.clipRect(bitmapLeft + (bitmap.getWidth()/2f) * ((1 - fraction) /0.25f),</span><br><span class="line">                    bitmapTop + (bitmap.getHeight()/2f)* ((1 - fraction) / 0.25f),</span><br><span class="line">                    bitmapRight - (bitmap.getWidth()/2f) * ((1 - fraction) /0.25f),</span><br><span class="line">                    bitmapBottom - (bitmap.getHeight()/2f)* ((1 - fraction) / 0.25f));</span><br><span class="line">            Matrix matrix = new Matrix();</span><br><span class="line">            matrix.postScale(1.7f, 1.7f, (bitmapLeft + bitmapRight) * 0.5f,</span><br><span class="line">                    (bitmapTop + bitmapBottom) * 0.5f);</span><br><span class="line">            canvas.concat(matrix);</span><br><span class="line">            canvas.drawBitmap(bitmap, (bitmapLeft + bitmapRight) / 2 - bitmap.getWidth() / 2,</span><br><span class="line">                    (bitmapTop + bitmapBottom) / 2 - bitmap.getHeight() / 2, paint);</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void drawAppStatement(Canvas canvas, float fraction, String statement, int colorOfStatement,</span><br><span class="line">                                 WidthAndHeightOfView widthAndHeightOfView) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        int width = widthAndHeightOfView.getWidth();</span><br><span class="line">        int height = widthAndHeightOfView.getHeight();</span><br><span class="line">        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        paint.setColor(colorOfStatement);</span><br><span class="line">        paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        paint.setTextSize(45);</span><br><span class="line">        paint.setTextSkewX(-0.2f);</span><br><span class="line">        paint.setTextAlign(Paint.Align.CENTER);</span><br><span class="line">        RectF rectF = new RectF(width / 4 - statement.length(), height * 7 / 8,</span><br><span class="line">                width * 3, height);</span><br><span class="line">        if (fraction &lt;= 0.60f) &#123;</span><br><span class="line">            Path path = new Path();</span><br><span class="line">            path.addArc(rectF,193,40 * fraction * 1.67f);</span><br><span class="line">            canvas.drawPath(path, paint);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Path path = new Path();</span><br><span class="line">            path.addArc(rectF, 193, 40);</span><br><span class="line">            canvas.drawPath(path, paint);</span><br><span class="line">            canvas.drawTextOnPath(statement, path, 0, 0, paint);</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>示例</li>
</ol>
<blockquote>
<p>这是选择策略的方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">         * 开放绘制策略接口，可由用户自行定义</span><br><span class="line">         * @param drawStrategy 绘制接口</span><br><span class="line">         * @return Builder对象</span><br><span class="line">         */</span><br><span class="line">        public Builder setDrawStategy(DrawStrategy drawStrategy) &#123;</span><br><span class="line">            mOpeningStartAnimation.mDrawStrategy = drawStrategy;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>策略的具体实现</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">       canvas.drawColor(colorOfBackground); //绘制背景色</span><br><span class="line">       super.onDraw(canvas);</span><br><span class="line">       mWidthAndHeightOfView.setHeight(getHeight());</span><br><span class="line">       mWidthAndHeightOfView.setWidth(getWidth());</span><br><span class="line">       mDrawStrategy.drawAppIcon(canvas, fraction, mDrawable, colorOfAppIcon,</span><br><span class="line">               mWidthAndHeightOfView);</span><br><span class="line">       mDrawStrategy.drawAppName(canvas, fraction, appName, colorOfAppName,</span><br><span class="line">               mWidthAndHeightOfView);</span><br><span class="line">       mDrawStrategy.drawAppStatement(canvas, fraction, appStatement, colorOfAppStatement,</span><br><span class="line">               mWidthAndHeightOfView);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>具体项目可见</p>
<p><a href="https://github.com/JoshuaRogue/FancyView" target="_blank" rel="noopener">项目地址</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式中的车轮战-责任链模式</title>
    <url>/2018/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%BD%A6%E8%BD%AE%E6%88%98-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>责任链模式在Android中的应用莫过于事件分发了，ViewGroup对事件分别给子View，从ViewTree的顶部至上而下地进行处理，直到事件被消化为止，这种方法在Android广播中也能看到</p>
</blockquote>
<p>责任链模式的实现分为以下几个部分</p>
<h4 id="请求者"><a href="#请求者" class="headerlink" title="请求者"></a>请求者</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public  class Request &#123;</span><br><span class="line">    private Object object;</span><br><span class="line">    private int RequestLevel;</span><br><span class="line">    public Request(Object object,int requestLevel) &#123;</span><br><span class="line">        this.object = object;</span><br><span class="line">        this.RequestLevel = requestLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getObject() &#123;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getRequestLevel() &#123;</span><br><span class="line">        return RequestLevel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的object在实际开发当中我们可以换成其他自定义的对象，如Android中的Message和Handler那样</p>
</blockquote>
<h4 id="抽象处理者"><a href="#抽象处理者" class="headerlink" title="抽象处理者"></a>抽象处理者</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractHandler &#123;</span><br><span class="line">    private AbstractHandler nextHandler;</span><br><span class="line">    public final void handleRequest(Request request) &#123;</span><br><span class="line">        if (getHandlerLevel() == request.getRequestLevel()) &#123;</span><br><span class="line">            handle(request);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (nextHandler != null) &#123;</span><br><span class="line">                nextHandler.handleRequest(request);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;No handler can handle it!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNextHandler(AbstractHandler nextHandler) &#123;</span><br><span class="line">        this.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract int getHandlerLevel();</span><br><span class="line"></span><br><span class="line">    protected abstract void handle(Request request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理者"><a href="#处理者" class="headerlink" title="处理者"></a>处理者</h4><ol>
<li>处理者1</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Handler1 extends AbstractHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void handle(Request request) &#123;</span><br><span class="line">        System.out.println(&quot;handler1 handle it&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected int getHandlerLevel() &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>处理者2</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Handler2 extends AbstractHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected int getHandlerLevel() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handle(Request request) &#123;</span><br><span class="line">        System.out.println(&quot;handler2 handle it&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbstractHandler handler1 = new Handler1();</span><br><span class="line">        AbstractHandler handler2 = new Handler2();</span><br><span class="line">        handler1.setNextHandler(handler2);</span><br><span class="line">        Request request = new Request(&quot;request&quot;,2);</span><br><span class="line">        handler1.handleRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样处理事件就会沿着责任链一个个下去，直到被处理者处理或没有处理者为止</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>OpeningStartAnimation - Android开屏动画view</title>
    <url>/2017/12/26/OpeningStartAnimation%20-%20Android%E5%BC%80%E5%B1%8F%E5%8A%A8%E7%94%BBview/</url>
    <content><![CDATA[<h4 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://github.com/JoshuaRogue/FancyView" target="_blank" rel="noopener">https://github.com/JoshuaRogue/FancyView</a></p>
<h4 id="使用后效果如下："><a href="#使用后效果如下：" class="headerlink" title="使用后效果如下："></a>使用后效果如下：</h4><p><img src="http://img.blog.csdn.net/20171218134614196?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20171218134631999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20171218134644097?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20171218134705691?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>使用方法：</p>
<ol>
<li><p>在项目中添加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;site.gemus:openingstartanimation:1.0.0&apos; //在gradle中导入项目</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<blockquote>
<p>OpeningStartAnimation.Builder(Context context)  //context为当前活动的baseContext</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>OpeningStartAnimation.show(Activity mactivity) //mactivity为当前显示的activity<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpeningStartAnimation openingStartAnimation = new OpeningStartAnimation.Builder(this)</span><br><span class="line">                        .create();</span><br><span class="line">                openingStartAnimation.show(this);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="默认的效果为图1，可使用Builder-setDrawStategy-方法指定其他三种效果，图2、3、4分别对应了RedYellowBlueDrawStrategy，LineDrawStrategy和RotationDrawStrategy三种动画效果，也可以自定义接口实现动画，如下所示"><a href="#默认的效果为图1，可使用Builder-setDrawStategy-方法指定其他三种效果，图2、3、4分别对应了RedYellowBlueDrawStrategy，LineDrawStrategy和RotationDrawStrategy三种动画效果，也可以自定义接口实现动画，如下所示" class="headerlink" title="默认的效果为图1，可使用Builder.setDrawStategy() 方法指定其他三种效果，图2、3、4分别对应了RedYellowBlueDrawStrategy，LineDrawStrategy和RotationDrawStrategy三种动画效果，也可以自定义接口实现动画，如下所示"></a>默认的效果为图1，可使用<strong>Builder.setDrawStategy()</strong> 方法指定其他三种效果，图2、3、4分别对应了RedYellowBlueDrawStrategy，LineDrawStrategy和RotationDrawStrategy三种动画效果，也可以自定义接口实现动画，如下所示</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpeningStartAnimation openingStartAnimation = new OpeningStartAnimation.Builder(this)</span><br><span class="line">                .setDrawStategy(new DrawStrategy() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void drawAppName(Canvas canvas, float fraction, String name, int colorOfAppName, WidthAndHeightOfView widthAndHeightOfView) &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void drawAppIcon(Canvas canvas, float fraction, Drawable icon, int colorOfIcon, WidthAndHeightOfView widthAndHeightOfView) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void drawAppStatement(Canvas canvas, float fraction, String statement, int colorOfStatement, WidthAndHeightOfView widthAndHeightOfView) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).create();</span><br></pre></td></tr></table></figure>
<h4 id="也可以通过其他set函数指定图标，应用名，应用一句话描述等等，如下所示"><a href="#也可以通过其他set函数指定图标，应用名，应用一句话描述等等，如下所示" class="headerlink" title="也可以通过其他set函数指定图标，应用名，应用一句话描述等等，如下所示"></a>也可以通过其他set函数指定图标，应用名，应用一句话描述等等，如下所示</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpeningStartAnimation openingStartAnimation = new OpeningStartAnimation.Builder(this)</span><br><span class="line">               .setAppIcon() //设置图标</span><br><span class="line">               .setColorOfAppIcon() //设置绘制图标线条的颜色</span><br><span class="line">               .setAppName() //设置app名称</span><br><span class="line">               .setColorOfAppName() //设置app名称颜色</span><br><span class="line">               .setAppStatement() //设置一句话描述</span><br><span class="line">               .setColorOfAppStatement() // 设置一句话描述的颜色</span><br><span class="line">               .setAnimationInterval() // 设置动画时间间隔</span><br><span class="line">               .setAnimationFinishTime() // 设置动画的消失时长</span><br><span class="line">               .create();</span><br></pre></td></tr></table></figure>
<h5 id="觉得好用的话别忘了赏个star哦，github地址如下"><a href="#觉得好用的话别忘了赏个star哦，github地址如下" class="headerlink" title="觉得好用的话别忘了赏个star哦，github地址如下"></a>觉得好用的话别忘了赏个star哦，github地址如下</h5><blockquote>
<p><a href="https://github.com/JoshuaRogue/FancyView" target="_blank" rel="noopener">https://github.com/JoshuaRogue/FancyView</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>发布Android开源项目到Jcenter库</title>
    <url>/2017/12/10/%E5%8F%91%E5%B8%83Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%88%B0Jcenter%E5%BA%93/</url>
    <content><![CDATA[<h4 id="我们在使用Android-studio时，导入一个第三方开源库很方便，如果整个库已经被发布到Maven库时，我们只需要在MainActivity所在的build-gradle（注意不是最外层的）中添加依赖即可，像这样"><a href="#我们在使用Android-studio时，导入一个第三方开源库很方便，如果整个库已经被发布到Maven库时，我们只需要在MainActivity所在的build-gradle（注意不是最外层的）中添加依赖即可，像这样" class="headerlink" title="我们在使用Android studio时，导入一个第三方开源库很方便，如果整个库已经被发布到Maven库时，我们只需要在MainActivity所在的build.gradle（注意不是最外层的）中添加依赖即可，像这样"></a>我们在使用Android studio时，导入一个第三方开源库很方便，如果整个库已经被发布到Maven库时，我们只需要在MainActivity所在的build.gradle（注意不是最外层的）中添加依赖即可，像这样</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br><span class="line">implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里只是举个例子，实际上这两个都是官方的库，在Android studio 3.0中不再默认使用compile而是使用implementation来引入，这里注意一下</p>
<h4 id="如果我们想要把自己做的一个库发布到Maven库上，让其他人也能这么方便地使用的话，-我们应该把库中的文件独立出来成一个Android-library，这样在后续打包的时候你就能把整个库独立打包，而不是和项目中其他的一些文件一起打包（比如说与库的实现无关的Activity和它的布局文件，还有一些其他的配置文件），像下面这样"><a href="#如果我们想要把自己做的一个库发布到Maven库上，让其他人也能这么方便地使用的话，-我们应该把库中的文件独立出来成一个Android-library，这样在后续打包的时候你就能把整个库独立打包，而不是和项目中其他的一些文件一起打包（比如说与库的实现无关的Activity和它的布局文件，还有一些其他的配置文件），像下面这样" class="headerlink" title="如果我们想要把自己做的一个库发布到Maven库上，让其他人也能这么方便地使用的话， 我们应该把库中的文件独立出来成一个Android library，这样在后续打包的时候你就能把整个库独立打包，而不是和项目中其他的一些文件一起打包（比如说与库的实现无关的Activity和它的布局文件，还有一些其他的配置文件），像下面这样"></a>如果我们想要把自己做的一个库发布到Maven库上，让其他人也能这么方便地使用的话， 我们应该把库中的文件独立出来成一个Android library，这样在后续打包的时候你就能把整个库独立打包，而不是和项目中其他的一些文件一起打包（比如说与库的实现无关的Activity和它的布局文件，还有一些其他的配置文件），像下面这样</h4><ol>
<li><img src="http://img.blog.csdn.net/20171218101159513?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li>
<li><img src="http://img.blog.csdn.net/20171218101219101?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li>
<li><img src="http://img.blog.csdn.net/20171218101314644?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>在这里库的名字（红圈圈出来的）需要注意了，这个就是在将来引入库的时候，两个‘：’之间的库名称，像<strong>com.squareup.okhttp:okhttp:2.0.0</strong>，’:’后面的okhttp就是库的名字，这关系到将来发布之后时怎么个样子，所以特地拿出来说一下。<h4 id="接下来就是把去完成这个库了，完成之后你会发现在主应用-就是app文件夹中的-，比如说在MainActivity中，是无法使用这个库的，因为我们还少了一步，在主应用的依赖里加入这个库，因为加入的是本地库，所以只需要这么写"><a href="#接下来就是把去完成这个库了，完成之后你会发现在主应用-就是app文件夹中的-，比如说在MainActivity中，是无法使用这个库的，因为我们还少了一步，在主应用的依赖里加入这个库，因为加入的是本地库，所以只需要这么写" class="headerlink" title="接下来就是把去完成这个库了，完成之后你会发现在主应用(就是app文件夹中的)，比如说在MainActivity中，是无法使用这个库的，因为我们还少了一步，在主应用的依赖里加入这个库，因为加入的是本地库，所以只需要这么写"></a>接下来就是把去完成这个库了，完成之后你会发现在主应用(就是app文件夹中的)，比如说在MainActivity中，是无法使用这个库的，因为我们还少了一步，在主应用的依赖里加入这个库，因为加入的是本地库，所以只需要这么写</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile project(&quot;:openingstartanimation&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>openingstartanimation是我自己写的库名称，在这里填入你自己的</p>
<h4 id="已经做好这一步的话（其实如果不需要app使用这个库的话上一步可以不做，不过我们总得测试一下自己的库哈哈哈哈），就可以做一些把库发布到Jcenter上了。"><a href="#已经做好这一步的话（其实如果不需要app使用这个库的话上一步可以不做，不过我们总得测试一下自己的库哈哈哈哈），就可以做一些把库发布到Jcenter上了。" class="headerlink" title="已经做好这一步的话（其实如果不需要app使用这个库的话上一步可以不做，不过我们总得测试一下自己的库哈哈哈哈），就可以做一些把库发布到Jcenter上了。"></a>已经做好这一步的话（其实如果不需要app使用这个库的话上一步可以不做，不过我们总得测试一下自己的库哈哈哈哈），就可以做一些把库发布到Jcenter上了。</h4><h4 id="再Jcenter上注册账号，地址如下："><a href="#再Jcenter上注册账号，地址如下：" class="headerlink" title="再Jcenter上注册账号，地址如下："></a>再Jcenter上注册账号，地址如下：</h4><p><a href="https://bintray.com/signup/oss" target="_blank" rel="noopener">https://bintray.com/signup/oss</a> （这个是开源项目的注册）</p>
<h5 id="我在注册的时候遇到了个小坑，使用国内的qq邮箱注册无法被识别，使用谷歌邮箱注册也老是出错，建议大家直接使用边上的-sign-up-with-google-或者直接使用-sign-in-with-google-这样的出错几率比较小。"><a href="#我在注册的时候遇到了个小坑，使用国内的qq邮箱注册无法被识别，使用谷歌邮箱注册也老是出错，建议大家直接使用边上的-sign-up-with-google-或者直接使用-sign-in-with-google-这样的出错几率比较小。" class="headerlink" title="我在注册的时候遇到了个小坑，使用国内的qq邮箱注册无法被识别，使用谷歌邮箱注册也老是出错，建议大家直接使用边上的 sign up with google 或者直接使用 sign in with google ,这样的出错几率比较小。"></a>我在注册的时候遇到了个小坑，使用国内的qq邮箱注册无法被识别，使用谷歌邮箱注册也老是出错，建议大家直接使用边上的 <strong>sign up with google</strong> 或者直接使用 <strong>sign in with google</strong> ,这样的出错几率比较小。</h5><h4 id="注册成功之后进入个人中心，点左上角的edit进入个人配置，找到apikey，这个等等会用到。之后再回退到上一个页面，先-add-new-Repository-创建自己的maven库，这里的name一栏填的名字需要注意一下，这在后面也会用到，建议直接填maven，然后type的类型也是maven，开源协议则一般选择Apache2-0，创建完成之后再回到Android-studio配置一下文件。"><a href="#注册成功之后进入个人中心，点左上角的edit进入个人配置，找到apikey，这个等等会用到。之后再回退到上一个页面，先-add-new-Repository-创建自己的maven库，这里的name一栏填的名字需要注意一下，这在后面也会用到，建议直接填maven，然后type的类型也是maven，开源协议则一般选择Apache2-0，创建完成之后再回到Android-studio配置一下文件。" class="headerlink" title="注册成功之后进入个人中心，点左上角的edit进入个人配置，找到apikey，这个等等会用到。之后再回退到上一个页面，先 add new Repository 创建自己的maven库，这里的name一栏填的名字需要注意一下，这在后面也会用到，建议直接填maven，然后type的类型也是maven，开源协议则一般选择Apache2.0，创建完成之后再回到Android studio配置一下文件。"></a>注册成功之后进入个人中心，点左上角的edit进入个人配置，找到apikey，这个<strong>等等会用到</strong>。之后再回退到上一个页面，先 <strong>add new Repository</strong> 创建自己的maven库，这里的<strong>name一栏填的名字需要注意一下，这在后面也会用到，建议直接填maven</strong>，然后type的类型也是maven，开源协议则一般选择<strong>Apache2.0</strong>，创建完成之后再回到Android studio配置一下文件。</h4><h3 id="第一步，在最外层的build-gradle中加入依赖，如下"><a href="#第一步，在最外层的build-gradle中加入依赖，如下" class="headerlink" title="第一步，在最外层的build.gradle中加入依赖，如下"></a>第一步，在<strong>最外层的build.gradle</strong>中加入依赖，如下</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    </span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">    classpath &apos;com.android.tools.build:gradle:3.0.1&apos;</span><br><span class="line">    classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&apos; //新添加的</span><br><span class="line">    classpath &apos;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.2&apos;   //新添加的</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="第二步，在库中的build-gradle-中填写maven库的配置，下面是我的build-gradle的完整的内容"><a href="#第二步，在库中的build-gradle-中填写maven库的配置，下面是我的build-gradle的完整的内容" class="headerlink" title="第二步，在库中的build.gradle 中填写maven库的配置，下面是我的build.gradle的完整的内容"></a>第二步，在<strong>库中的build.gradle</strong> 中填写maven库的配置，下面是我的build.gradle的完整的内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &apos;com.android.library&apos;</span><br><span class="line">apply plugin: &apos;com.github.dcendents.android-maven&apos;</span><br><span class="line">apply plugin: &apos;com.jfrog.bintray&apos;</span><br><span class="line">// This is the library version used when deploying the artifact</span><br><span class="line">version = &quot;1.0.0&quot;</span><br><span class="line"></span><br><span class="line">def siteUrl = &apos;&apos;      // 项目的主页</span><br><span class="line">def gitUrl = &apos;https://github.com/JoshuaRogue/FancyView.git&apos;   // Git仓库的url</span><br><span class="line">group = &quot;&quot;      // Maven Group ID for the artifact，一般填你唯一的包名</span><br><span class="line">install &#123;</span><br><span class="line">    repositories.mavenInstaller &#123;</span><br><span class="line">        // This generates POM.xml with proper parameters</span><br><span class="line">        pom &#123;</span><br><span class="line">            project &#123;</span><br><span class="line">                packaging &apos;aar&apos;</span><br><span class="line">                // Add your description here</span><br><span class="line">                name &apos;maven&apos;</span><br><span class="line">                url siteUrl</span><br><span class="line">                // Set your license</span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        name &apos;The Apache Software License, Version 2.0&apos;</span><br><span class="line">                        url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                developers &#123;</span><br><span class="line">                    developer &#123;</span><br><span class="line">                        id &apos;&apos;     //填写的一些基本信息</span><br><span class="line">                        name &apos;&apos;</span><br><span class="line">                        email &apos;&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                scm &#123;</span><br><span class="line">                    connection gitUrl</span><br><span class="line">                    developerConnection gitUrl</span><br><span class="line">                    url siteUrl</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task sourcesJar(type: Jar) &#123;</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">    classifier = &apos;sources&apos;</span><br><span class="line">&#125;</span><br><span class="line">task javadoc(type: Javadoc) &#123;</span><br><span class="line">    source = android.sourceSets.main.java.srcDirs</span><br><span class="line">&#125;</span><br><span class="line">task javadocJar(type: Jar, dependsOn: javadoc) &#123;</span><br><span class="line">    classifier = &apos;javadoc&apos;</span><br><span class="line">    from javadoc.destinationDir</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives javadocJar</span><br><span class="line">    archives sourcesJar</span><br><span class="line">&#125;</span><br><span class="line">Properties properties = new Properties()</span><br><span class="line">properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())</span><br><span class="line">bintray &#123;</span><br><span class="line">    user = properties.getProperty(&quot;bintray.user&quot;)</span><br><span class="line">    key = properties.getProperty(&quot;bintray.apikey&quot;)</span><br><span class="line">    configurations = [&apos;archives&apos;]</span><br><span class="line">    pkg &#123;</span><br><span class="line">        repo = &quot;&quot;    //这是刚刚在创建maven库时的name</span><br><span class="line">        name = &quot;&quot;   //发布到JCenter上的项目名字</span><br><span class="line">        websiteUrl = siteUrl</span><br><span class="line">        vcsUrl = gitUrl</span><br><span class="line">        licenses = [&quot;Apache-2.0&quot;]</span><br><span class="line">        publish = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">javadoc &#123; //jav doc采用utf-8编码否则会报“GBK的不可映射字符”错误</span><br><span class="line">    options&#123;</span><br><span class="line">        encoding &quot;UTF-8&quot;</span><br><span class="line">        charSet &apos;UTF-8&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 26</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 16</span><br><span class="line">        targetSdkVersion 26</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line"></span><br><span class="line">    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br><span class="line">    testImplementation &apos;junit:junit:4.12&apos;</span><br><span class="line">    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;</span><br><span class="line">    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="还有一步别忘了，在最外层的local-propersitory中加入你的用户名和密码信息，如下"><a href="#还有一步别忘了，在最外层的local-propersitory中加入你的用户名和密码信息，如下" class="headerlink" title="还有一步别忘了，在最外层的local.propersitory中加入你的用户名和密码信息，如下:"></a>还有一步别忘了，在最外层的local.propersitory中加入你的用户名和密码信息，如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#bintray</span><br><span class="line">bintray.user=your user</span><br><span class="line">bintray.apikey=your apikey</span><br></pre></td></tr></table></figure>
<p>最后，在terminal（Android studio 下面直接有，不需要打开cmd）中运行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gradlew bintrayUpload</span><br></pre></td></tr></table></figure></p>
<h4 id="build成功之后就可以在你的主页中看到这个项目了"><a href="#build成功之后就可以在你的主页中看到这个项目了" class="headerlink" title="build成功之后就可以在你的主页中看到这个项目了"></a>build成功之后就可以在你的主页中看到这个项目了</h4><h5 id="以上，如有错误，恳请指出"><a href="#以上，如有错误，恳请指出" class="headerlink" title="以上，如有错误，恳请指出"></a>以上，如有错误，恳请指出</h5>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Parcelable序列化类在Activity、Fragment之间通信</title>
    <url>/2017/11/27/Parcelable%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB%E5%9C%A8Activity%E3%80%81Fragment%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h4 id="要让一个类的对象序列化，我们首先得让这个类实现Parcelable接口，我自己定义的一个类如下："><a href="#要让一个类的对象序列化，我们首先得让这个类实现Parcelable接口，我自己定义的一个类如下：" class="headerlink" title="要让一个类的对象序列化，我们首先得让这个类实现Parcelable接口，我自己定义的一个类如下："></a>要让一个类的对象序列化，我们首先得让这个类实现Parcelable接口，我自己定义的一个类如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NewPlan implements Parcelable&#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String location;</span><br><span class="line">    private long startTime;</span><br><span class="line">    private long endTime;</span><br><span class="line">    public(Long id, String location, long startTime, long endTime) &#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.location = location;</span><br><span class="line">    this.startTime = startTime;</span><br><span class="line">    this.endTime = endTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return this.id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getLocation() &#123;</span><br><span class="line">        return this.location;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLocation(String location) &#123;</span><br><span class="line">        this.location = location;</span><br><span class="line">    &#125;</span><br><span class="line">    public long getStartTime() &#123;</span><br><span class="line">        return this.startTime;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setStartTime(long startTime) &#123;</span><br><span class="line">        this.startTime = startTime;</span><br><span class="line">    &#125;</span><br><span class="line">    public long getEndTime() &#123;</span><br><span class="line">        return this.endTime;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setEndTime(long endTime) &#123;</span><br><span class="line">        this.endTime = endTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="这时Ide会提醒我们需要实现以下两个函数"><a href="#这时Ide会提醒我们需要实现以下两个函数" class="headerlink" title="这时Ide会提醒我们需要实现以下两个函数"></a>这时Ide会提醒我们需要实现以下两个函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeString(location);</span><br><span class="line">        dest.writeLong(startTime);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="describeContents-函数我们一般不需要对它进行操作，我们需要写的是writeToParcel函数，注意，我们如果需要通信但是不需要得到对象中所有的属性的话，可以少些几个属性，比如我这里就只写了两个属性，做完这一步就可以来写内部生成器了"><a href="#describeContents-函数我们一般不需要对它进行操作，我们需要写的是writeToParcel函数，注意，我们如果需要通信但是不需要得到对象中所有的属性的话，可以少些几个属性，比如我这里就只写了两个属性，做完这一步就可以来写内部生成器了" class="headerlink" title="describeContents()函数我们一般不需要对它进行操作，我们需要写的是writeToParcel函数，注意，我们如果需要通信但是不需要得到对象中所有的属性的话，可以少些几个属性，比如我这里就只写了两个属性，做完这一步就可以来写内部生成器了"></a>describeContents()函数我们一般不需要对它进行操作，我们需要写的是writeToParcel函数，注意，我们如果需要通信但是不需要得到对象中所有的属性的话，可以少些几个属性，比如我这里就只写了两个属性，做完这一步就可以来写内部生成器了</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final Parcelable.Creator&lt;NewPlan&gt; CREATOR = new Parcelable.Creator&lt;NewPlan&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public NewPlan createFromParcel(Parcel source) &#123;</span><br><span class="line">            NewPlan newPlan = new NewPlan();</span><br><span class="line">            newPlan.location = source.readString();</span><br><span class="line">            newPlan.startTime = source.readLong();</span><br><span class="line">            return newPlan;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public NewPlan[] newArray(int size) &#123;</span><br><span class="line">            return new NewPlan[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="这里要严格按照我们刚刚写入的顺序来写，写入函数并没有给每个属性值都指定相应的Key，重写这两个函数之后，生成器就完成了。接下来我们就可以使用它通过Intent和Bundle在Activity和Fragment之间通信了"><a href="#这里要严格按照我们刚刚写入的顺序来写，写入函数并没有给每个属性值都指定相应的Key，重写这两个函数之后，生成器就完成了。接下来我们就可以使用它通过Intent和Bundle在Activity和Fragment之间通信了" class="headerlink" title="这里要严格按照我们刚刚写入的顺序来写，写入函数并没有给每个属性值都指定相应的Key，重写这两个函数之后，生成器就完成了。接下来我们就可以使用它通过Intent和Bundle在Activity和Fragment之间通信了"></a>这里要严格按照我们刚刚写入的顺序来写，写入函数并没有给每个属性值都指定相应的Key，重写这两个函数之后，生成器就完成了。接下来我们就可以使用它通过Intent和Bundle在Activity和Fragment之间通信了</h4><p>一.  Activity和Activity之间用Intent传递对象</p>
<h5 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Intent intent = new Intent(MainActivity.this, SecondActivity.class);</span><br><span class="line">intent.putExtra(&quot;it&quot;, new NewPlan(0, &quot;湖北武汉&quot;, 20171110,20171111);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<h5 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Intent intent = getIntent();</span><br><span class="line">NewPlan mNewPlan = intent.getParcelableExtra()；</span><br></pre></td></tr></table></figure>
<h4 id="当然，除了传输一个对象，我们也可以传递List集合，不过传递对象集合时一定要注意，集合的类型一定是ArrayList，声明为List接口也是不可以的"><a href="#当然，除了传输一个对象，我们也可以传递List集合，不过传递对象集合时一定要注意，集合的类型一定是ArrayList，声明为List接口也是不可以的" class="headerlink" title="当然，除了传输一个对象，我们也可以传递List集合，不过传递对象集合时一定要注意，集合的类型一定是ArrayList，声明为List接口也是不可以的"></a>当然，除了传输一个对象，我们也可以传递List集合，不过传递对象集合时一定要注意，集合的类型一定是ArrayList，声明为List接口也是不可以的</h4><p>二. Activity与Fragment传递对象</p>
<h4 id="我们在fragment的构造参数中无法传入我们想要传递的数据，官方推荐是使用argument传递消息，用法如下"><a href="#我们在fragment的构造参数中无法传入我们想要传递的数据，官方推荐是使用argument传递消息，用法如下" class="headerlink" title="我们在fragment的构造参数中无法传入我们想要传递的数据，官方推荐是使用argument传递消息，用法如下"></a>我们在fragment的构造参数中无法传入我们想要传递的数据，官方推荐是使用argument传递消息，用法如下</h4><h5 id="Activity给Fragment设置arguement"><a href="#Activity给Fragment设置arguement" class="headerlink" title="Activity给Fragment设置arguement"></a>Activity给Fragment设置arguement</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mScheduleDetailFragment = new ScheduleDetailFragment();//继承fragment的类</span><br><span class="line">bundleDetail.putParcelableArrayList(&quot;newPlan&quot;,new NewPlan(0, &quot;湖北武汉&quot;, 20171110,20171111); //将想要传递的对象放入Bundle</span><br><span class="line">        mScheduleDetailFragment.setArguments(bundleDetail);//设置argument</span><br></pre></td></tr></table></figure>
<h5 id="fragment中获得Bundle中的对象"><a href="#fragment中获得Bundle中的对象" class="headerlink" title="fragment中获得Bundle中的对象"></a>fragment中获得Bundle中的对象</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NewPlan m= this.getArguments().getParcelable(&quot;newPlan&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，只有在实现Parcelable接口时写入和读取的属性才能在被传递后被读取，没有这样做的属性在传递后为控制，比如说这里我只能得到location和StartTime这两个属性</p>
<p>如有错误，恳请指出</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>另类的Android studio 3.0 报错解决方案</title>
    <url>/2017/11/25/%E5%8F%A6%E7%B1%BB%E7%9A%84Android%20studio%203.0%20%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h4 id="前几天手贱升级了3-0，结果第二天就报出了奇怪的错误，类似于下面这种"><a href="#前几天手贱升级了3-0，结果第二天就报出了奇怪的错误，类似于下面这种" class="headerlink" title="前几天手贱升级了3.0，结果第二天就报出了奇怪的错误，类似于下面这种"></a>前几天手贱升级了3.0，结果第二天就报出了奇怪的错误，类似于下面这种</h4><blockquote>
<p>Error:too many padding sections on bottom border.</p>
<p>Error:com.android.tools.aapt2.Aapt2Exception: AAPT2 error: check logs for details</p>
<h4 id="按照网上给的解决方案，在gradle-properties-中把android-enableAapt2-false-加进去，发现还是报错，这次换成了aapt报错"><a href="#按照网上给的解决方案，在gradle-properties-中把android-enableAapt2-false-加进去，发现还是报错，这次换成了aapt报错" class="headerlink" title="按照网上给的解决方案，在gradle.properties 中把android.enableAapt2=false 加进去，发现还是报错，这次换成了aapt报错"></a>按照网上给的解决方案，在<em>gradle.properties</em> 中把<em>android.enableAapt2=false</em> 加进去，发现还是报错，这次换成了aapt报错</h4><p>Execution failed for task ‘:app:mergeDebugResources’. &gt; Error: Some file crunching failed, see logs for details</p>
<p>####最后终于找到了问题的根源，就是9path图片的错误，Android studio对图片的要求很高，如果这里错了，很容易就报错了，把图片换掉之后aapt2也不会报错了</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>MVP模式中的小技巧：软引用与弱引用</title>
    <url>/2017/11/06/MVP%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%9A%E8%BD%AF%E5%BC%95%E7%94%A8%E4%B8%8E%E5%BC%B1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>在MVP当中，过多的类导致了内存控制十分困难，而强引用又很容易导致OOM（GC时不会回收被强引用持有的对象），在这个时候就轮到其他的两中对象引用的方式：软引用与弱引用登场了（虚引用几乎不会被用到）</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p> 在系统内存不够时，会回收被软引用持有的对象，引用方法如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//T可代表任何对象</span><br><span class="line">SoftReference&lt;T&gt; reference = new SoftReference&lt;T&gt;(t0);</span><br><span class="line">T t1 = reference.get();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h6 id="这里表示t1持有t0的弱引用"><a href="#这里表示t1持有t0的弱引用" class="headerlink" title="这里表示t1持有t0的弱引用"></a>这里表示t1持有t0的弱引用</h6><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><blockquote>
<p>每次系统运行垃圾清理（GC）时都会回收被弱引用持有的对象，引用方法如下，和软引用类似<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;T&gt;  reference = new WeakReference&lt;T&gt;(t0);</span><br><span class="line">T t1 = reference.get();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="在MVP模式中，Presenter可能会需要引用Activity的引用，在这里我们就可以使用这两种方式来防止内存泄漏了，如在View层的接口定义了一个getACtivity（）函数，则在Activity中实现的时候可以这么写"><a href="#在MVP模式中，Presenter可能会需要引用Activity的引用，在这里我们就可以使用这两种方式来防止内存泄漏了，如在View层的接口定义了一个getACtivity（）函数，则在Activity中实现的时候可以这么写" class="headerlink" title="在MVP模式中，Presenter可能会需要引用Activity的引用，在这里我们就可以使用这两种方式来防止内存泄漏了，如在View层的接口定义了一个getACtivity（）函数，则在Activity中实现的时候可以这么写"></a>在MVP模式中，Presenter可能会需要引用Activity的引用，在这里我们就可以使用这两种方式来防止内存泄漏了，如在View层的接口定义了一个getACtivity（）函数，则在Activity中实现的时候可以这么写</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Activity getActivity() &#123;</span><br><span class="line">WeakReference&lt;Activity&gt; weakReference = new WeakReference&lt;Activity&gt;(this);</span><br><span class="line">return weakReference.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="我们也可以用一个ArrayList来控制weakReference，这样可以避免频繁地new-WeakReference，具体代码如下"><a href="#我们也可以用一个ArrayList来控制weakReference，这样可以避免频繁地new-WeakReference，具体代码如下" class="headerlink" title="我们也可以用一个ArrayList来控制weakReference，这样可以避免频繁地new WeakReference，具体代码如下"></a>我们也可以用一个ArrayList来控制weakReference，这样可以避免频繁地new WeakReference，具体代码如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private List&lt;WeakReference&lt;Activity&gt;&gt; mWeakReferenceList = new ArrayList&lt;WeakReference&lt;Activity&gt;&gt;();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Activity getActivity() &#123;</span><br><span class="line">        if (mWeakReferenceList.size() == 0) &#123;</span><br><span class="line">            WeakReference&lt;Activity&gt; weakReference = new WeakReference&lt;Activity&gt;(this);</span><br><span class="line">            mWeakReferenceList.add(weakReference);</span><br><span class="line">            return weakReference.get();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            WeakReference&lt;Activity&gt; weakReference = mWeakReferenceList.get(0);</span><br><span class="line">            LogUtil.v(TAG, &quot;list woeked!&quot;);</span><br><span class="line">            return weakReference.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>####运行时可看到打印日志<br><img src="http://img.blog.csdn.net/20171015205034526?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h5 id="成功运行了"><a href="#成功运行了" class="headerlink" title="成功运行了"></a>成功运行了</h5><h4 id="如上，如有错误，恳请指出"><a href="#如上，如有错误，恳请指出" class="headerlink" title="如上，如有错误，恳请指出"></a>如上，如有错误，恳请指出</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>使用委托模式在Activity中操作RecyclerView中的item</title>
    <url>/2017/11/02/%E4%BD%BF%E7%94%A8%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F%E5%9C%A8Activity%E4%B8%AD%E6%93%8D%E4%BD%9CRecyclerView%E4%B8%AD%E7%9A%84item/</url>
    <content><![CDATA[<blockquote>
<p>RecyclerView与ListView不同，无法直接通过setItemClicklistener来获得单个item的点击时间，这个时候，我们可以通过在adapter中定义接口，并在Activity中实现相应接口来获得每个Item的点击事件，也就是标准的委托模式。</p>
<h4 id="具体做法如下："><a href="#具体做法如下：" class="headerlink" title="具体做法如下："></a>具体做法如下：</h4><h4 id="第一步-在Adapter类中定义内部接口，我自己定义的如下："><a href="#第一步-在Adapter类中定义内部接口，我自己定义的如下：" class="headerlink" title="第一步 在Adapter类中定义内部接口，我自己定义的如下："></a>第一步 在Adapter类中定义内部接口，我自己定义的如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 在活动中实现的接口</span><br><span class="line">    */</span><br><span class="line">   public interface SelectItem &#123;</span><br><span class="line">       /**</span><br><span class="line">        * 在活动中定义的方法</span><br><span class="line">        * @param view view对象</span><br><span class="line">        * @param position item的位置</span><br><span class="line">        */</span><br><span class="line">       void select(View view, int position);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="第二步-在onBindViewHolder方法中定义定义点击事件，并在点击事件中执行该接口的逻辑"><a href="#第二步-在onBindViewHolder方法中定义定义点击事件，并在点击事件中执行该接口的逻辑" class="headerlink" title="第二步 在onBindViewHolder方法中定义定义点击事件，并在点击事件中执行该接口的逻辑"></a>第二步 在onBindViewHolder方法中定义定义点击事件，并在点击事件中执行该接口的逻辑</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">holder.mainView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if (null != mSelectItem) &#123;</span><br><span class="line">                    mSelectItem.select(v, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h5 id="这样我们就得到了在回调函数中的view和position，这样就能在Activity中对相应的数据进行操作了"><a href="#这样我们就得到了在回调函数中的view和position，这样就能在Activity中对相应的数据进行操作了" class="headerlink" title="这样我们就得到了在回调函数中的view和position，这样就能在Activity中对相应的数据进行操作了"></a>这样我们就得到了在回调函数中的view和position，这样就能在Activity中对相应的数据进行操作了</h5><h4 id="第四步-在adapter中定义定义设置委托对象的函数"><a href="#第四步-在adapter中定义定义设置委托对象的函数" class="headerlink" title="第四步 在adapter中定义定义设置委托对象的函数"></a>第四步 在adapter中定义定义设置委托对象的函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setSelectItem(SelectItem selectItem) &#123;</span><br><span class="line">        mSelectItem = selectItem;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="做好这一步，我们就可以通过在Activity中重写接口中的方法来获得当前点击类的位置和view对象了"><a href="#做好这一步，我们就可以通过在Activity中重写接口中的方法来获得当前点击类的位置和view对象了" class="headerlink" title="做好这一步，我们就可以通过在Activity中重写接口中的方法来获得当前点击类的位置和view对象了"></a>做好这一步，我们就可以通过在Activity中重写接口中的方法来获得当前点击类的位置和view对象了</h4><h4 id="最后一步，在Activity中重写接口函数"><a href="#最后一步，在Activity中重写接口函数" class="headerlink" title="最后一步，在Activity中重写接口函数"></a>最后一步，在Activity中重写接口函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pickItemAdapter.setSelectItem(new PickItemAdapter.SelectItem() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void select(View view, int position) &#123;</span><br><span class="line">                selectItem(position); //对数据进行操作的函数，自己定义的</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="这样我们就能很方便地获取当前item的位置，对数据进行操作了！"><a href="#这样我们就能很方便地获取当前item的位置，对数据进行操作了！" class="headerlink" title="这样我们就能很方便地获取当前item的位置，对数据进行操作了！"></a>这样我们就能很方便地获取当前item的位置，对数据进行操作了！</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Dagger2实现MVP模式</title>
    <url>/2017/10/22/Dagger2%E5%AE%9E%E7%8E%B0MVP%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>MVP模式是为了实现View与Model完全解耦而生的模式，而配上Dagger2就能如虎添翼了</p>
<h5 id="MVP模式的图解如下（网上盗的图）"><a href="#MVP模式的图解如下（网上盗的图）" class="headerlink" title="MVP模式的图解如下（网上盗的图）"></a>MVP模式的图解如下（网上盗的图）</h5><p><img src="http://img.blog.csdn.net/20171015195037116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="而我们平常在实现MVP模式的时候，应该让View集成接口实现，这样比较容易实现调用，Presenter想要获得某个Activity中的成员的时候也显得更加容易，如下实例"><a href="#而我们平常在实现MVP模式的时候，应该让View集成接口实现，这样比较容易实现调用，Presenter想要获得某个Activity中的成员的时候也显得更加容易，如下实例" class="headerlink" title="而我们平常在实现MVP模式的时候，应该让View集成接口实现，这样比较容易实现调用，Presenter想要获得某个Activity中的成员的时候也显得更加容易，如下实例"></a>而我们平常在实现MVP模式的时候，应该让View集成接口实现，这样比较容易实现调用，Presenter想要获得某个Activity中的成员的时候也显得更加容易，如下实例</h4><p>接口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface MainView &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获得当前的活动</span><br><span class="line">     * @return 当前活动</span><br><span class="line">     */</span><br><span class="line">    Activity getActivity();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>Activity继承此接口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity implements MainView</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="这样在写Presenter时，我们就可以这样写"><a href="#这样在写Presenter时，我们就可以这样写" class="headerlink" title="这样在写Presenter时，我们就可以这样写"></a>这样在写Presenter时，我们就可以这样写</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainPresenterImpel &#123;</span><br><span class="line">    private final MainView mMainView;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    public MainPresenterImpel(MainView mainView) &#123;</span><br><span class="line">        mMainView = mainView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="这样我们就可以通过Presenter来调用Activity中写的函数，也可以用它来获得诸如Context等的上帝接口…"><a href="#这样我们就可以通过Presenter来调用Activity中写的函数，也可以用它来获得诸如Context等的上帝接口…" class="headerlink" title="这样我们就可以通过Presenter来调用Activity中写的函数，也可以用它来获得诸如Context等的上帝接口…"></a>这样我们就可以通过Presenter来调用Activity中写的函数，也可以用它来获得诸如Context等的上帝接口…</h4><h3 id="接下来就轮到用Dagger2实现注入的时候了"><a href="#接下来就轮到用Dagger2实现注入的时候了" class="headerlink" title="接下来就轮到用Dagger2实现注入的时候了"></a>接下来就轮到用Dagger2实现注入的时候了</h3><h4 id="首先，加入dagger2的依赖"><a href="#首先，加入dagger2的依赖" class="headerlink" title="首先，加入dagger2的依赖"></a>首先，加入dagger2的依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.google.dagger:dagger:2.11&apos;</span><br><span class="line">annotationProcessor &apos;com.google.dagger:dagger-compiler:2.11&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>版本号可能不是最新的哦</p>
<h4 id="然后，我们应该实现两个类，Module和Component"><a href="#然后，我们应该实现两个类，Module和Component" class="headerlink" title="然后，我们应该实现两个类，Module和Component"></a>然后，我们应该实现两个类，Module和Component</h4><h5 id="Module这个类相当与构造出一个我们需要注入的对象，而Component则是一个注入的接口，它帮助我们把我们需要注入的对象注入到目标类当中去"><a href="#Module这个类相当与构造出一个我们需要注入的对象，而Component则是一个注入的接口，它帮助我们把我们需要注入的对象注入到目标类当中去" class="headerlink" title="Module这个类相当与构造出一个我们需要注入的对象，而Component则是一个注入的接口，它帮助我们把我们需要注入的对象注入到目标类当中去"></a>Module这个类相当与构造出一个我们需要注入的对象，而Component则是一个注入的接口，它帮助我们把我们需要注入的对象注入到目标类当中去</h5><h4 id="Module类如下，这里我们需要注意，因为我们的Presenter类构造函数并不是无参的，我们需要到目标类当中获取到MainView才能将它构造出来，但我们可以先这样写"><a href="#Module类如下，这里我们需要注意，因为我们的Presenter类构造函数并不是无参的，我们需要到目标类当中获取到MainView才能将它构造出来，但我们可以先这样写" class="headerlink" title="Module类如下，这里我们需要注意，因为我们的Presenter类构造函数并不是无参的，我们需要到目标类当中获取到MainView才能将它构造出来，但我们可以先这样写"></a>Module类如下，这里我们需要注意，因为我们的Presenter类构造函数并不是无参的，我们需要到目标类当中获取到MainView才能将它构造出来，但我们可以先这样写</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class MainPresenterImpelModule &#123;</span><br><span class="line">    private MainView mMainView;</span><br><span class="line">    public MainPresenterImpelModule(MainView mainView) &#123;</span><br><span class="line">        mMainView = mainView;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 返回MainPresenterImpelModule</span><br><span class="line">     * @param mainView constructor必需的参数</span><br><span class="line">     * @return MainPresenterImpel实例</span><br><span class="line">     */</span><br><span class="line">    @Provides</span><br><span class="line">    MainPresenterImpel provideImpel(MainView mainView) &#123;</span><br><span class="line">        return new MainPresenterImpel(mainView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回在活动中的MainView</span><br><span class="line">     * @return 提供创建MainPresenterImpel的MainView</span><br><span class="line">     */</span><br><span class="line">    @Provides</span><br><span class="line">    MainView provideMainView() &#123;</span><br><span class="line">        return mMainView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="在这里Presenter本身也是带构造函数的，这样做主要是为了获取到目标类中的MainView，两个Provides标签则表示了这个函数返回的成员可以帮我们构造Presenter，我们可以看到provideMainView-提供了provideImpel-MainView-mainView-中所需的MainView，而它自身的MainView则需要到目标类中获取。"><a href="#在这里Presenter本身也是带构造函数的，这样做主要是为了获取到目标类中的MainView，两个Provides标签则表示了这个函数返回的成员可以帮我们构造Presenter，我们可以看到provideMainView-提供了provideImpel-MainView-mainView-中所需的MainView，而它自身的MainView则需要到目标类中获取。" class="headerlink" title="在这里Presenter本身也是带构造函数的，这样做主要是为了获取到目标类中的MainView，两个Provides标签则表示了这个函数返回的成员可以帮我们构造Presenter，我们可以看到provideMainView()提供了provideImpel(MainView mainView)中所需的MainView，而它自身的MainView则需要到目标类中获取。"></a>在这里Presenter本身也是带构造函数的，这样做主要是为了获取到目标类中的MainView，两个Provides标签则表示了这个函数返回的成员可以帮我们构造Presenter，我们可以看到provideMainView()提供了provideImpel(MainView mainView)中所需的MainView，而它自身的MainView则需要到目标类中获取。</h4><h4 id="Component类如下所示"><a href="#Component类如下所示" class="headerlink" title="Component类如下所示"></a>Component类如下所示</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component(modules = MainPresenterImpelModule.class)</span><br><span class="line">public interface MainActivityComponent &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 这里inject表示注入的意思，这个方法名可以随意更改，但建议就</span><br><span class="line">     * 用inject即可。</span><br><span class="line">     * @param activity 依赖注入的活动实例</span><br><span class="line">     */</span><br><span class="line">    void inject(Activity activity);</span><br><span class="line">    MainPresenterImpel getMainPresenterImpel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="这里就是把modules类生成的对象注入到Activity类中去，inject函数就是完成注入的方法，而getMainPresenterImpel-可以直接获得Presenter的实例，而不是new-一个出来，这里需要注意的是getMainPresenterImpel-方法是可以不写的，如果不写则需要在Activity用注释的方式获得Presenter实例，如下所示"><a href="#这里就是把modules类生成的对象注入到Activity类中去，inject函数就是完成注入的方法，而getMainPresenterImpel-可以直接获得Presenter的实例，而不是new-一个出来，这里需要注意的是getMainPresenterImpel-方法是可以不写的，如果不写则需要在Activity用注释的方式获得Presenter实例，如下所示" class="headerlink" title="这里就是把modules类生成的对象注入到Activity类中去，inject函数就是完成注入的方法，而getMainPresenterImpel()可以直接获得Presenter的实例，而不是new 一个出来，这里需要注意的是getMainPresenterImpel()方法是可以不写的，如果不写则需要在Activity用注释的方式获得Presenter实例，如下所示"></a>这里就是把modules类生成的对象注入到Activity类中去，inject函数就是完成注入的方法，而getMainPresenterImpel()可以直接获得Presenter的实例，而不是new 一个出来，这里需要注意的是getMainPresenterImpel()方法是可以不写的，如果不写则需要在Activity用注释的方式获得Presenter实例，如下所示</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@inject</span><br><span class="line">MainPresenterImpel mMainPresenterImpel；</span><br></pre></td></tr></table></figure>
<h4 id="最后一步，实现注入"><a href="#最后一步，实现注入" class="headerlink" title="最后一步，实现注入"></a>最后一步，实现注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MainActivityComponent mainActivityComponent = DaggerMainActivityComponent.builder()</span><br><span class="line">                .mainPresenterImpelModule(new MainPresenterImpelModule(this))</span><br><span class="line">                .build();</span><br><span class="line">        mainActivityComponent.inject(this);</span><br></pre></td></tr></table></figure>
<h4 id="我这样写主要是为了要获得Presenter-的实例，如下"><a href="#我这样写主要是为了要获得Presenter-的实例，如下" class="headerlink" title="我这样写主要是为了要获得Presenter 的实例，如下"></a>我这样写主要是为了要获得Presenter 的实例，如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mMainPresenterImpel = mainActivityComponent.getMainPresenterImpel();</span><br></pre></td></tr></table></figure>
<h4 id="如果采用注释的方法获得实例的话直接注入就ok，像这样"><a href="#如果采用注释的方法获得实例的话直接注入就ok，像这样" class="headerlink" title="如果采用注释的方法获得实例的话直接注入就ok，像这样"></a>如果采用注释的方法获得实例的话直接注入就ok，像这样</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DaggerMainActivityComponent.builder()</span><br><span class="line">                .mainPresenterImpelModule(new MainPresenterImpelModule(this))</span><br><span class="line">                .build()</span><br><span class="line">                .inject(this);</span><br></pre></td></tr></table></figure>
<h4 id="如有错误请指正"><a href="#如有错误请指正" class="headerlink" title="如有错误请指正"></a>如有错误请指正</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Android中设置界面PreferenceFragment的用法</title>
    <url>/2017/10/19/Android%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2PreferenceFragment%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>发现Android虽然为我们提供了很好的设置界面的东西（也就是这个PreferenceFragment），但是网上的资料还真是少之又少，可能大家的需求都是自己做设置界面，不稀罕Google为我们做好的，不过既然用到了这个东西，还是拿出来做下笔记</p>
<h4 id="第一步，我们现在res中写一个preferences-xml文件，当然你也可以命名成其他的名字"><a href="#第一步，我们现在res中写一个preferences-xml文件，当然你也可以命名成其他的名字" class="headerlink" title="第一步，我们现在res中写一个preferences.xml文件，当然你也可以命名成其他的名字"></a>第一步，我们现在res中写一个preferences.xml文件，当然你也可以命名成其他的名字</h4><p>文件目录如下：<br><img src="http://img.blog.csdn.net/20171016170343679?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h5 id="根文件布局是PreferenceScreen-定义了一个设置界面，PreferenceCategory则为设置的不同分类，可供选择的Preference有Preference，SwitchPreference，ListPreference以及CheckboxPreference达到，这些都可以放到PreferenceCategory中去，我自己写的界面如下"><a href="#根文件布局是PreferenceScreen-定义了一个设置界面，PreferenceCategory则为设置的不同分类，可供选择的Preference有Preference，SwitchPreference，ListPreference以及CheckboxPreference达到，这些都可以放到PreferenceCategory中去，我自己写的界面如下" class="headerlink" title="根文件布局是PreferenceScreen,定义了一个设置界面，PreferenceCategory则为设置的不同分类，可供选择的Preference有Preference，SwitchPreference，ListPreference以及CheckboxPreference达到，这些都可以放到PreferenceCategory中去，我自己写的界面如下"></a>根文件布局是PreferenceScreen,定义了一个设置界面，PreferenceCategory则为设置的不同分类，可供选择的Preference有Preference，SwitchPreference，ListPreference以及CheckboxPreference达到，这些都可以放到PreferenceCategory中去，我自己写的界面如下</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;PreferenceCategory android:title=&quot;@string/warning_setting&quot;&gt;</span><br><span class="line">        &lt;SwitchPreference android:key=&quot;weather_warn&quot;</span><br><span class="line">                          android:title=&quot;@string/weather_warn&quot;</span><br><span class="line">                          android:summaryOff=&quot;开启后在日程开始前会弹出通知栏&quot;</span><br><span class="line">                          android:summaryOn=&quot;会提醒日程&quot;</span><br><span class="line">                          android:defaultValue=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;ListPreference android:key=&quot;warning_time&quot;</span><br><span class="line">                        android:dependency=&quot;weather_warn&quot;</span><br><span class="line">                        android:title=&quot;@string/waring_time_select&quot;</span><br><span class="line">                        android:summary=&quot;开启提醒则需要设置这项,默认为15分钟&quot;</span><br><span class="line">                        android:entries=&quot;@array/time&quot;</span><br><span class="line">                        android:entryValues=&quot;@array/time&quot;</span><br><span class="line">                        android:defaultValue=&quot;@string/time_default&quot;</span><br><span class="line">                        android:dialogTitle=&quot;请选择提前时间&quot;/&gt;</span><br><span class="line">    &lt;/PreferenceCategory&gt;</span><br><span class="line">    &lt;/PreferenceScreen&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>显示的效果是这样的<br><img src="http://img.blog.csdn.net/20171016170914634?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<blockquote>
<p>这里的颜色跟定义的style有关系</p>
</blockquote>
<p>在这里我使用了一个android:dependency=”weather_warn”属性，这个属性的意思是只有当key为weather_warn的preference值为true时，它才是可以被选择的，我们在preference中可以定义默认的值，summary属性则是选项下面的小字，summaryon和summaryoff可以控制打开开关后显示的小字</p>
<h4 id="第二步，写我们的Java类，继承PreferenceFragment"><a href="#第二步，写我们的Java类，继承PreferenceFragment" class="headerlink" title="第二步，写我们的Java类，继承PreferenceFragment"></a>第二步，写我们的Java类，继承PreferenceFragment</h4><p>在这里我们需要注意，这个Fragment和普通的Fragment有很大的不同，我们只需要在onCreate中执行addPreferencesFromResource(R.xml.preferences);就可以了，不需要写onCreateView函数，下面是我写的一个示例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        addPreferencesFromResource(R.xml.preferences);</span><br><span class="line">        useDefault = (SwitchPreference) findPreference(&quot;use_default_image&quot;);</span><br><span class="line">        warnDuration = (ListPreference) findPreference(&quot;warning_time&quot;);</span><br><span class="line">        updateDuration = (ListPreference) findPreference(&quot;update_duration&quot;);</span><br><span class="line">        useDefault.setOnPreferenceClickListener(this);</span><br><span class="line">        updateDuration.setOnPreferenceChangeListener(this);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意我这里用到的ListPreference和SwitchPreference并不是刚刚我给出来的Preferces.xml中的内容哦，不过用法都是一样的，我们可以发现在这里，获得Preferences的方法很像在Activity中findviewbyid的用法，只不过这里使用的不是id，而是我们刚刚定义的key</p>
</blockquote>
<p>这里我们还定义了点击事件，如果像我这样使用的话还需要继承Preference.OnPreferenceClickListener, Preference.OnPreferenceChangeListener这两个接口，然后重写两个方法，这也跟setOnClicklistener的用法十分相似，我们需要注意ListPreference的用法和想CheckPreference和SwitchPreference的方法都不一样，对SwitchPreference、CheckboxPreference应该设置点击事件，而对ListPreference则设置Chane事件。</p>
<blockquote>
<p>ListPreference的参考此文<br><a href="http://www.jb51.net/article/75874.htm" target="_blank" rel="noopener">http://www.jb51.net/article/75874.htm</a></p>
<h4 id="以上，如有错误，恳请指出"><a href="#以上，如有错误，恳请指出" class="headerlink" title="以上，如有错误，恳请指出"></a>以上，如有错误，恳请指出</h4></blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>android图片状态栏实现沉浸式状态栏</title>
    <url>/2017/10/18/android%E5%9B%BE%E7%89%87%E7%8A%B6%E6%80%81%E6%A0%8F%E5%AE%9E%E7%8E%B0%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/</url>
    <content><![CDATA[<blockquote>
<p>沉浸式状态栏实现起来的文章网上有很多了，不过再MD中有一个图片和toolbar一起使用，还会产生过度效果的沉浸式状态栏，像下面这样<br><img src="http://img.blog.csdn.net/20171022162924742?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>标题栏XML代码如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;android.support.design.widget.AppBarLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;192dp&quot;</span><br><span class="line">        android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;android.support.design.widget.CollapsingToolbarLayout</span><br><span class="line">            android:id=&quot;@+id/notification_background&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            app:contentScrim=&quot;?attr/colorPrimary&quot;</span><br><span class="line">            app:layout_scrollFlags=&quot;scroll|enterAlways|enterAlwaysCollapsed&quot;</span><br><span class="line">            android:fitsSystemWindows=&quot;true&quot;</span><br><span class="line">            app:layout_scrollInterpolator=&quot;@android:anim/decelerate_interpolator&quot;</span><br><span class="line">            app:toolbarId=&quot;@+id/toolbar&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;ImageView</span><br><span class="line">                android:id=&quot;@+id/app_bar_image&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;</span><br><span class="line">                android:contentDescription=&quot;@string/background&quot;</span><br><span class="line">                android:scaleType=&quot;centerCrop&quot;</span><br><span class="line">                /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;android.support.v7.widget.Toolbar</span><br><span class="line">                android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">                /&gt;</span><br><span class="line">        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;</span><br><span class="line">    &lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>####如果我们一直使用的是默认图片的画不需要担心，但如果图片是动态改变的，上面状态栏的颜色与下面图片的颜色就有可能会出现很不搭的情况，这个时候就应该动态改变状态栏的颜色了</p>
<h5 id="像下面的图片"><a href="#像下面的图片" class="headerlink" title="像下面的图片"></a>像下面的图片</h5><p><img src="http://img.blog.csdn.net/20171022163410832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="这个效果就是用Android-supportV7包Graphics中的Palette实现的，它的作用就是将图片中存在的颜色提取出来，我们可以选择其中的任意一种颜色，具体代码如下"><a href="#这个效果就是用Android-supportV7包Graphics中的Palette实现的，它的作用就是将图片中存在的颜色提取出来，我们可以选择其中的任意一种颜色，具体代码如下" class="headerlink" title="这个效果就是用Android supportV7包Graphics中的Palette实现的，它的作用就是将图片中存在的颜色提取出来，我们可以选择其中的任意一种颜色，具体代码如下"></a>这个效果就是用Android supportV7包Graphics中的Palette实现的，它的作用就是将图片中存在的颜色提取出来，我们可以选择其中的任意一种颜色，具体代码如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Palette.from(resource).generate(new Palette.PaletteAsyncListener() &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void onGenerated(Palette palette) &#123;</span><br><span class="line">   Palette.Swatch swatch = palette.getMutedSwatch();</span><br><span class="line">   int color;</span><br><span class="line">   if (swatch != null) &#123;</span><br><span class="line">      color = swatch.getRgb(); //获取样本颜色</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      color = primaryColor; //提取样本失败则使用默认颜色</span><br><span class="line">      &#125;                                                                                                                                                         setThemeColor(color); //设置状态栏颜色，下文中会有具体实现</span><br><span class="line">                        &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="代码中resource是图片的Bitmap对象，swatch则为提取出来的色彩样本，我们这里getMutedSwatch-提取出的是柔和的色彩，当然，还有其他色彩可以选择，可以参考以下的文章"><a href="#代码中resource是图片的Bitmap对象，swatch则为提取出来的色彩样本，我们这里getMutedSwatch-提取出的是柔和的色彩，当然，还有其他色彩可以选择，可以参考以下的文章" class="headerlink" title="代码中resource是图片的Bitmap对象，swatch则为提取出来的色彩样本，我们这里getMutedSwatch()提取出的是柔和的色彩，当然，还有其他色彩可以选择，可以参考以下的文章"></a>代码中resource是图片的Bitmap对象，swatch则为提取出来的色彩样本，我们这里getMutedSwatch()提取出的是柔和的色彩，当然，还有其他色彩可以选择，可以参考以下的文章</h4><blockquote>
<p><a href="http://www.jianshu.com/p/9fcf316031ba" target="_blank" rel="noopener">http://www.jianshu.com/p/9fcf316031ba</a></p>
<h4 id="提取完颜色之后，我们就可以用它来设置状态栏的颜色的，改变状态栏颜色可以参考以下代码"><a href="#提取完颜色之后，我们就可以用它来设置状态栏的颜色的，改变状态栏颜色可以参考以下代码" class="headerlink" title="提取完颜色之后，我们就可以用它来设置状态栏的颜色的，改变状态栏颜色可以参考以下代码"></a>提取完颜色之后，我们就可以用它来设置状态栏的颜色的，改变状态栏颜色可以参考以下代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.zhy.colorfulstatusbar;</span><br><span class="line"></span><br><span class="line">import android.annotation.TargetApi;</span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.graphics.Color;</span><br><span class="line">import android.os.Build;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.ViewGroup;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by zhy on 15/9/21.</span><br><span class="line"> */</span><br><span class="line">public class StatusBarCompat</span><br><span class="line">&#123;</span><br><span class="line">    private static final int INVALID_VAL = -1;</span><br><span class="line">    private static final int COLOR_DEFAULT = Color.parseColor(&quot;#20000000&quot;);</span><br><span class="line"></span><br><span class="line">    @TargetApi(Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">    public static void compat(Activity activity, int statusColor)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">        &#123;</span><br><span class="line">            if (statusColor != INVALID_VAL)</span><br><span class="line">            &#123;</span><br><span class="line">                activity.getWindow().setStatusBarColor(statusColor);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">        &#123;</span><br><span class="line">            int color = COLOR_DEFAULT;</span><br><span class="line">            ViewGroup contentView = (ViewGroup) activity.findViewById(android.R.id.content);</span><br><span class="line">            if (statusColor != INVALID_VAL)</span><br><span class="line">            &#123;</span><br><span class="line">                color = statusColor;</span><br><span class="line">            &#125;</span><br><span class="line">            View statusBarView = new View(activity);</span><br><span class="line">            ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                    getStatusBarHeight(activity));</span><br><span class="line">            statusBarView.setBackgroundColor(color);</span><br><span class="line">            contentView.addView(statusBarView, lp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void compat(Activity activity)</span><br><span class="line">    &#123;</span><br><span class="line">        compat(activity, INVALID_VAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int getStatusBarHeight(Context context)</span><br><span class="line">    &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        int resourceId = context.getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;);</span><br><span class="line">        if (resourceId &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            result = context.getResources().getDimensionPixelSize(resourceId);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注： 转载自 <a href="http://blog.csdn.net/lmj623565791/article/details/48649563" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/48649563</a><br>有了这个帮助类来帮助我们改变状态栏的颜色，实现起来就很简单了，实现如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void setThemeColor(int mColor) &#123;</span><br><span class="line">    mNotificationBackground.setContentScrimColor(mColor);</span><br><span class="line">    StatusBarCompat.compat(MainActivity.this, mColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="注意，-mNotificationBackground即为xml代码布局中CollapsingToolbarLayout的实例，这个设置是改变过渡时的颜色。"><a href="#注意，-mNotificationBackground即为xml代码布局中CollapsingToolbarLayout的实例，这个设置是改变过渡时的颜色。" class="headerlink" title="注意， mNotificationBackground即为xml代码布局中CollapsingToolbarLayout的实例，这个设置是改变过渡时的颜色。"></a>注意， mNotificationBackground即为xml代码布局中CollapsingToolbarLayout的实例，这个设置是改变过渡时的颜色。</h5>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>DialogFragment实现自定义布局的小技巧</title>
    <url>/2017/10/13/DialogFragment%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<blockquote>
<p>DialogFragment可以说是用起来很方便，也很容易上手的一个类了，上次博客写了一篇关于将DatePicker放入DialogFragment中的文章，之后又遇到了将一整个布局放入DialogFragment中的情况，写着来记录一下</p>
<h4 id="一般来说，我们在DialogFragment中放入一个View只需要像这样写"><a href="#一般来说，我们在DialogFragment中放入一个View只需要像这样写" class="headerlink" title="一般来说，我们在DialogFragment中放入一个View只需要像这样写"></a>一般来说，我们在DialogFragment中放入一个View只需要像这样写</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">View v = LayoutInflater.from(getActivity().getApplication())</span><br><span class="line">                .inflate(R.layout.datepicker, null);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="但是如果我们需要把一整个布局都传入，而且还需要获得布局内控件的引用时，我们就需要一个ViewGroup传入，那这怎么才能在DialogFragment中实现呢？其实还是很简单的，只需要在onCreateView函数中将ViewGroup取出就可以了，具体代码如下："><a href="#但是如果我们需要把一整个布局都传入，而且还需要获得布局内控件的引用时，我们就需要一个ViewGroup传入，那这怎么才能在DialogFragment中实现呢？其实还是很简单的，只需要在onCreateView函数中将ViewGroup取出就可以了，具体代码如下：" class="headerlink" title="但是如果我们需要把一整个布局都传入，而且还需要获得布局内控件的引用时，我们就需要一个ViewGroup传入，那这怎么才能在DialogFragment中实现呢？其实还是很简单的，只需要在onCreateView函数中将ViewGroup取出就可以了，具体代码如下："></a>但是如果我们需要把一整个布局都传入，而且还需要获得布局内控件的引用时，我们就需要一个ViewGroup传入，那这怎么才能在DialogFragment中实现呢？其实还是很简单的，只需要在onCreateView函数中将ViewGroup取出就可以了，具体代码如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">   @Override</span><br><span class="line">   public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">       mViewGroup = container;</span><br><span class="line">       return super.onCreateView(inflater, container, savedInstanceState);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>然后再使用提取出的mViewGroup来获得整个布局<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Dialog onCreateDialog(Bundle savedInstanceState) &#123;</span><br><span class="line">        View view = LayoutInflater.from(getContext())</span><br><span class="line">                .inflate(R.layout.location_dialog_fragment, mViewGroup, false);</span><br><span class="line">      ...... &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就能轻松把自己写的布局再DialogFragment中展示了，获得布局中的控件就轻而易举了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mEditLocation = (Button) view.findViewById(R.id.edit_location);</span><br><span class="line"> mThingStatement=(EditText)view.findViewById(R.id.thing_statement);</span><br><span class="line">       mSpendMoney = (EditText) view.findViewById(R.id.spend_money);</span><br><span class="line">       mStartTime = (TextView) view.findViewById(R.id.start_time);</span><br><span class="line">       mSpendTime = (EditText) view.findViewById(R.id.spend_time);</span><br></pre></td></tr></table></figure></p>
<h5 id="以上，如有错误，恳请指出"><a href="#以上，如有错误，恳请指出" class="headerlink" title="以上，如有错误，恳请指出"></a>以上，如有错误，恳请指出</h5>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Rxjava2和Retrofit2实现解析bing每日一图JSON</title>
    <url>/2017/10/12/Rxjava2%E5%92%8CRetrofit2%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90bing%E6%AF%8F%E6%97%A5%E4%B8%80%E5%9B%BEJSON/</url>
    <content><![CDATA[<blockquote>
<p>一直想学习一下Rxjava和Retrofit实现网络请求，正好这几天准备实现一个下载bing每日一图的功能，就实践了一下</p>
<h5 id="网上找的带有每日一图链接的资源如下"><a href="#网上找的带有每日一图链接的资源如下" class="headerlink" title="网上找的带有每日一图链接的资源如下"></a>网上找的带有每日一图链接的资源如下</h5><p><a href="https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1" target="_blank" rel="noopener">https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</a></p>
<h5 id="打开之后会得到一长串JSON格式的数据"><a href="#打开之后会得到一长串JSON格式的数据" class="headerlink" title="打开之后会得到一长串JSON格式的数据"></a>打开之后会得到一长串JSON格式的数据</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;images&quot;:[&#123;&quot;startdate&quot;:&quot;20171006&quot;,&quot;fullstartdate&quot;:&quot;201710061600&quot;,&quot;enddate&quot;:&quot;20171007&quot;,&quot;url&quot;:&quot;/az/hprichbg/rb/VallesMarineris_ZH-CN10598461085_1920x1080.jpg&quot;,&quot;urlbase&quot;:&quot;/az/hprichbg/rb/VallesMarineris_ZH-CN10598461085&quot;,&quot;copyright&quot;:&quot;火星上的峡谷系统-水手号峡谷地区上的小行星 (© Detlev van Ravenswaay/Getty Images)&quot;,&quot;copyrightlink&quot;:&quot;http://www.bing.com/search?q=%E7%81%AB%E6%98%9F%E5%B3%A1%E8%B0%B7&amp;form=hpcapt&amp;mkt=zh-cn&quot;,&quot;quiz&quot;:&quot;/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20171006_VallesMarineris%22&amp;FORM=HPQUIZ&quot;,&quot;wp&quot;:true,&quot;hsh&quot;:&quot;5b69b96f1ea30eb5ec187173de25ef3c&quot;,&quot;drk&quot;:1,&quot;top&quot;:1,&quot;bot&quot;:1,&quot;hs&quot;:[]&#125;],&quot;tooltips&quot;:&#123;&quot;loading&quot;:&quot;正在加载...&quot;,&quot;previous&quot;:&quot;上一个图像&quot;,&quot;next&quot;:&quot;下一个图像&quot;,&quot;walle&quot;:&quot;此图片不能下载用作壁纸。&quot;,&quot;walls&quot;:&quot;下载今日美图。仅限用作桌面壁纸。&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="带有bing每日一图的链接显而易见了，就是"><a href="#带有bing每日一图的链接显而易见了，就是" class="headerlink" title="带有bing每日一图的链接显而易见了，就是"></a>带有bing每日一图的链接显而易见了，就是</h5><blockquote>
<p>“urlbase”:”/az/hprichbg/rb/VallesMarineris_ZH-CN10598461085”</p>
<p>#####当然 这仅仅是我写这篇文章时候的链接，每天数据都会不同</p>
<h3 id="接下来我们来开始实现Rxjava2和Retrofit2解析JSON了，添加依赖如下"><a href="#接下来我们来开始实现Rxjava2和Retrofit2解析JSON了，添加依赖如下" class="headerlink" title="接下来我们来开始实现Rxjava2和Retrofit2解析JSON了，添加依赖如下"></a>接下来我们来开始实现Rxjava2和Retrofit2解析JSON了，添加依赖如下</h3><p> compile ‘com.squareup.retrofit2:retrofit:2.3.0’<br>    compile ‘io.reactivex.rxjava2:rxandroid:2.0.1’<br>    compile ‘io.reactivex.rxjava2:rxjava:2.1.3’<br>    compile ‘com.squareup.retrofit2:converter-gson:2.3.0’<br>    compile ‘com.squareup.retrofit2:adapter-rxjava2:2.3.0’</p>
<h5 id="因为okhttp已经集成在retrofit中了，所有这里不需要再加入okhttp的依赖"><a href="#因为okhttp已经集成在retrofit中了，所有这里不需要再加入okhttp的依赖" class="headerlink" title="因为okhttp已经集成在retrofit中了，所有这里不需要再加入okhttp的依赖"></a>因为okhttp已经集成在retrofit中了，所有这里不需要再加入okhttp的依赖</h5><h4 id="一步一步来，首先，我们先根据返回的数据写一个实体类，这里有一个很方便的工具GsonFormat，可以直接根据网页中的信息生成gettter-setter及内部类，还没有安装此插件的同学可以参考这一篇博文"><a href="#一步一步来，首先，我们先根据返回的数据写一个实体类，这里有一个很方便的工具GsonFormat，可以直接根据网页中的信息生成gettter-setter及内部类，还没有安装此插件的同学可以参考这一篇博文" class="headerlink" title="一步一步来，首先，我们先根据返回的数据写一个实体类，这里有一个很方便的工具GsonFormat，可以直接根据网页中的信息生成gettter setter及内部类，还没有安装此插件的同学可以参考这一篇博文"></a>一步一步来，首先，我们先根据返回的数据写一个实体类，这里有一个很方便的工具GsonFormat，可以直接根据网页中的信息生成gettter setter及内部类，还没有安装此插件的同学可以参考这一篇博文</h4><p><a href="http://blog.csdn.net/dakaring/article/details/46300963" target="_blank" rel="noopener">http://blog.csdn.net/dakaring/article/details/46300963</a></p>
<h5 id="我们也可以添加自己的函数，这样可以很方便地得到想要的数据，如下"><a href="#我们也可以添加自己的函数，这样可以很方便地得到想要的数据，如下" class="headerlink" title="我们也可以添加自己的函数，这样可以很方便地得到想要的数据，如下"></a>我们也可以添加自己的函数，这样可以很方便地得到想要的数据，如下</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String getURL() &#123;</span><br><span class="line">        return images.get(0).getUrl();</span><br><span class="line"> &#125;</span><br><span class="line">String getDate() &#123;</span><br><span class="line">        return images.get(0).getEnddate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="这里就是我自己添加的函数"><a href="#这里就是我自己添加的函数" class="headerlink" title="这里就是我自己添加的函数"></a>这里就是我自己添加的函数</h5><h4 id="完成实体类之后就可以来定义接口了"><a href="#完成实体类之后就可以来定义接口了" class="headerlink" title="完成实体类之后就可以来定义接口了"></a>完成实体类之后就可以来定义接口了</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface ImageAPI &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 网络请求</span><br><span class="line">     * @return 实体类</span><br><span class="line">     */</span><br><span class="line">    @GET(&quot;HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&quot;)</span><br><span class="line">    Flowable&lt;ImageBean&gt; getImage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="这里需要注意的是，在-GET后面添加的是上面的链接https-cn-bing-com-HPImageArchive-aspx-format-js-amp-idx-0-amp-n-1的后半部分，这也是retrofit-的用法很重要的一点，当然，在我们这里并没有体现出来这种方式的优点，但在其他地方，可以起到很好的解耦作用。我们这里定义的接口直接就返回了ImageBean类，在后面就可以直接提取数据了。Flowable则是Rxjava2新引入的东西，它可以更好地处理同步异步的关系。"><a href="#这里需要注意的是，在-GET后面添加的是上面的链接https-cn-bing-com-HPImageArchive-aspx-format-js-amp-idx-0-amp-n-1的后半部分，这也是retrofit-的用法很重要的一点，当然，在我们这里并没有体现出来这种方式的优点，但在其他地方，可以起到很好的解耦作用。我们这里定义的接口直接就返回了ImageBean类，在后面就可以直接提取数据了。Flowable则是Rxjava2新引入的东西，它可以更好地处理同步异步的关系。" class="headerlink" title="这里需要注意的是，在@GET后面添加的是上面的链接https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1的后半部分，这也是retrofit 的用法很重要的一点，当然，在我们这里并没有体现出来这种方式的优点，但在其他地方，可以起到很好的解耦作用。我们这里定义的接口直接就返回了ImageBean类，在后面就可以直接提取数据了。Flowable则是Rxjava2新引入的东西，它可以更好地处理同步异步的关系。"></a>这里需要注意的是，在@GET后面添加的是上面的链接<a href="https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1的后半部分，这也是retrofit" target="_blank" rel="noopener">https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1的后半部分，这也是retrofit</a> 的用法很重要的一点，当然，在我们这里并没有体现出来这种方式的优点，但在其他地方，可以起到很好的解耦作用。我们这里定义的接口直接就返回了ImageBean类，在后面就可以直接提取数据了。Flowable则是Rxjava2新引入的东西，它可以更好地处理同步异步的关系。</h5><h4 id="最后一步就是实现了，我们在上一步只给出了链接的下半部分，在这里我们将将上半部分封装进retrofit，这样完整的链接就给出了"><a href="#最后一步就是实现了，我们在上一步只给出了链接的下半部分，在这里我们将将上半部分封装进retrofit，这样完整的链接就给出了" class="headerlink" title="最后一步就是实现了，我们在上一步只给出了链接的下半部分，在这里我们将将上半部分封装进retrofit，这样完整的链接就给出了"></a>最后一步就是实现了，我们在上一步只给出了链接的下半部分，在这里我们将将上半部分封装进retrofit，这样完整的链接就给出了</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final String BASE_URL = &quot;https://cn.bing.com&quot;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .baseUrl(&quot;https://cn.bing.com/&quot;)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>
<h5 id="在这里我们实现了Retrofit-的初始化，以及将JSON转化，其中addCallAdapterFactory-RxJava2CallAdapterFactory-create-表示添加Rxjava2与Retrofit2的适配器，addConverterFactory-GsonConverterFactory-create-则表示添加Json转化工具。"><a href="#在这里我们实现了Retrofit-的初始化，以及将JSON转化，其中addCallAdapterFactory-RxJava2CallAdapterFactory-create-表示添加Rxjava2与Retrofit2的适配器，addConverterFactory-GsonConverterFactory-create-则表示添加Json转化工具。" class="headerlink" title="在这里我们实现了Retrofit 的初始化，以及将JSON转化，其中addCallAdapterFactory(RxJava2CallAdapterFactory.create())表示添加Rxjava2与Retrofit2的适配器，addConverterFactory(GsonConverterFactory.create())则表示添加Json转化工具。"></a>在这里我们实现了Retrofit 的初始化，以及将JSON转化，其中addCallAdapterFactory(RxJava2CallAdapterFactory.create())表示添加Rxjava2与Retrofit2的适配器，addConverterFactory(GsonConverterFactory.create())则表示添加Json转化工具。</h5><h4 id="最后一步-实现接口"><a href="#最后一步-实现接口" class="headerlink" title="最后一步 实现接口"></a>最后一步 实现接口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final ImageAPI imageAPI = retrofit.create(ImageAPI.class);</span><br><span class="line">        LogUtil.v(TAG, &quot;downloadUrl&quot;);</span><br><span class="line">        imageAPI.getImage()</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(Schedulers.newThread())</span><br><span class="line">                .subscribe(new Subscriber&lt;ImageBean&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                        s.request(Long.MAX_VALUE);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onNext(ImageBean imageBean) &#123;</span><br><span class="line">                        LogUtil.v(TAG, &quot;next&quot;);</span><br><span class="line">                        LogUtil.d(TAG, BASE_URL + imageBean.getURL());</span><br><span class="line">                        LogUtil.d(TAG, imageBean.getDate());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onError(Throwable t) &#123;</span><br><span class="line">                        t.printStackTrace();</span><br><span class="line">                        LogUtil.v(TAG, &quot;error&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onComplete() &#123;</span><br><span class="line">                        LogUtil.v(TAG, &quot;complete&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<h5 id="这里需要注意onSubscribe函数中必须对s进行处理，这里表示一次性处理几次数据，若不处理，则onNext不生效！"><a href="#这里需要注意onSubscribe函数中必须对s进行处理，这里表示一次性处理几次数据，若不处理，则onNext不生效！" class="headerlink" title="这里需要注意onSubscribe函数中必须对s进行处理，这里表示一次性处理几次数据，若不处理，则onNext不生效！"></a>这里需要注意onSubscribe函数中必须对s进行处理，这里表示一次性处理几次数据，若不处理，则onNext不生效！</h5><h4 id="到这里就结束了，可以得到完整的每日一图链接，如有差错恳请指出！"><a href="#到这里就结束了，可以得到完整的每日一图链接，如有差错恳请指出！" class="headerlink" title="到这里就结束了，可以得到完整的每日一图链接，如有差错恳请指出！"></a>到这里就结束了，可以得到完整的每日一图链接，如有差错恳请指出！</h4>]]></content>
      <categories>
        <category>Android网络开发</category>
      </categories>
  </entry>
  <entry>
    <title>ButterKnife在RecyclerView adapter中的使用</title>
    <url>/2017/10/08/ButterKnife%E5%9C%A8RecyclerView%20adapter%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="ButterKnife是一个用起来十分方便的开源库，我们只需要用一个小小的插件ButterKnifeZenezny就免去了写一大袋findViewbyId的书写，不过在adapter中，插件自动生成的方式就步行了，我们一般都需要在ViewHolder中实现依赖注入-这时候我们需要像下面这样"><a href="#ButterKnife是一个用起来十分方便的开源库，我们只需要用一个小小的插件ButterKnifeZenezny就免去了写一大袋findViewbyId的书写，不过在adapter中，插件自动生成的方式就步行了，我们一般都需要在ViewHolder中实现依赖注入-这时候我们需要像下面这样" class="headerlink" title="ButterKnife是一个用起来十分方便的开源库，我们只需要用一个小小的插件ButterKnifeZenezny就免去了写一大袋findViewbyId的书写，不过在adapter中，插件自动生成的方式就步行了，我们一般都需要在ViewHolder中实现依赖注入,这时候我们需要像下面这样"></a>ButterKnife是一个用起来十分方便的开源库，我们只需要用一个小小的插件ButterKnifeZenezny就免去了写一大袋findViewbyId的书写，不过在adapter中，插件自动生成的方式就步行了，我们一般都需要在ViewHolder中实现依赖注入,这时候我们需要像下面这样</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class LocationViewHolder extends RecyclerView.ViewHolder &#123;</span><br><span class="line">        @BindView(R.id.location_show)</span><br><span class="line">        TextView locationShow;</span><br><span class="line">        @BindView(R.id.statement_show)</span><br><span class="line">        TextView stateementShow;</span><br><span class="line">        @BindView(R.id.time_show)</span><br><span class="line">        TextView timeShow;</span><br><span class="line">        @BindView(R.id.spend_money_show)</span><br><span class="line">        TextView spendMoneyShow;</span><br><span class="line">        @BindView(R.id.spend_time_show)</span><br><span class="line">        TextView spendTimeShow;</span><br><span class="line">        public LocationViewHolder(View itemView) &#123;</span><br><span class="line">            super(itemView);</span><br><span class="line">            ButterKnife.bind(this, itemView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="这种方式就可以实现用ButterKnife注入view，简化了我们的书写，当然，对项目中用了ButterKnife的强迫症患者来说，实在是很棒了。。"><a href="#这种方式就可以实现用ButterKnife注入view，简化了我们的书写，当然，对项目中用了ButterKnife的强迫症患者来说，实在是很棒了。。" class="headerlink" title="这种方式就可以实现用ButterKnife注入view，简化了我们的书写，当然，对项目中用了ButterKnife的强迫症患者来说，实在是很棒了。。"></a>这种方式就可以实现用ButterKnife注入view，简化了我们的书写，当然，对项目中用了ButterKnife的强迫症患者来说，实在是很棒了。。</h4>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>NDK实现毛玻璃效果</title>
    <url>/2017/10/07/NDK%E5%AE%9E%E7%8E%B0%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E5%AE%8C%E5%85%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>前几天准备做一个动态的毛玻璃效果，中间查阅了很多网上的资料，我用的方法是CMake做NDK，由C/C++来实现图片的毛玻璃化，废话不多说，具体方法如下</p>
<h4 id="首先，当然是配置NDK环境，这类网上教程很多，就麻烦自行配制了，参考教程如下"><a href="#首先，当然是配置NDK环境，这类网上教程很多，就麻烦自行配制了，参考教程如下" class="headerlink" title="首先，当然是配置NDK环境，这类网上教程很多，就麻烦自行配制了，参考教程如下"></a>首先，当然是配置NDK环境，这类网上教程很多，就麻烦自行配制了，参考教程如下</h4><p><a href="http://blog.csdn.net/xiaoyu_93/article/details/53082088" target="_blank" rel="noopener">http://blog.csdn.net/xiaoyu_93/article/details/53082088</a></p>
<h4 id="这里配置好之后我们还需要在gradle中配置一下NDK开发所需要的库"><a href="#这里配置好之后我们还需要在gradle中配置一下NDK开发所需要的库" class="headerlink" title="这里配置好之后我们还需要在gradle中配置一下NDK开发所需要的库"></a>这里配置好之后我们还需要在gradle中配置一下NDK开发所需要的库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                cppFlags &quot;-std=c++11 -frtti -fexceptions&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            ndk &#123;</span><br><span class="line">                moduleName &quot;blur_lib&quot;   // 动态库名称</span><br><span class="line">                abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;x86&quot; // 相应的架构平台</span><br><span class="line">                ldLibs &quot;log&quot; //log输出</span><br><span class="line">                ldLibs &quot;jnigraphics&quot; //graphic相关jni</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="来编写C-C-文件了，我是直接在系统默认的C-库中做，也就是Native-lib-cpp，代码如下"><a href="#来编写C-C-文件了，我是直接在系统默认的C-库中做，也就是Native-lib-cpp，代码如下" class="headerlink" title="来编写C/C++文件了，我是直接在系统默认的C++库中做，也就是Native-lib.cpp，代码如下"></a>来编写C/C++文件了，我是直接在系统默认的C++库中做，也就是Native-lib.cpp，代码如下</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* DO NOT EDIT THIS FILE - it is machine generated */</span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">/* Header for class com_pecoo_blurjnidemo_NativeHelper */</span><br><span class="line">#ifndef _Included_com_pecoo_blurjnidemo_NativeHelper</span><br><span class="line">#define _Included_com_pecoo_blurjnidemo_NativeHelper</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">/*</span><br><span class="line"> * Class:     com_pecoo_blurjnidemo_NativeHelper</span><br><span class="line"> * Method:    blurBitmap</span><br><span class="line"> * Signature: (Ljava/lang/Object;I)V</span><br><span class="line"> */</span><br><span class="line">#include &lt;android/log.h&gt;</span><br><span class="line">#include &lt;android/bitmap.h&gt;</span><br><span class="line">#include &quot;stackblur.h&quot;   // 在第一步中创建的.h头文件，下面可以调用里面的方法</span><br><span class="line"></span><br><span class="line">// log宏定义</span><br><span class="line">#define TAG &quot;Native_Blur_Jni&quot;</span><br><span class="line">#define LOG_D(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__)</span><br><span class="line"></span><br><span class="line">JNIEXPORT void JNICALL Java_com_android_betterway_utils_BlurUtil_blurBitmap</span><br><span class="line">        (JNIEnv *env, jclass obj, jobject bitmapIn, jint r)</span><br><span class="line">&#123;</span><br><span class="line">    AndroidBitmapInfo infoIn;</span><br><span class="line">    void *pixels;</span><br><span class="line">    // 获取bitmap的信息</span><br><span class="line">    if (AndroidBitmap_getInfo(env, bitmapIn, &amp;infoIn) != ANDROID_BITMAP_RESULT_SUCCESS) &#123;</span><br><span class="line">        LOG_D(&quot;AndroidBitmap_getInfo failed!&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 检测bitmap是不是这两种格式，因为算法中只有对这两种图片会做处理</span><br><span class="line">    if (infoIn.format != ANDROID_BITMAP_FORMAT_RGBA_8888 &amp;&amp;</span><br><span class="line">        infoIn.format != ANDROID_BITMAP_FORMAT_RGB_565) &#123;</span><br><span class="line">        LOG_D(&quot;Only support ANDROID_BITMAP_FORMAT_RGBA_8888 and ANDROID_BITMAP_FORMAT_RGB_565&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 锁定图片</span><br><span class="line">    if (AndroidBitmap_lockPixels(env, bitmapIn, &amp;pixels) != ANDROID_BITMAP_RESULT_SUCCESS) &#123;</span><br><span class="line">        LOG_D(&quot;AndroidBitmap_lockPixels failed!&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 得到宽高</span><br><span class="line">    int h = infoIn.height;</span><br><span class="line">    int w = infoIn.width;</span><br><span class="line">    if (infoIn.format == ANDROID_BITMAP_FORMAT_RGBA_8888) &#123;</span><br><span class="line">        // 调用stackblur.c中的blur_ARGB_8888()或blur_RGB_565()</span><br><span class="line">        pixels = blur_ARGB_8888((int *) pixels, w, h, r);</span><br><span class="line">    &#125; else if (infoIn.format == ANDROID_BITMAP_FORMAT_RGB_565) &#123;</span><br><span class="line">        pixels = blur_RGB_565((short *) pixels, w, h, r);</span><br><span class="line">    &#125;</span><br><span class="line">    // 对应上面的AndroidBitmap_lockPixels（）</span><br><span class="line">    AndroidBitmap_unlockPixels(env, bitmapIn);</span><br><span class="line">&#125;</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h4 id="当然，这里还有其他的文件，分别如下，这是来定义图片色彩通道的文件"><a href="#当然，这里还有其他的文件，分别如下，这是来定义图片色彩通道的文件" class="headerlink" title="当然，这里还有其他的文件，分别如下，这是来定义图片色彩通道的文件"></a>当然，这里还有其他的文件，分别如下，这是来定义图片色彩通道的文件</h4><blockquote>
<p>stackblur.c<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">#define ABS(a) ((a)&lt;(0)?(-a):(a))</span><br><span class="line">#define MAX(a, b) ((a)&gt;(b)?(a):(b))</span><br><span class="line">#define MIN(a, b) ((a)&lt;(b)?(a):(b))</span><br><span class="line"></span><br><span class="line">/*************************************************</span><br><span class="line">Function:		StackBlur</span><br><span class="line">Description:    Using stack way blurred image pixels</span><br><span class="line">Calls:          malloc</span><br><span class="line">Table Accessed: NULL</span><br><span class="line">Table Updated:	NULL</span><br><span class="line">Input:          Collection of pixels, wide image, image is high, the blur radius</span><br><span class="line">Output:         After return to fuzzy collection of pixels</span><br><span class="line">Return:         After return to fuzzy collection of pixels</span><br><span class="line">Others:         NULL</span><br><span class="line">*************************************************/</span><br><span class="line">int *blur_ARGB_8888(int *pix, int w, int h, int radius) &#123;</span><br><span class="line">    int wm = w - 1;</span><br><span class="line">    int hm = h - 1;</span><br><span class="line">    int wh = w * h;</span><br><span class="line">    int div = radius + radius + 1;</span><br><span class="line"></span><br><span class="line">    short *r = (short *) malloc(wh * sizeof(short));</span><br><span class="line">    short *g = (short *) malloc(wh * sizeof(short));</span><br><span class="line">    short *b = (short *) malloc(wh * sizeof(short));</span><br><span class="line">    int rsum, gsum, bsum, x, y, i, p, yp, yi, yw;</span><br><span class="line"></span><br><span class="line">    int *vmin = (int *) malloc(MAX(w, h) * sizeof(int));</span><br><span class="line"></span><br><span class="line">    int divsum = (div + 1) &gt;&gt; 1;</span><br><span class="line">    divsum *= divsum;</span><br><span class="line">    short *dv = (short *) malloc(256 * divsum * sizeof(short));</span><br><span class="line">    for (i = 0; i &lt; 256 * divsum; i++) &#123;</span><br><span class="line">        dv[i] = (short) (i / divsum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    yw = yi = 0;</span><br><span class="line"></span><br><span class="line">    int(*stack)[3] = (int (*)[3]) malloc(div * 3 * sizeof(int));</span><br><span class="line">    int stackpointer;</span><br><span class="line">    int stackstart;</span><br><span class="line">    int *sir;</span><br><span class="line">    int rbs;</span><br><span class="line">    int r1 = radius + 1;</span><br><span class="line">    int routsum, goutsum, boutsum;</span><br><span class="line">    int rinsum, ginsum, binsum;</span><br><span class="line"></span><br><span class="line">    for (y = 0; y &lt; h; y++) &#123;</span><br><span class="line">        rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;</span><br><span class="line">        for (i = -radius; i &lt;= radius; i++) &#123;</span><br><span class="line">            p = pix[yi + (MIN(wm, MAX(i, 0)))];</span><br><span class="line">            sir = stack[i + radius];</span><br><span class="line">            sir[0] = (p &amp; 0xff0000) &gt;&gt; 16;</span><br><span class="line">            sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8;</span><br><span class="line">            sir[2] = (p &amp; 0x0000ff);</span><br><span class="line"></span><br><span class="line">            rbs = r1 - ABS(i);</span><br><span class="line">            rsum += sir[0] * rbs;</span><br><span class="line">            gsum += sir[1] * rbs;</span><br><span class="line">            bsum += sir[2] * rbs;</span><br><span class="line">            if (i &gt; 0) &#123;</span><br><span class="line">                rinsum += sir[0];</span><br><span class="line">                ginsum += sir[1];</span><br><span class="line">                binsum += sir[2];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                routsum += sir[0];</span><br><span class="line">                goutsum += sir[1];</span><br><span class="line">                boutsum += sir[2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stackpointer = radius;</span><br><span class="line"></span><br><span class="line">        for (x = 0; x &lt; w; x++) &#123;</span><br><span class="line"></span><br><span class="line">            r[yi] = dv[rsum];</span><br><span class="line">            g[yi] = dv[gsum];</span><br><span class="line">            b[yi] = dv[bsum];</span><br><span class="line"></span><br><span class="line">            rsum -= routsum;</span><br><span class="line">            gsum -= goutsum;</span><br><span class="line">            bsum -= boutsum;</span><br><span class="line"></span><br><span class="line">            stackstart = stackpointer - radius + div;</span><br><span class="line">            sir = stack[stackstart % div];</span><br><span class="line"></span><br><span class="line">            routsum -= sir[0];</span><br><span class="line">            goutsum -= sir[1];</span><br><span class="line">            boutsum -= sir[2];</span><br><span class="line"></span><br><span class="line">            if (y == 0) &#123;</span><br><span class="line">                vmin[x] = MIN(x + radius + 1, wm);</span><br><span class="line">            &#125;</span><br><span class="line">            p = pix[yw + vmin[x]];</span><br><span class="line"></span><br><span class="line">            sir[0] = (p &amp; 0xff0000) &gt;&gt; 16;</span><br><span class="line">            sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8;</span><br><span class="line">            sir[2] = (p &amp; 0x0000ff);</span><br><span class="line"></span><br><span class="line">            rinsum += sir[0];</span><br><span class="line">            ginsum += sir[1];</span><br><span class="line">            binsum += sir[2];</span><br><span class="line"></span><br><span class="line">            rsum += rinsum;</span><br><span class="line">            gsum += ginsum;</span><br><span class="line">            bsum += binsum;</span><br><span class="line"></span><br><span class="line">            stackpointer = (stackpointer + 1) % div;</span><br><span class="line">            sir = stack[(stackpointer) % div];</span><br><span class="line"></span><br><span class="line">            routsum += sir[0];</span><br><span class="line">            goutsum += sir[1];</span><br><span class="line">            boutsum += sir[2];</span><br><span class="line"></span><br><span class="line">            rinsum -= sir[0];</span><br><span class="line">            ginsum -= sir[1];</span><br><span class="line">            binsum -= sir[2];</span><br><span class="line"></span><br><span class="line">            yi++;</span><br><span class="line">        &#125;</span><br><span class="line">        yw += w;</span><br><span class="line">    &#125;</span><br><span class="line">    for (x = 0; x &lt; w; x++) &#123;</span><br><span class="line">        rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;</span><br><span class="line">        yp = -radius * w;</span><br><span class="line">        for (i = -radius; i &lt;= radius; i++) &#123;</span><br><span class="line">            yi = MAX(0, yp) + x;</span><br><span class="line"></span><br><span class="line">            sir = stack[i + radius];</span><br><span class="line"></span><br><span class="line">            sir[0] = r[yi];</span><br><span class="line">            sir[1] = g[yi];</span><br><span class="line">            sir[2] = b[yi];</span><br><span class="line"></span><br><span class="line">            rbs = r1 - ABS(i);</span><br><span class="line"></span><br><span class="line">            rsum += r[yi] * rbs;</span><br><span class="line">            gsum += g[yi] * rbs;</span><br><span class="line">            bsum += b[yi] * rbs;</span><br><span class="line"></span><br><span class="line">            if (i &gt; 0) &#123;</span><br><span class="line">                rinsum += sir[0];</span><br><span class="line">                ginsum += sir[1];</span><br><span class="line">                binsum += sir[2];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                routsum += sir[0];</span><br><span class="line">                goutsum += sir[1];</span><br><span class="line">                boutsum += sir[2];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (i &lt; hm) &#123;</span><br><span class="line">                yp += w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        yi = x;</span><br><span class="line">        stackpointer = radius;</span><br><span class="line">        for (y = 0; y &lt; h; y++) &#123;</span><br><span class="line">            // Preserve alpha channel: ( 0xff000000 &amp; pix[yi] )</span><br><span class="line">            pix[yi] = (0xff000000 &amp; pix[yi]) | (dv[rsum] &lt;&lt; 16) | (dv[gsum] &lt;&lt; 8) | dv[bsum];</span><br><span class="line"></span><br><span class="line">            rsum -= routsum;</span><br><span class="line">            gsum -= goutsum;</span><br><span class="line">            bsum -= boutsum;</span><br><span class="line"></span><br><span class="line">            stackstart = stackpointer - radius + div;</span><br><span class="line">            sir = stack[stackstart % div];</span><br><span class="line"></span><br><span class="line">            routsum -= sir[0];</span><br><span class="line">            goutsum -= sir[1];</span><br><span class="line">            boutsum -= sir[2];</span><br><span class="line"></span><br><span class="line">            if (x == 0) &#123;</span><br><span class="line">                vmin[y] = MIN(y + r1, hm) * w;</span><br><span class="line">            &#125;</span><br><span class="line">            p = x + vmin[y];</span><br><span class="line"></span><br><span class="line">            sir[0] = r[p];</span><br><span class="line">            sir[1] = g[p];</span><br><span class="line">            sir[2] = b[p];</span><br><span class="line"></span><br><span class="line">            rinsum += sir[0];</span><br><span class="line">            ginsum += sir[1];</span><br><span class="line">            binsum += sir[2];</span><br><span class="line"></span><br><span class="line">            rsum += rinsum;</span><br><span class="line">            gsum += ginsum;</span><br><span class="line">            bsum += binsum;</span><br><span class="line"></span><br><span class="line">            stackpointer = (stackpointer + 1) % div;</span><br><span class="line">            sir = stack[stackpointer];</span><br><span class="line"></span><br><span class="line">            routsum += sir[0];</span><br><span class="line">            goutsum += sir[1];</span><br><span class="line">            boutsum += sir[2];</span><br><span class="line"></span><br><span class="line">            rinsum -= sir[0];</span><br><span class="line">            ginsum -= sir[1];</span><br><span class="line">            binsum -= sir[2];</span><br><span class="line"></span><br><span class="line">            yi += w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(r);</span><br><span class="line">    free(g);</span><br><span class="line">    free(b);</span><br><span class="line">    free(vmin);</span><br><span class="line">    free(dv);</span><br><span class="line">    free(stack);</span><br><span class="line">    return (pix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">short *blur_RGB_565(short *pix, int w, int h, int radius) &#123;</span><br><span class="line">    int wm = w - 1;</span><br><span class="line">    int hm = h - 1;</span><br><span class="line">    int wh = w * h;</span><br><span class="line">    int div = radius + radius + 1;</span><br><span class="line"></span><br><span class="line">    short *r = (short *) malloc(wh * sizeof(short));</span><br><span class="line">    short *g = (short *) malloc(wh * sizeof(short));</span><br><span class="line">    short *b = (short *) malloc(wh * sizeof(short));</span><br><span class="line"></span><br><span class="line">    int rsum, gsum, bsum, x, y, p, i, yp, yi, yw;</span><br><span class="line"></span><br><span class="line">    int *vmin = (int *) malloc(MAX(w, h) * sizeof(int));</span><br><span class="line"></span><br><span class="line">    int divsum = (div + 1) &gt;&gt; 1;</span><br><span class="line">    divsum *= divsum;</span><br><span class="line"></span><br><span class="line">    short *dv = (short *) malloc(256 * divsum * sizeof(short));</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 256 * divsum; i++) &#123;</span><br><span class="line">        dv[i] = (short) (i / divsum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    yw = yi = 0;</span><br><span class="line"></span><br><span class="line">    int(*stack)[3] = (int (*)[3]) malloc(div * 3 * sizeof(int));</span><br><span class="line">    int stackpointer;</span><br><span class="line">    int stackstart;</span><br><span class="line">    int *sir;</span><br><span class="line">    int rbs;</span><br><span class="line">    int r1 = radius + 1;</span><br><span class="line">    int routsum, goutsum, boutsum;</span><br><span class="line">    int rinsum, ginsum, binsum;</span><br><span class="line"></span><br><span class="line">    for (y = 0; y &lt; h; y++) &#123;</span><br><span class="line">        rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;</span><br><span class="line">        for (i = -radius; i &lt;= radius; i++) &#123;</span><br><span class="line">            p = pix[yi + (MIN(wm, MAX(i, 0)))];</span><br><span class="line">            sir = stack[i + radius];</span><br><span class="line">            sir[0] = (((p) &amp; 0xF800) &gt;&gt; 11) &lt;&lt; 3;</span><br><span class="line">            sir[1] = (((p) &amp; 0x7E0) &gt;&gt; 5) &lt;&lt; 2;</span><br><span class="line">            sir[2] = ((p) &amp; 0x1F) &lt;&lt; 3;</span><br><span class="line"></span><br><span class="line">            rbs = r1 - ABS(i);</span><br><span class="line">            rsum += sir[0] * rbs;</span><br><span class="line">            gsum += sir[1] * rbs;</span><br><span class="line">            bsum += sir[2] * rbs;</span><br><span class="line">            if (i &gt; 0) &#123;</span><br><span class="line">                rinsum += sir[0];</span><br><span class="line">                ginsum += sir[1];</span><br><span class="line">                binsum += sir[2];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                routsum += sir[0];</span><br><span class="line">                goutsum += sir[1];</span><br><span class="line">                boutsum += sir[2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stackpointer = radius;</span><br><span class="line"></span><br><span class="line">        for (x = 0; x &lt; w; x++) &#123;</span><br><span class="line"></span><br><span class="line">            r[yi] = dv[rsum];</span><br><span class="line">            g[yi] = dv[gsum];</span><br><span class="line">            b[yi] = dv[bsum];</span><br><span class="line"></span><br><span class="line">            rsum -= routsum;</span><br><span class="line">            gsum -= goutsum;</span><br><span class="line">            bsum -= boutsum;</span><br><span class="line"></span><br><span class="line">            stackstart = stackpointer - radius + div;</span><br><span class="line">            sir = stack[stackstart % div];</span><br><span class="line"></span><br><span class="line">            routsum -= sir[0];</span><br><span class="line">            goutsum -= sir[1];</span><br><span class="line">            boutsum -= sir[2];</span><br><span class="line"></span><br><span class="line">            if (y == 0) &#123;</span><br><span class="line">                vmin[x] = MIN(x + radius + 1, wm);</span><br><span class="line">            &#125;</span><br><span class="line">            p = pix[yw + vmin[x]];</span><br><span class="line"></span><br><span class="line">            sir[0] = (((p) &amp; 0xF800) &gt;&gt; 11) &lt;&lt; 3;</span><br><span class="line">            sir[1] = (((p) &amp; 0x7E0) &gt;&gt; 5) &lt;&lt; 2;</span><br><span class="line">            sir[2] = ((p) &amp; 0x1F) &lt;&lt; 3;</span><br><span class="line"></span><br><span class="line">            rinsum += sir[0];</span><br><span class="line">            ginsum += sir[1];</span><br><span class="line">            binsum += sir[2];</span><br><span class="line"></span><br><span class="line">            rsum += rinsum;</span><br><span class="line">            gsum += ginsum;</span><br><span class="line">            bsum += binsum;</span><br><span class="line"></span><br><span class="line">            stackpointer = (stackpointer + 1) % div;</span><br><span class="line">            sir = stack[(stackpointer) % div];</span><br><span class="line"></span><br><span class="line">            routsum += sir[0];</span><br><span class="line">            goutsum += sir[1];</span><br><span class="line">            boutsum += sir[2];</span><br><span class="line"></span><br><span class="line">            rinsum -= sir[0];</span><br><span class="line">            ginsum -= sir[1];</span><br><span class="line">            binsum -= sir[2];</span><br><span class="line"></span><br><span class="line">            yi++;</span><br><span class="line">        &#125;</span><br><span class="line">        yw += w;</span><br><span class="line">    &#125;</span><br><span class="line">    for (x = 0; x &lt; w; x++) &#123;</span><br><span class="line">        rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;</span><br><span class="line">        yp = -radius * w;</span><br><span class="line">        for (i = -radius; i &lt;= radius; i++) &#123;</span><br><span class="line">            yi = MAX(0, yp) + x;</span><br><span class="line"></span><br><span class="line">            sir = stack[i + radius];</span><br><span class="line"></span><br><span class="line">            sir[0] = r[yi];</span><br><span class="line">            sir[1] = g[yi];</span><br><span class="line">            sir[2] = b[yi];</span><br><span class="line"></span><br><span class="line">            rbs = r1 - ABS(i);</span><br><span class="line"></span><br><span class="line">            rsum += r[yi] * rbs;</span><br><span class="line">            gsum += g[yi] * rbs;</span><br><span class="line">            bsum += b[yi] * rbs;</span><br><span class="line"></span><br><span class="line">            if (i &gt; 0) &#123;</span><br><span class="line">                rinsum += sir[0];</span><br><span class="line">                ginsum += sir[1];</span><br><span class="line">                binsum += sir[2];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                routsum += sir[0];</span><br><span class="line">                goutsum += sir[1];</span><br><span class="line">                boutsum += sir[2];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (i &lt; hm) &#123;</span><br><span class="line">                yp += w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        yi = x;</span><br><span class="line">        stackpointer = radius;</span><br><span class="line">        for (y = 0; y &lt; h; y++) &#123;</span><br><span class="line">            // Not have alpha channel</span><br><span class="line">            pix[yi] = ((((dv[rsum]) &gt;&gt; 3) &lt;&lt; 11) | (((dv[gsum]) &gt;&gt; 2) &lt;&lt; 5) | ((dv[bsum]) &gt;&gt; 3));</span><br><span class="line"></span><br><span class="line">            rsum -= routsum;</span><br><span class="line">            gsum -= goutsum;</span><br><span class="line">            bsum -= boutsum;</span><br><span class="line"></span><br><span class="line">            stackstart = stackpointer - radius + div;</span><br><span class="line">            sir = stack[stackstart % div];</span><br><span class="line"></span><br><span class="line">            routsum -= sir[0];</span><br><span class="line">            goutsum -= sir[1];</span><br><span class="line">            boutsum -= sir[2];</span><br><span class="line"></span><br><span class="line">            if (x == 0) &#123;</span><br><span class="line">                vmin[y] = MIN(y + r1, hm) * w;</span><br><span class="line">            &#125;</span><br><span class="line">            p = x + vmin[y];</span><br><span class="line"></span><br><span class="line">            sir[0] = r[p];</span><br><span class="line">            sir[1] = g[p];</span><br><span class="line">            sir[2] = b[p];</span><br><span class="line"></span><br><span class="line">            rinsum += sir[0];</span><br><span class="line">            ginsum += sir[1];</span><br><span class="line">            binsum += sir[2];</span><br><span class="line"></span><br><span class="line">            rsum += rinsum;</span><br><span class="line">            gsum += ginsum;</span><br><span class="line">            bsum += binsum;</span><br><span class="line"></span><br><span class="line">            stackpointer = (stackpointer + 1) % div;</span><br><span class="line">            sir = stack[stackpointer];</span><br><span class="line"></span><br><span class="line">            routsum += sir[0];</span><br><span class="line">            goutsum += sir[1];</span><br><span class="line">            boutsum += sir[2];</span><br><span class="line"></span><br><span class="line">            rinsum -= sir[0];</span><br><span class="line">            ginsum -= sir[1];</span><br><span class="line">            binsum -= sir[2];</span><br><span class="line"></span><br><span class="line">            yi += w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(r);</span><br><span class="line">    free(g);</span><br><span class="line">    free(b);</span><br><span class="line">    free(vmin);</span><br><span class="line">    free(dv);</span><br><span class="line">    free(stack);</span><br><span class="line">    return (pix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="代码有些长。。。还好不用自己敲"><a href="#代码有些长。。。还好不用自己敲" class="headerlink" title="代码有些长。。。还好不用自己敲"></a>代码有些长。。。还好不用自己敲</h5><h4 id="以及它对应的头文件"><a href="#以及它对应的头文件" class="headerlink" title="以及它对应的头文件"></a>以及它对应的头文件</h4><blockquote>
<p>stackblur.h<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef BETTERWAY_STACKBLUR_H</span><br><span class="line">#define BETTERWAY_STACKBLUR_H</span><br><span class="line">int *blur_ARGB_8888(int *, int, int, int);</span><br><span class="line"></span><br><span class="line">short *blur_RGB_565(short *, int, int, int);</span><br><span class="line">#endif //BETTERWAY_STACKBLUR_H</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="这些都做完了之后，就可以在CmakeList-text文件中加载了，如下所示，注意，我这里只给出了与默认文件不一样的部分，注意，这里的jnigraphics虽然说我们已经在gradle中添加，但在这里不添加的话还是会报错，但是c-c-中使用Log的库只要在gradle中添加就可以，这里实在是没弄明白，如有高手知道请告知，感激不尽。"><a href="#这些都做完了之后，就可以在CmakeList-text文件中加载了，如下所示，注意，我这里只给出了与默认文件不一样的部分，注意，这里的jnigraphics虽然说我们已经在gradle中添加，但在这里不添加的话还是会报错，但是c-c-中使用Log的库只要在gradle中添加就可以，这里实在是没弄明白，如有高手知道请告知，感激不尽。" class="headerlink" title="这些都做完了之后，就可以在CmakeList.text文件中加载了，如下所示，注意，我这里只给出了与默认文件不一样的部分，注意，这里的jnigraphics虽然说我们已经在gradle中添加，但在这里不添加的话还是会报错，但是c/c++中使用Log的库只要在gradle中添加就可以，这里实在是没弄明白，如有高手知道请告知，感激不尽。"></a>这些都做完了之后，就可以在CmakeList.text文件中加载了，如下所示，注意，我这里只给出了与默认文件不一样的部分，注意，这里的jnigraphics虽然说我们已经在gradle中添加，但在这里不添加的话还是会报错，但是c/c++中使用Log的库只要在gradle中添加就可以，这里实在是没弄明白，如有高手知道请告知，感激不尽。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">             stackblur</span><br><span class="line"></span><br><span class="line">             # Sets the library as a shared library.</span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             # Provides a relative path to your source file(s).</span><br><span class="line">             src/main/cpp/stackblur.c )</span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">                       native-lib</span><br><span class="line">                       stackblur</span><br><span class="line">                       jnigraphics</span><br><span class="line">                       # Links the target library to the log library</span><br><span class="line">                       # included in the NDK.</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure>
<p>#####　因为我是在默认的native-lib中实现的函数，所以并没有添加另外的文件，当然，如果你实在另外的C/C++文件中实现的，就要添加其他的</p>
<h4 id="最后在java函数中调用native函数，就可以实现图片的毛玻璃化了，这里给出我的实现方法"><a href="#最后在java函数中调用native函数，就可以实现图片的毛玻璃化了，这里给出我的实现方法" class="headerlink" title="最后在java函数中调用native函数，就可以实现图片的毛玻璃化了，这里给出我的实现方法"></a>最后在java函数中调用native函数，就可以实现图片的毛玻璃化了，这里给出我的实现方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Bitmap blur(Bitmap srcBitmap) &#123;</span><br><span class="line">       blurBitmap(srcBitmap, 13);</span><br><span class="line">        return srcBitmap;</span><br><span class="line">    &#125;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;native-lib&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 参数r为对bitmap虚化的程度范围</span><br><span class="line">    static native void blurBitmap(Object bitmap, int r);</span><br></pre></td></tr></table></figure>
<h3 id="附加一点东西，为了实现截图的毛玻璃效果，我们一般还会压缩一下图片，这样才能使毛玻璃效果更快更自然，这里给出一个减少图片像素的方法"><a href="#附加一点东西，为了实现截图的毛玻璃效果，我们一般还会压缩一下图片，这样才能使毛玻璃效果更快更自然，这里给出一个减少图片像素的方法" class="headerlink" title="附加一点东西，为了实现截图的毛玻璃效果，我们一般还会压缩一下图片，这样才能使毛玻璃效果更快更自然，这里给出一个减少图片像素的方法"></a>附加一点东西，为了实现截图的毛玻璃效果，我们一般还会压缩一下图片，这样才能使毛玻璃效果更快更自然，这里给出一个减少图片像素的方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Bitmap compressScale(Bitmap bmp) &#123;</span><br><span class="line">        // 尺寸压缩倍数,值越大，图片尺寸越小</span><br><span class="line">        int ratio = 5;</span><br><span class="line">        // 压缩Bitmap到对应尺寸</span><br><span class="line">        Bitmap result = Bitmap.createBitmap(bmp.getWidth() / ratio, bmp.getHeight() / ratio, Bitmap.Config.ARGB_8888);</span><br><span class="line">        Canvas canvas = new Canvas(result);</span><br><span class="line">        Rect rect = new Rect(0, 0, bmp.getWidth() / ratio, bmp.getHeight() / ratio);</span><br><span class="line">        canvas.drawBitmap(bmp, null, rect, null);</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        // 把压缩后的数据存放到baos中</span><br><span class="line">        result.compress(Bitmap.CompressFormat.JPEG, 60 ,baos);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="配合上这个方法，毛玻璃效果就能更快得实现了"><a href="#配合上这个方法，毛玻璃效果就能更快得实现了" class="headerlink" title="配合上这个方法，毛玻璃效果就能更快得实现了"></a>配合上这个方法，毛玻璃效果就能更快得实现了</h4><h5 id="如上，如有错误，恳请指正"><a href="#如上，如有错误，恳请指正" class="headerlink" title="如上，如有错误，恳请指正"></a>如上，如有错误，恳请指正</h5>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>DialogFragment实现DatePicker</title>
    <url>/2017/10/05/DialogFragment%E5%AE%9E%E7%8E%B0DatePicker/</url>
    <content><![CDATA[<blockquote>
<p>先上效果图<br><img src="http://img.blog.csdn.net/20171022171615530?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="要实现这个效果，首先，我们得先创建一个Dialogfragment，注意我们只重写onCreateDialog函数，其他的函数就不用管了，在此之前我们先写好xml文件，很简单，只需要把datepicker作为根布局就可以了"><a href="#要实现这个效果，首先，我们得先创建一个Dialogfragment，注意我们只重写onCreateDialog函数，其他的函数就不用管了，在此之前我们先写好xml文件，很简单，只需要把datepicker作为根布局就可以了" class="headerlink" title="要实现这个效果，首先，我们得先创建一个Dialogfragment，注意我们只重写onCreateDialog函数，其他的函数就不用管了，在此之前我们先写好xml文件，很简单，只需要把datepicker作为根布局就可以了"></a>要实现这个效果，首先，我们得先创建一个Dialogfragment，注意我们只重写onCreateDialog函数，其他的函数就不用管了，在此之前我们先写好xml文件，很简单，只需要把datepicker作为根布局就可以了</h4><p>datepicker.xml<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;DatePicker xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">            android:id=&quot;@+id/datePicker&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:calendarViewShown=&quot;false&quot;&gt;</span><br><span class="line">&lt;/DatePicker&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="我们需要在onCreateDialog返回一个dialog，这个dialog我们一般都使用AlertDialog，现在官方已经不推荐使用Dialog了，具体代码如下："><a href="#我们需要在onCreateDialog返回一个dialog，这个dialog我们一般都使用AlertDialog，现在官方已经不推荐使用Dialog了，具体代码如下：" class="headerlink" title="我们需要在onCreateDialog返回一个dialog，这个dialog我们一般都使用AlertDialog，现在官方已经不推荐使用Dialog了，具体代码如下："></a>我们需要在onCreateDialog返回一个dialog，这个dialog我们一般都使用AlertDialog，现在官方已经不推荐使用Dialog了，具体代码如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">View v = LayoutInflater.from(getActivity())</span><br><span class="line">                .inflate(R.layout.datepicker, null);</span><br><span class="line">        final DatePicker datePicker = (DatePicker)v;</span><br><span class="line">        datePicker.setMinDate(TimeUtil.getDayLong());</span><br><span class="line">        //设置可选择的最小日期，TimeUtil是我自己写的工具类，返回当前日期的long值</span><br><span class="line">        AlertDialog.Builder dialogbuilder = new AlertDialog.Builder(getActivity())</span><br><span class="line">                .setView(datePicker)</span><br><span class="line">                .setTitle(R.string.datepicker_title)</span><br><span class="line">                .setPositiveButton(R.string.button_sure, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onClick(DialogInterface dialog, int which) &#123;            //添加自己的代码</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .setNegativeButton(R.string.button_cancel, null);</span><br><span class="line">                 return dialogbuilder.create();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>alertdialog的构造用到了十分典型的Builder模式，这个模式可以使我们更容易组织alerdialog。</p>
<h4 id="写完了dialogfragment之后，就可以在活动中调用它了，代码十分简单"><a href="#写完了dialogfragment之后，就可以在活动中调用它了，代码十分简单" class="headerlink" title="写完了dialogfragment之后，就可以在活动中调用它了，代码十分简单"></a>写完了dialogfragment之后，就可以在活动中调用它了，代码十分简单</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FragmentManager manager = getSupportFragmentManager(); </span><br><span class="line">DatePickerFragment datePickerFragment = new DatePickerFragment();</span><br><span class="line">//datePickerFragment即为我们写的继承dialogfragment的组件</span><br><span class="line">datePickerFragment.setActitityType(activityType);</span><br><span class="line">datePickerFragment.show(manager, &quot;DatePickerFragment&quot;);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="不过这个dialogfragment显示的方式可能有些难看，这里给出我的一个动画的实现方式"><a href="#不过这个dialogfragment显示的方式可能有些难看，这里给出我的一个动画的实现方式" class="headerlink" title="不过这个dialogfragment显示的方式可能有些难看，这里给出我的一个动画的实现方式"></a>不过这个dialogfragment显示的方式可能有些难看，这里给出我的一个动画的实现方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (dialog.getWindow() != null) &#123;</span><br><span class="line">            Window window=dialog.getWindow();</span><br><span class="line">            window.setWindowAnimations(R.style.dialogAnim);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>动画的xml代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style name=&quot;dialogAnim&quot; mce_bogus=&quot;1&quot; parent=&quot;android:Animation&quot;&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/dialog_push_in&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/dialog_push_out&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>dialog_push_in<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;scale</span><br><span class="line">        android:duration=&quot;@android:integer/config_shortAnimTime&quot;</span><br><span class="line">        android:fromYScale=&quot;0.5&quot;</span><br><span class="line">        android:fromXScale=&quot;0.4&quot;</span><br><span class="line">        android:toXScale=&quot;1.0&quot;</span><br><span class="line">        android:toYScale=&quot;1.0&quot;</span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;alpha</span><br><span class="line">        android:duration=&quot;@android:integer/config_shortAnimTime&quot;</span><br><span class="line">        android:fromAlpha=&quot;0.0&quot;</span><br><span class="line">        android:toAlpha=&quot;1.0&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p>
<p>dialog_push_out<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;scale</span><br><span class="line">        android:duration=&quot;@android:integer/config_shortAnimTime&quot;</span><br><span class="line">        android:fromYScale=&quot;1.0&quot;</span><br><span class="line">        android:fromXScale=&quot;1.0&quot;</span><br><span class="line">        android:toXScale=&quot;0.4&quot;</span><br><span class="line">        android:toYScale=&quot;0.5&quot;</span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;alpha</span><br><span class="line">        android:duration=&quot;@android:integer/config_shortAnimTime&quot;</span><br><span class="line">        android:fromAlpha=&quot;1.0&quot;</span><br><span class="line">        android:toAlpha=&quot;0.0&quot; /&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>自定义ViewGroup之扩展FloatingActionButton</title>
    <url>/2017/10/02/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E4%B9%8B%E6%89%A9%E5%B1%95FloatingActionButton/</url>
    <content><![CDATA[<blockquote>
<p>本文主要是实现一个ViewGroup容器，并实现在内部自由放置FloatingActionButton，与各种FloatingActionButton开源库不同的是只侧重基础的实现，但实际效果还算美观。</p>
</blockquote>
<h4 id="效果图如下所示"><a href="#效果图如下所示" class="headerlink" title="效果图如下所示"></a>效果图如下所示</h4><p><img src="http://img.blog.csdn.net/20171015184457415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="效果图"></p>
<h4 id="首先，我们先实现一个类似于竖直排布的线性布局的ViewGroup，创建一个FloatingActionButtonMenu类集成ViewGroup"><a href="#首先，我们先实现一个类似于竖直排布的线性布局的ViewGroup，创建一个FloatingActionButtonMenu类集成ViewGroup" class="headerlink" title="首先，我们先实现一个类似于竖直排布的线性布局的ViewGroup，创建一个FloatingActionButtonMenu类集成ViewGroup"></a>首先，我们先实现一个类似于竖直排布的线性布局的ViewGroup，创建一个FloatingActionButtonMenu类集成ViewGroup</h4><h5 id="第一步-获得父类的arginLayoutParams，这里直接使用系统自带attrs就可以了，要注意的是方法返回值必须为ViewGroup-LayoutParams，否则在运行时会报错，这与我们直接按ctrl-o选择的结果不一样。"><a href="#第一步-获得父类的arginLayoutParams，这里直接使用系统自带attrs就可以了，要注意的是方法返回值必须为ViewGroup-LayoutParams，否则在运行时会报错，这与我们直接按ctrl-o选择的结果不一样。" class="headerlink" title="第一步 获得父类的arginLayoutParams，这里直接使用系统自带attrs就可以了，要注意的是方法返回值必须为ViewGroup.LayoutParams，否则在运行时会报错，这与我们直接按ctrl+o选择的结果不一样。"></a>第一步 获得父类的arginLayoutParams，这里直接使用系统自带attrs就可以了，要注意的是方法返回值必须为ViewGroup.LayoutParams，否则在运行时会报错，这与我们直接按ctrl+o选择的结果不一样。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) &#123;</span><br><span class="line">        Log.d(tag, &quot;generateLayoutParams&quot;);</span><br><span class="line">        return new MarginLayoutParams(getContext(), attrs);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="第二步，重写onMeasure方法，这一步主要时得到我们实现的ViewGroup最后所占的空间，属性中match-parent与wrap-parent所对应的分别是MeasureSpec-EXACTLY和MeasureSpec-AT-MOST"><a href="#第二步，重写onMeasure方法，这一步主要时得到我们实现的ViewGroup最后所占的空间，属性中match-parent与wrap-parent所对应的分别是MeasureSpec-EXACTLY和MeasureSpec-AT-MOST" class="headerlink" title="第二步，重写onMeasure方法，这一步主要时得到我们实现的ViewGroup最后所占的空间，属性中match_parent与wrap_parent所对应的分别是MeasureSpec.EXACTLY和MeasureSpec.AT_MOST"></a>第二步，重写onMeasure方法，这一步主要时得到我们实现的ViewGroup最后所占的空间，属性中match_parent与wrap_parent所对应的分别是MeasureSpec.EXACTLY和MeasureSpec.AT_MOST</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        // 获得此ViewGroup上级容器为其推荐的宽和高，以及计算模式</span><br><span class="line">        // 所得既为设置match_parent时的大小</span><br><span class="line">        Log.d(tag, &quot;onMeasure&quot;);</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        int sizeWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        int sizeHeight = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        // 计算出所有的childView的宽和高</span><br><span class="line">        measureChildren(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        // 记录如果是wrap_content是设置的宽和高</span><br><span class="line">        int childCount = getChildCount();</span><br><span class="line">        MarginLayoutParams layoutParms = null;</span><br><span class="line">        //宽为各个子View的最大值，高为总和</span><br><span class="line">        int width = 0, height = 0;</span><br><span class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">            View childView = getChildAt(i);</span><br><span class="line">            layoutParms = (MarginLayoutParams) childView.getLayoutParams();</span><br><span class="line">            int cWidth = childView.getMeasuredWidth() + layoutParms.rightMargin + layoutParms.leftMargin;</span><br><span class="line">            int cHeight = childView.getMeasuredHeight();</span><br><span class="line">            if (cWidth &gt; width) &#123;</span><br><span class="line">                width = cWidth;</span><br><span class="line">            &#125;</span><br><span class="line">            height += cHeight + layoutParms.bottomMargin + layoutParms.topMargin;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * 若为match_parent则将宽高设置为上级推荐的大小</span><br><span class="line">         * 否则则设置为计算出的大小，即为wrap_parent</span><br><span class="line">         */</span><br><span class="line">        setMeasuredDimension((widthMode == MeasureSpec.EXACTLY)</span><br><span class="line">                ? sizeWidth : width, (heightMode == MeasureSpec.EXACTLY)</span><br><span class="line">                ? sizeHeight : height);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="第三步，重写onLayout函数，这个函数主要是制定容器中各个view相对于容器的位置，这里需要注意的是在进行计算时尽量使用子view的属性，用容器的属性进行计算可能会得到无法显示的结果"><a href="#第三步，重写onLayout函数，这个函数主要是制定容器中各个view相对于容器的位置，这里需要注意的是在进行计算时尽量使用子view的属性，用容器的属性进行计算可能会得到无法显示的结果" class="headerlink" title="第三步，重写onLayout函数，这个函数主要是制定容器中各个view相对于容器的位置，这里需要注意的是在进行计算时尽量使用子view的属性，用容器的属性进行计算可能会得到无法显示的结果"></a>第三步，重写onLayout函数，这个函数主要是制定容器中各个view相对于容器的位置，这里需要注意的是在进行计算时尽量使用子view的属性，用容器的属性进行计算可能会得到无法显示的结果</h5><blockquote>
<p>四个点坐标的位置如下图所示<br><img src="http://img.blog.csdn.net/20171002210536111?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM0ODc0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h5 id="我们这里所实现的布局类似于叠罗汉，在xml文件中最下面的控件，在容器中就是在最底部，在这里我还使除了控制按钮之外的所有view变为透明状态同时不可点击，这样做主要是使动画更容易实现"><a href="#我们这里所实现的布局类似于叠罗汉，在xml文件中最下面的控件，在容器中就是在最底部，在这里我还使除了控制按钮之外的所有view变为透明状态同时不可点击，这样做主要是使动画更容易实现" class="headerlink" title="我们这里所实现的布局类似于叠罗汉，在xml文件中最下面的控件，在容器中就是在最底部，在这里我还使除了控制按钮之外的所有view变为透明状态同时不可点击，这样做主要是使动画更容易实现"></a>我们这里所实现的布局类似于叠罗汉，在xml文件中最下面的控件，在容器中就是在最底部，在这里我还使除了控制按钮之外的所有view变为透明状态同时不可点击，这样做主要是使动画更容易实现</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">        Log.d(tag, &quot;onLayout&quot;);</span><br><span class="line">        int cCount = getChildCount();</span><br><span class="line">        MarginLayoutParams layoutParams;</span><br><span class="line">        /**</span><br><span class="line">         * 遍历所有childView根据其宽和高</span><br><span class="line">         * 指定相应位置</span><br><span class="line">         */</span><br><span class="line">        int height = 0;</span><br><span class="line">        for (int i = 0; i &lt; cCount; i++) &#123;</span><br><span class="line">            View childView = getChildAt(i);</span><br><span class="line">            layoutParams = (MarginLayoutParams) childView.getLayoutParams();</span><br><span class="line">            int cl = layoutParams.leftMargin;</span><br><span class="line">            int cr = cl + childView.getMeasuredWidth();</span><br><span class="line">            int ct = layoutParams.topMargin + height;</span><br><span class="line">            int cb = ct + childView.getMeasuredHeight();</span><br><span class="line">            childView.layout(cl, ct, cr, cb);</span><br><span class="line">            height += childView.getMeasuredHeight() + layoutParams.bottomMargin;</span><br><span class="line">            //使上面的子view全都不可见</span><br><span class="line">            if (i != cCount- 1)&#123;</span><br><span class="line">                childView.setAlpha(0f);</span><br><span class="line">                childView.setClickable(false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state = HIDE;</span><br><span class="line">        setClick(getChildAt(cCount- 1));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在最后面实现的函数是把最底部的view作为一个开关，由它来控制其他子view是否可见</p>
<h5 id="点击事件函数如下"><a href="#点击事件函数如下" class="headerlink" title="点击事件函数如下"></a>点击事件函数如下</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setClick(final View view)&#123;</span><br><span class="line">       view.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View v) &#123;</span><br><span class="line">               if (state == HIDE) &#123;</span><br><span class="line">                   //当状态为不可见时，点击按钮弹出所有隐藏view</span><br><span class="line">                   ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;rotation&quot;, 0f, rotation);</span><br><span class="line">                   animator.setDuration(duration);</span><br><span class="line">                   animator.start();</span><br><span class="line">                   for (int i = 0; i&lt; getChildCount() - 1; i++)&#123;</span><br><span class="line">                       View childView = getChildAt(i);</span><br><span class="line">                       //实现淡入效果</span><br><span class="line">                       ObjectAnimator chlidanimator = ObjectAnimator.ofFloat(childView, &quot;alpha&quot;, 0f, 1f);</span><br><span class="line">                       //实现拉伸效果</span><br><span class="line">                       ObjectAnimator otheranimator = ObjectAnimator.ofFloat(childView, &quot;scaleX&quot;, 1.0f, 1.2f, 1.0f);</span><br><span class="line">                       otheranimator.setDuration(400);</span><br><span class="line">                       chlidanimator.setDuration(400);</span><br><span class="line">                       otheranimator.start();</span><br><span class="line">                       chlidanimator.start();</span><br><span class="line">                       childView.setClickable(true);</span><br><span class="line">                       state = SHOW;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   //当状态为可见时，点击按钮隐藏所有view</span><br><span class="line">                   ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;rotation&quot;, rotation, 0f);</span><br><span class="line">                   animator.setDuration(duration);</span><br><span class="line">                   animator.start();</span><br><span class="line">                   for (int i = 0; i&lt; getChildCount() - 1; i++)&#123;</span><br><span class="line">                       View childView = getChildAt(i);</span><br><span class="line">                       ObjectAnimator chlidanimator = ObjectAnimator.ofFloat(childView, &quot;alpha&quot;, 1f, 0f);</span><br><span class="line">                       chlidanimator.setDuration(400);</span><br><span class="line">                       chlidanimator.start();</span><br><span class="line">                       childView.setClickable(false);</span><br><span class="line">                       state = HIDE;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="XML代码如下"><a href="#XML代码如下" class="headerlink" title="XML代码如下"></a>XML代码如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;com.android.betterway.myview.FloatingActionButtonMenu</span><br><span class="line">        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;172dp&quot;</span><br><span class="line">        android:layout_gravity=&quot;bottom|right&quot;</span><br><span class="line">        android:background=&quot;#00000000&quot;</span><br><span class="line">        android:layout_margin=&quot;15dp&quot;</span><br><span class="line">      &gt;</span><br><span class="line"></span><br><span class="line">        &lt;android.support.design.widget.FloatingActionButton</span><br><span class="line">            android:id=&quot;@+id/floatingActionButton7&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_margin=&quot;10dp&quot;</span><br><span class="line">            android:clickable=&quot;true&quot;</span><br><span class="line">            android:elevation=&quot;4dp&quot;</span><br><span class="line">            app:fabSize=&quot;mini&quot;</span><br><span class="line">            app:srcCompat=&quot;@drawable/ic_action_addsmart&quot;</span><br><span class="line">            fab:backgroundTint=&quot;@color/primary_light&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;android.support.design.widget.FloatingActionButton</span><br><span class="line">            android:id=&quot;@+id/floatingActionButton6&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_margin=&quot;10dp&quot;</span><br><span class="line">            android:clickable=&quot;true&quot;</span><br><span class="line">            app:fabSize=&quot;mini&quot;</span><br><span class="line">            app:srcCompat=&quot;@drawable/ic_action_addnormal&quot;</span><br><span class="line">            fab:backgroundTint=&quot;@color/primary_light&quot;</span><br><span class="line">            fab:elevation=&quot;4dp&quot;/&gt;</span><br><span class="line">        &lt;android.support.design.widget.FloatingActionButton</span><br><span class="line">            android:id=&quot;@+id/floatingActionButton5&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_margin=&quot;4dp&quot;</span><br><span class="line">            android:clickable=&quot;true&quot;</span><br><span class="line">            app:fabSize=&quot;normal&quot;</span><br><span class="line">            fab:elevation=&quot;5dp&quot;</span><br><span class="line">            app:srcCompat=&quot;@drawable/ic_action_add&quot;</span><br><span class="line">            fab:backgroundTint=&quot;@color/accent&quot;/&gt;</span><br><span class="line">    &lt;/com.android.betterway.myview.FloatingActionButtonMenu&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
</search>
